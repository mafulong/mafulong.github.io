<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>go并发编程题目 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/05/07/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="go并发编程题目"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="go并发编程题目"><meta name="og:description" content="go并发编程题目"><meta property="og:url" content="https://mafulong.github.io/2021/05/07/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-05-07"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="go并发编程题目"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">go并发编程题目</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/05/07 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Go" title="Go">Go</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6651 字，约 20 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="go并发编程题目">go并发编程题目</h2><h2 id="交替打印1-100的奇数偶数">交替打印1-100的奇数偶数</h2><p><a href="https://www.jishuchi.com/read/go-interview/3439">参考</a></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
	<span class="n">POOL</span> <span class="o">=</span> <span class="m">100</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">groutine1</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="n">nxt</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">POOL</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="m">2</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="n">dep</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"groutine-1:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">nxt</span> <span class="o">&lt;-</span> <span class="m">1</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">groutine2</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="n">nxt</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">POOL</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="m">2</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="n">dep</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"groutine-2:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">nxt</span> <span class="o">&lt;-</span> <span class="m">1</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">c1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">c2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">groutine1</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">groutine2</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span>
	<span class="n">c1</span> <span class="o">&lt;-</span> <span class="m">1</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>用chan 信号通知另一个goroutine执行。</p><p>用chan 信号阻塞等待通知</p><h2 id="用chan实现互斥锁">用chan实现互斥锁</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">num</span> <span class="kt">int</span>
<span class="k">func</span> <span class="n">add</span><span class="p">(</span><span class="n">h</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">wg</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
    <span class="n">h</span> <span class="o">&lt;-</span> <span class="m">1</span>
    <span class="n">num</span> <span class="o">+=</span> <span class="m">1</span>
    <span class="o">&lt;-</span><span class="n">h</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="n">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="n">add</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">wg</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"num:"</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="一堆任务限制并发度为3">一堆任务，限制并发度为3</h2><p>利用chan缓冲区</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// main_chan.go</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span> <span class="m">3</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span> <span class="c">//写</span>
		<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
			<span class="o">&lt;-</span><span class="n">ch</span>
		<span class="p">}(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">make(chan struct{}, 3)</code> 创建缓冲区大小为 3 的 channel，在没有被接收的情况下，至多发送 3 个消息则被阻塞。</li><li>开启协程前，调用 <code class="language-plaintext highlighter-rouge">ch &lt;- struct{}{}</code>，若缓存区满，则阻塞。</li><li>协程任务结束，调用 <code class="language-plaintext highlighter-rouge">&lt;-ch</code> 释放缓冲区。</li><li><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> 并不是必须的</li></ul><h2 id="非阻塞的尝试读chan或者写chan">非阻塞的尝试读chan或者写chan</h2><p>可能会因为阻塞而不成功，如果阻塞了就不会读写成功</p><p>非阻塞尝试下写</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span><span class="o">:</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div><p>非阻塞尝试下读</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span> <span class="n">done</span><span class="o">:</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div><p>无用测试code</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestB</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">a</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"写失败"</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">a</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"读失败"</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="超时控制">超时控制</h2><p>可以用time.After</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">xxx</span><span class="o">...</span>
  
	<span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"timeout"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="定时器">定时器</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">time</span><span class="o">.</span><span class="n">Tick</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">){</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></div></div><h2 id="实现一个可重入锁">实现一个可重入锁</h2><p><a href="https://segmentfault.com/a/1190000040092635">参考</a></p><p>重入锁就是一个user可以多次Lock 最后UnLock和Lock数量一致就解锁。 可重入锁又称为递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法时会自动获取锁，不会因为之前已经获取过还没释放而阻塞。</p><p>实现一个可重入锁需要这两点：</p><ul><li>记住持有锁的线程，比如user</li><li>统计重入的次数, 比如times，如果是同user，那么times不会有并发访问的</li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"runtime"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ReentrantLock</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">mu</span>       <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">owner</span>    <span class="kt">int</span>          <span class="c">// 当前持有锁的 Goroutine ID</span>
	<span class="n">recursion</span> <span class="kt">int</span>          <span class="c">// 当前 Goroutine 持有锁的次数</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rl</span> <span class="o">*</span><span class="n">ReentrantLock</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">gid</span> <span class="o">:=</span> <span class="n">getGoroutineID</span><span class="p">()</span> <span class="c">// 获取当前 Goroutine 的 ID</span>
	<span class="n">rl</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">rl</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">rl</span><span class="o">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">gid</span> <span class="p">{</span>
		<span class="c">// 如果当前 Goroutine 已持有锁，增加递归计数</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">recursion</span><span class="o">++</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c">// 等待锁被释放，成为新的锁持有者</span>
	<span class="k">for</span> <span class="n">rl</span><span class="o">.</span><span class="n">recursion</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="n">rl</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">gid</span>
	<span class="n">rl</span><span class="o">.</span><span class="n">recursion</span> <span class="o">=</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rl</span> <span class="o">*</span><span class="n">ReentrantLock</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">gid</span> <span class="o">:=</span> <span class="n">getGoroutineID</span><span class="p">()</span>
	<span class="n">rl</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">rl</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">rl</span><span class="o">.</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">gid</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">"unlock of unowned lock"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">rl</span><span class="o">.</span><span class="n">recursion</span><span class="o">--</span>
	<span class="k">if</span> <span class="n">rl</span><span class="o">.</span><span class="n">recursion</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="c">// 如果递归计数为 0，释放锁</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="m">0</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 获取 Goroutine ID 的辅助函数</span>
<span class="k">func</span> <span class="n">getGoroutineID</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="m">64</span><span class="p">)</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">Stack</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="no">false</span><span class="p">)</span>
	<span class="k">var</span> <span class="n">id</span> <span class="kt">int</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Sscanf</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="p">]),</span> <span class="s">"goroutine %d "</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">id</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">rl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ReentrantLock</span><span class="p">{}</span>

	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 trying to acquire lock..."</span><span class="p">)</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 acquired lock"</span><span class="p">)</span>

		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 trying to re-acquire lock..."</span><span class="p">)</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 re-acquired lock"</span><span class="p">)</span>

		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 releasing lock..."</span><span class="p">)</span>
		<span class="n">rl</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 released one lock level"</span><span class="p">)</span>

		<span class="n">rl</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Goroutine 1 fully released lock"</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div><p>检查times为0这个for循环有点挫，更好的是使用信号量。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ReentrantLock</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">lock</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
    <span class="n">cond</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span>
    <span class="n">recursion</span> <span class="kt">int32</span>
    <span class="n">host</span>     <span class="kt">int64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rt</span> <span class="o">*</span><span class="n">ReentrantLock</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">id</span> <span class="o">:=</span> <span class="n">GetGoroutineID</span><span class="p">()</span>
    <span class="n">rt</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="n">rt</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">rt</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="n">id</span><span class="p">{</span>
        <span class="n">rt</span><span class="o">.</span><span class="n">recursion</span><span class="o">++</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">rt</span><span class="o">.</span><span class="n">recursion</span> <span class="o">!=</span> <span class="m">0</span><span class="p">{</span>
        <span class="n">rt</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="n">rt</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="n">id</span>
    <span class="n">rt</span><span class="o">.</span><span class="n">recursion</span> <span class="o">=</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rt</span> <span class="o">*</span><span class="n">ReentrantLock</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">rt</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="n">rt</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">rt</span><span class="o">.</span><span class="n">recursion</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="n">rt</span><span class="o">.</span><span class="n">host</span> <span class="o">!=</span> <span class="n">GetGoroutineID</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"the wrong call host: (%d); current_id: %d; recursion: %d"</span><span class="p">,</span> <span class="n">rt</span><span class="o">.</span><span class="n">host</span><span class="p">,</span><span class="n">GetGoroutineID</span><span class="p">(),</span><span class="n">rt</span><span class="o">.</span><span class="n">recursion</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="n">rt</span><span class="o">.</span><span class="n">recursion</span><span class="o">--</span>
    <span class="k">if</span> <span class="n">rt</span><span class="o">.</span><span class="n">recursion</span> <span class="o">==</span> <span class="m">0</span><span class="p">{</span>
        <span class="n">rt</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Go</code>语言的发明者认为，如果当你的代码需要重入锁时，那就说明你的代码有问题了，我们正常写代码时，从入口函数开始，执行的层次都是一层层往下的，如果有一个锁需要共享给几个函数，那么就在调用这几个函数的上面，直接加上互斥锁就好了，不需要在每一个函数里面都添加锁，再去释放锁。</p><h2 id="实现一个读写锁">实现一个读写锁</h2><p><a href="https://yinwoods.github.io/2019/05/19/Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AF%BB%E5%86%99%E9%94%81/">参考</a></p><h2 id="实现连接池">实现连接池</h2><p>在 Go 语言中，实现一个基本的 <strong>连接池</strong> 是一个常见的需求，尤其是在处理数据库连接、HTTP 请求连接或其他类型的网络连接时。连接池的主要作用是复用已有的连接，避免频繁的建立和销毁连接，从而提高性能。</p><ul><li>channel存连接，并发读和取。select试探是否有空闲的。</li><li>api: 取, 还</li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Connection 模拟一个连接对象</span>
<span class="k">type</span> <span class="n">Connection</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ID</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c">// ConnectionPool 连接池结构</span>
<span class="k">type</span> <span class="n">ConnectionPool</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">pool</span>     <span class="k">chan</span> <span class="o">*</span><span class="n">Connection</span> <span class="c">// 存放连接的 channel</span>
	<span class="n">maxConns</span> <span class="kt">int</span>              <span class="c">// 最大连接数</span>
	<span class="n">mu</span>       <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>       <span class="c">// 保护连接池的并发访问, 创建时用到.</span>
<span class="p">}</span>

<span class="c">// NewConnectionPool 创建一个新的连接池</span>
<span class="k">func</span> <span class="n">NewConnectionPool</span><span class="p">(</span><span class="n">maxConns</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">ConnectionPool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ConnectionPool</span><span class="p">{</span>
		<span class="n">pool</span><span class="o">:</span>     <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="o">*</span><span class="n">Connection</span><span class="p">,</span> <span class="n">maxConns</span><span class="p">),</span> <span class="c">// 使用缓冲 channel 存放连接</span>
		<span class="n">maxConns</span><span class="o">:</span> <span class="n">maxConns</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// GetConnection 从连接池中获取一个连接</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ConnectionPool</span><span class="p">)</span> <span class="n">GetConnection</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="n">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">conn</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">p</span><span class="o">.</span><span class="n">pool</span><span class="o">:</span> <span class="c">// 从池中取出连接</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Reusing connection:"</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">conn</span><span class="p">,</span> <span class="no">nil</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// 如果没有空闲连接，可以选择创建新的连接</span>
		<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">createConnection</span><span class="p">(),</span> <span class="no">nil</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// createConnection 创建一个新的连接</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ConnectionPool</span><span class="p">)</span> <span class="n">createConnection</span><span class="p">()</span> <span class="o">*</span><span class="n">Connection</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

	<span class="c">// 如果连接池没有达到最大连接数，创建新的连接</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="n">maxConns</span> <span class="p">{</span>
		<span class="n">conn</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Connection</span><span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span> <span class="o">+</span> <span class="m">1</span><span class="p">}</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Creating new connection:"</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">conn</span>
	<span class="p">}</span>

	<span class="c">// 如果连接池已满，返回 nil 或报错</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// ReturnConnection 将连接放回连接池</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ConnectionPool</span><span class="p">)</span> <span class="n">ReturnConnection</span><span class="p">(</span><span class="n">conn</span> <span class="o">*</span><span class="n">Connection</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">p</span><span class="o">.</span><span class="n">pool</span> <span class="o">&lt;-</span> <span class="n">conn</span><span class="o">:</span> <span class="c">// 将连接放回池中</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Returning connection:"</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="c">// 如果池已满，则丢弃连接</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Connection pool is full, discarding connection:"</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 关闭连接池，清理所有连接</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ConnectionPool</span><span class="p">)</span> <span class="n">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="实现协程池">实现协程池</h2><p>线程池原理:  在线程池中存在几个概念：核心线程数、最大线程数、任务队列。核心线程数指的是线程池的基本大小；最大线程数指的是，同一时刻线程池中线程的数量最大不能超过该值；任务队列是当任务较多时，线程池中线程的数量已经达到了核心线程数，这时候就是用任务队列来存储我们提交的任务。  与其他池化技术不同的是，线程池是基于<code class="language-plaintext highlighter-rouge">生产者-消费者</code>模式来实现的，任务的提交方是生产者，线程池是消费者。当我们需要执行某个任务时，只需要把任务扔到线程池中即可。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Task 定义任务的结构体</span>
<span class="k">type</span> <span class="n">Task</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ID</span> <span class="kt">int</span>
  <span class="n">handle</span> <span class="k">func</span><span class="p">(){}</span>
<span class="p">}</span>

<span class="c">// GoroutinePool 定义协程池的结构体</span>
<span class="k">type</span> <span class="n">GoroutinePool</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">taskQueue</span> <span class="k">chan</span> <span class="n">Task</span>   <span class="c">// 存放任务的队列</span>
	<span class="n">wg</span>        <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span> <span class="c">// 等待所有任务完成</span>
	<span class="n">maxGoroutines</span> <span class="kt">int</span>      <span class="c">// 最大协程数</span>
<span class="p">}</span>

<span class="c">// NewGoroutinePool 创建一个新的协程池</span>
<span class="k">func</span> <span class="n">NewGoroutinePool</span><span class="p">(</span><span class="n">maxGoroutines</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">GoroutinePool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">GoroutinePool</span><span class="p">{</span>
		<span class="n">taskQueue</span><span class="o">:</span>    <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Task</span><span class="p">,</span> <span class="n">maxGoroutines</span><span class="p">),</span> <span class="c">// 任务队列的大小与最大协程数相同</span>
		<span class="n">maxGoroutines</span><span class="o">:</span> <span class="n">maxGoroutines</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Run 执行协程池</span>
<span class="k">func</span> <span class="p">(</span><span class="n">pool</span> <span class="o">*</span><span class="n">GoroutinePool</span><span class="p">)</span> <span class="n">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pool</span><span class="o">.</span><span class="n">maxGoroutines</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">pool</span><span class="o">.</span><span class="n">worker</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c">// 启动 maxGoroutines 个协程</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// worker 执行任务的工作函数</span>
<span class="k">func</span> <span class="p">(</span><span class="n">pool</span> <span class="o">*</span><span class="n">GoroutinePool</span><span class="p">)</span> <span class="n">worker</span><span class="p">(</span><span class="n">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">pool</span><span class="o">.</span><span class="n">taskQueue</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Worker %d started task %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
		<span class="c">// 模拟任务处理时间</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Worker %d finished task %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
		<span class="n">pool</span><span class="o">.</span><span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// 标记任务完成</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// AddTask 向协程池中添加任务</span>
<span class="k">func</span> <span class="p">(</span><span class="n">pool</span> <span class="o">*</span><span class="n">GoroutinePool</span><span class="p">)</span> <span class="n">AddTask</span><span class="p">(</span><span class="n">task</span> <span class="n">Task</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pool</span><span class="o">.</span><span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>        <span class="c">// 添加一个任务，等待协程完成</span>
	<span class="n">pool</span><span class="o">.</span><span class="n">taskQueue</span> <span class="o">&lt;-</span> <span class="n">task</span> <span class="c">// 将任务加入任务队列</span>
<span class="p">}</span>

<span class="c">// Wait 等待所有任务完成</span>
<span class="k">func</span> <span class="p">(</span><span class="n">pool</span> <span class="o">*</span><span class="n">GoroutinePool</span><span class="p">)</span> <span class="n">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">pool</span><span class="o">.</span><span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// 等待所有任务完成</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">taskQueue</span><span class="p">)</span> <span class="c">// 关闭任务队列</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// 创建一个最大协程数为 3 的协程池</span>
	<span class="n">pool</span> <span class="o">:=</span> <span class="n">NewGoroutinePool</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>

	<span class="c">// 启动协程池</span>
	<span class="n">pool</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>

	<span class="c">// 向池中添加 10 个任务</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">task</span> <span class="o">:=</span> <span class="n">Task</span><span class="p">{</span><span class="n">ID</span><span class="o">:</span> <span class="n">i</span><span class="p">}</span>
		<span class="n">pool</span><span class="o">.</span><span class="n">AddTask</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// 等待所有任务完成</span>
	<span class="n">pool</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"All tasks have been completed."</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div><h2 id="实现限流器">实现限流器</h2><p>参考系统设计里的限流器设计。</p><p>不能用atomic，实际只能用mutex。</p><p>参考个人博客: https://mafulong.eu.org/2021/04/12/%E9%99%90%E6%B5%81%E5%99%A8/#golang%E5%AE%9E%E7%8E%B0%E4%BB%A4%E7%89%8C%E6%A1%B6–%E9%98%BB%E5%A1%9Efifo</p><h2 id="实现熔断器">实现熔断器</h2></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
