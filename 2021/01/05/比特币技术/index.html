<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>比特币技术 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/01/05/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8A%80%E6%9C%AF/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="比特币技术"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="区块链入门 比特币技术"><meta name="og:description" content="区块链入门 比特币技术"><meta property="og:url" content="https://mafulong.github.io/2021/01/05/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8A%80%E6%9C%AF/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-01-05"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="比特币技术"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">比特币技术</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/05 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Web3" title="Web3">Web3</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 14230 字，约 41 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="区块链入门-比特币技术">区块链入门 比特币技术</h2><p>廖雪峰的区块链笔记。 <a href="https://liaoxuefeng.com/books/blockchain/bitcoin/basic/index.html">参考</a></p><h3 id="比特币解决的问题">比特币解决的问题</h3><p>比特币则是通过区块链技术，把整个账本全部公开，人手一份，全网相同，因此，修改账本不会被其他人承认。比特币的区块链就是一种存储了全部账本的链式数据库，通过一系列密码学理论进行防篡改，防双花。</p><p>比特币解决的是现金电子化后无需中央信任机构的交易问题，即M0如何通过网络进行价值传输。我们已经习惯了通过互联网对数字化的新闻、音乐、视频进行信息传输，因为信息传输的本质是复制，但现实世界的现金可不能复制。想象一下我们如何把100元现金通过网络发送给另一个人，同时确保交易前后两个人的现金总额保持不变。所以，中本聪的白皮书把比特币定义为“点对点的电子现金系统”。</p><p>区块链是由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：</p><p>比特币网络中是<strong>每次生成一个新区块</strong>，新区块中会打包<strong>多笔交易信息</strong>，</p><h2 id="区块链原理">区块链原理</h2><h3 id="交易信息的来源内存池mempool">交易信息的来源：内存池（Mempool）</h3><p><strong>什么是内存池？</strong></p><p>当用户（或钱包、交易所）发起一笔交易，例如从一个地址发送 BTC 到另一个地址，这笔交易会首先被广播到比特币网络，然后：</p><ol><li>网络中的节点会接收到这笔交易</li><li>节点会先对其进行验证（签名是否有效、余额是否够等）</li><li>验证无误后，这笔交易就被加入到<strong>内存池（Mempool）</strong></li></ol><hr /><h3 id="挖矿时如何生成区块">挖矿时如何生成区块？</h3><p>矿工创建新区块时：</p><ol><li><strong>从内存池中选择交易</strong>（优先选择手续费高的）</li><li>将这些交易打包成一个候选区块（称为 <code class="language-plaintext highlighter-rouge">block template</code>）</li><li>进行工作量证明（Proof of Work，解题）</li><li>谁先解出哈希，谁就<strong>生成新区块</strong>，广播给全网</li><li>其他节点验证区块，没问题就接受该区块，并加入区块链中</li></ol><hr /><h4 id="每个区块至少包含两笔交易">每个区块至少包含两笔交易：</h4><ol><li><strong>Coinbase 交易</strong>：矿工的奖励交易（包括区块奖励和所有交易的手续费）</li><li><strong>用户交易</strong>：从 Mempool 中打包进来的普通交易</li></ol><h4 id="情况两个矿工同时挖出区块产生短暂分叉">情况：两个矿工同时挖出区块，产生短暂分叉</h4><p>假设当前链到高度 <code class="language-plaintext highlighter-rouge">N</code>，现在两个矿工分别几乎同时挖出下一个新区块。 因为网络传播延迟，不是所有节点都立刻看到同一个区块</p><h4 id="解决机制最长链原则longest-chain-rule">解决机制：最长链原则（Longest Chain Rule）</h4><blockquote><p>比特币规定：<strong>所有节点只承认「工作量最多（最长）」的链为主链。</strong></p></blockquote><h3 id="分叉如何被解决">分叉如何被解决？</h3><ol><li><p>两条链并存时，网络中部分节点支持 <code class="language-plaintext highlighter-rouge">N+1a</code>，另一部分支持 <code class="language-plaintext highlighter-rouge">N+1b</code></p></li><li><p>下一轮，假设某个矿工在 <code class="language-plaintext highlighter-rouge">N+1a</code> 的链上挖出了 <code class="language-plaintext highlighter-rouge">N+2a</code>，并成功广播给大多数节点：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mathematica
   
   
CopyEdit
     区块 N
      /  \
区块 N+1a 区块 N+1b
     |
 区块 N+2a
</code></pre></div></div></li><li><p>所有节点看到 <code class="language-plaintext highlighter-rouge">N+2a</code> 后发现这条链「更长」，就<strong>切换到这个分支</strong></p></li><li><p><code class="language-plaintext highlighter-rouge">N+1b</code> 就成为<strong>孤块（orphan block）</strong>，被丢弃</p></li></ol><hr /><h4 id="孤块orphan-block">孤块（Orphan Block）</h4><ul><li>是被网络短暂接受但最终被抛弃的区块</li><li>其中的交易 <strong>不会丢失</strong>，而是重新回到 Mempool</li><li>这些交易可能会被重新打包进后续区块中</li></ul><h4 id="举个例子">举个例子：</h4><p>比如：</p><ul><li>A矿工和B矿工分别在北京和纽约，几乎同时挖出区块高度为 <code class="language-plaintext highlighter-rouge">850,000</code></li><li>A的区块传播到亚洲快一些，B的传播到美洲快</li><li>某矿工在接收到 A 的区块后成功挖出了 <code class="language-plaintext highlighter-rouge">850,001</code></li><li>这样整个网络最终选择了以 A 为主的链，B的链被回滚</li></ul><h3 id="初步广播并打包--最终确认">初步广播并打包 ≠ 最终确认</h3><p>在比特币中：</p><ul><li>你的交易被打包进某个区块 ✅，<strong>并不代表最终交易成功</strong></li><li>如果这个区块后来被抛弃（因为发生分叉），那么这个交易就<strong>等于没发生过</strong></li><li>这时交易会回到内存池（Mempool）中等待重新打包</li></ul><blockquote><p><strong>在区块链分叉发生时，交易是否成功，要看它是否最终出现在主链中。</strong></p></blockquote><h3 id="分叉中交易可能经历">分叉中交易可能经历：</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>被某个区块打包</td><td>暂时进入链中，但可能被分叉掉</td></tr><tr><td>区块被孤立（orphaned）</td><td>所有交易视为未确认，回到 Mempool</td></tr><tr><td>被新主链重新打包</td><td>再次等待确认，才算最终成功</td></tr></tbody></table><hr /><h3 id="所以为什么我们说交易要有确认数">所以为什么我们说交易要有确认数？</h3><p>比特币交易通常说：</p><blockquote><p>“建议等 <strong>6 个确认</strong>，再认为交易是最终不可逆的”</p></blockquote><p>确认数是指：</p><ul><li>某交易所在区块之后又被多少个区块所确认</li></ul><table><thead><tr><th>确认数</th><th>安全性说明</th></tr></thead><tbody><tr><td>0</td><td>仅在 Mempool，还没被打包</td></tr><tr><td>1</td><td>刚被打包，可能会被分叉</td></tr><tr><td>2~3</td><td>安全性逐渐提高</td></tr><tr><td>6+</td><td>基本不可逆（99.999% 安全）</td></tr></tbody></table><h4 id="为什么越多确认越安全">为什么越多确认越安全？</h4><p>因为要「回滚」你的交易，攻击者必须：</p><ol><li><strong>回滚区块 N 所在的整条链</strong></li><li>并从区块 N 开始挖出一个<strong>比现在主链还长的新链</strong></li><li>这需要消耗大量算力（PoW）</li></ol><h4 id="攻击成本随着确认数指数级上升">攻击成本随着确认数指数级上升</h4><ul><li><strong>确认数 = 1</strong>：攻击者只需要超过网络 50% 算力一点点，就有较高成功率</li><li><strong>确认数 = 6</strong>：攻击者需要极高算力和运气，在短时间内挖出 6 个新区块赶上主链</li><li><strong>确认数 &gt; 6</strong>：攻击成本已经接近不可能，除非攻击者掌握接近全球一半的比特币算力</li></ul><h4 id="如果真的持续分叉会怎样">如果真的持续分叉，会怎样？</h4><p>这种情况通常只在以下条件下出现：</p><ul><li>恶意攻击（如拥有超过 50% 算力的攻击者）</li><li>网络严重分区（partitioning）</li><li>共识机制被篡改（如协议漏洞）</li></ul><p>但一旦这样发生，整个比特币生态就会：</p><ul><li>出现链重组（reorg）</li><li>引发重大共识危机</li><li>开发者/社区可能会通过硬分叉修复</li></ul><h3 id="解释一下什么是区块高度block-height">解释一下什么是区块高度（Block Height）</h3><ul><li>区块高度是用来表示某个区块在整个区块链中的<strong>位置编号</strong></li><li>创世区块（第一个区块，Genesis Block）的高度是 <code class="language-plaintext highlighter-rouge">0</code></li><li>每新挖出一个区块，高度就 +1</li></ul><table><thead><tr><th>项目</th><th>含义</th></tr></thead><tbody><tr><td>区块高度 851,768</td><td>是比特币链上的第 851,768 个区块</td></tr><tr><td>作用</td><td>用于定位、检索、追踪、验证交易历史等</td></tr><tr><td>如何查看</td><td>区块浏览器（如 mempool.space）</td></tr></tbody></table><h3 id="常用哈希算法">常用哈希算法</h3><p>常用的哈希算法以及它们的输出长度如下：</p><table><thead><tr><th>哈希算法</th><th>输出长度(bit)</th><th>输出长度(字节)</th></tr></thead><tbody><tr><td>MD5</td><td>128 bit</td><td>16 bytes</td></tr><tr><td>RipeMD160</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-1</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-256</td><td>256 bits</td><td>32 bytes</td></tr><tr><td>SHA-512</td><td>512 bits</td><td>64 bytes</td></tr></tbody></table><p>比特币使用的哈希算法有两种：SHA-256和RipeMD160</p><p>SHA-256的理论碰撞概率是：尝试2的130次方的随机输入，有99.8%的概率碰撞。注意2130是一个非常大的数字，大约是1361万亿亿亿亿。以现有的计算机的计算能力，是不可能在短期内破解的。</p><p>比特币使用两种哈希算法，一种是对数据进行两次SHA-256计算，这种算法在比特币协议中通常被称为hash256或者dhash。</p><p>另一种算法是先计算SHA-256，再计算RipeMD160，这种算法在比特币协议中通常被称为hash160。</p><h3 id="区块链不可篡改特性">区块链不可篡改特性</h3><h3 id="merkle-hash">Merkle Hash</h3><p>在区块的头部，有一个Merkle Hash字段，它记录了本区块所有交易的Merkle Hash：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202507131010621.jpg" alt="Merkle Hash" /></p><p>Merkle Hash是把一系列数据的哈希根据一个简单算法变成一个汇总的哈希。</p><p>假设一个区块有4个交易，我们对每个交易数据做dhash，得到4个哈希值<code class="language-plaintext highlighter-rouge">a1</code>，<code class="language-plaintext highlighter-rouge">a2</code>，<code class="language-plaintext highlighter-rouge">a3</code>和<code class="language-plaintext highlighter-rouge">a4</code>：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a1 = dhash(tx1)
a2 = dhash(tx2)
a3 = dhash(tx3)
a4 = dhash(tx4)
</code></pre></div></div><p>注意到哈希值也可以看做数据，所以可以把<code class="language-plaintext highlighter-rouge">a1</code>和<code class="language-plaintext highlighter-rouge">a2</code>拼起来，<code class="language-plaintext highlighter-rouge">a3</code>和<code class="language-plaintext highlighter-rouge">a4</code>拼起来，再计算出两个哈希值<code class="language-plaintext highlighter-rouge">b1</code>和<code class="language-plaintext highlighter-rouge">b2</code>：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       ┌───────────────┐               ┌───────────────┐
       │b1=dhash(a1+a2)│               │b2=dhash(a3+a4)│
       └───────────────┘               └───────────────┘
               ▲                               ▲
       ┌───────┴───────┐               ┌───────┴───────┐
       │               │               │               │
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│a1=dhash(tx1)│ │a2=dhash(tx2)│ │a3=dhash(tx3)│ │a4=dhash(tx4)│
└─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘
</code></pre></div></div><p>最后，把<code class="language-plaintext highlighter-rouge">b1</code>和<code class="language-plaintext highlighter-rouge">b2</code>这两个哈希值拼起来，计算出最终的哈希值，这个哈希就是Merkle Hash：</p><p>如果交易的数量不恰好是4个怎么办？例如，只有3个交易时，第一个和第二个交易的哈希<code class="language-plaintext highlighter-rouge">a1</code>和<code class="language-plaintext highlighter-rouge">a2</code>可以拼起来算出<code class="language-plaintext highlighter-rouge">b1</code>，第三个交易只能算出一个哈希<code class="language-plaintext highlighter-rouge">a3</code>，这个时候，就把a3直接复制一份，算出<code class="language-plaintext highlighter-rouge">b2</code>，这样，我们也能最终计算出Merkle Hash：</p><p>如果有5个交易，我们可以看到，<code class="language-plaintext highlighter-rouge">a5</code>被复制了一份，以便计算出<code class="language-plaintext highlighter-rouge">b3</code>，随后<code class="language-plaintext highlighter-rouge">b3</code>也被复制了一份，以便计算出<code class="language-plaintext highlighter-rouge">c2</code>。总之，在每一层计算中，如果有单数，就把最后一份数据复制，最后一定能计算出Merkle Hash：</p><p>从Merkle Hash的计算方法可以得出结论：修改任意一个交易哪怕一个字节，或者交换两个交易的顺序，都会导致Merkle Hash验证失败，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用就是保证交易记录永远无法修改。</p><h3 id="block-hash">Block Hash</h3><p>区块本身用Block Hash——也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202507131010632.jpg" alt="Block Hash" /></p><p>区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。</p><p>由于下一个区块的Prev Hash又会指向当前区块，这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。</p><p>区块链的第一个区块（又称创世区块）并没有上一个区块，因此，它的Prev Hash被设置为<code class="language-plaintext highlighter-rouge">00000000...000</code>。</p><p>如果一个恶意的攻击者修改了一个区块中的某个交易，那么Merkle Hash验证就不会通过。所以，他只能重新计算Merkle Hash，然后把区块头的Merkle Hash也修改了。这时，我们就会发现，这个区块本身的Block Hash就变了，所以，下一个区块指向它的链接就断掉了。</p><p>由于比特币区块的哈希必须满足一个难度值，因此，攻击者必须先重新计算这个区块的Block Hash，然后，再把后续所有区块全部重新计算并且伪造出来，才能够修改整个区块链。</p><p>在后面的挖矿中，我们会看到，修改一个区块的成本就已经非常非常高了，要修改后续所有区块，这个攻击者必须掌握全网51%以上的算力才行，所以，修改区块链的难度是非常非常大的，并且，由于正常的区块链在不断增长，同样一个区块，修改它的难度会随着时间的推移而不断增加。</p><h2 id="p2p交易原理">P2P交易原理</h2><h3 id="数字签名算法">数字签名算法</h3><p>常用的数字签名算法有：RSA算法，DSA算法和ECDSA算法。比特币采用的签名算法是椭圆曲线签名算法：ECDSA，使用的椭圆曲线是一个已经定义好的标准曲线secp256k1：</p><p>比特币采用的ECDSA签名算法需要一个私钥和公钥组成的秘钥对：私钥本质上就是一个1～2256的随机数，公钥是由私钥根据ECDSA算法推算出来的，通过私钥可以很容易推算出公钥，所以不必保存公钥，但是，通过公钥无法反推私钥，只能暴力破解。</p><p>比特币的私钥是一个随机的非常大的256位整数。它的上限，确切地说，比2256要稍微小一点：</p><pre><code class="language-plain">0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140
</code></pre><p>而比特币的公钥是根据私钥推算出的两个256位整数。</p><p>如果用银行卡作比较的话，比特币的公钥相当于银行卡卡号，它是两个256位整数：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv10/img/202508170751390.png" alt="bitcoin-card" /></p><p>比特币的私钥相当于银行卡密码，它是一个256位整数：</p><pre><code class="language-plain">18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725
</code></pre><p>比特币钱包实际上就是帮助用户管理私钥的软件。因为比特币的钱包是给普通用户使用的，它有几种分类：</p><ul><li>本地钱包：是把私钥保存在本地计算机硬盘上的钱包软件，如<a href="https://electrum.org/">Electrum</a>；</li><li>手机钱包：和本地钱包类似，但可以直接在手机上运行，如<a href="https://bitpay.com/">Bitpay</a>；</li><li>在线钱包：是把私钥委托给第三方在线服务商保存；</li><li>纸钱包：是指把私钥打印出来保存在纸上；</li><li>脑钱包：是指把私钥记在自己脑袋里。</li></ul><p>对大多数普通用户来说，想要记住私钥非常困难，所以<em>强烈不建议使用脑钱包</em>。</p><h3 id="交易">交易</h3><p><a href="https://liaoxuefeng.com/books/blockchain/bitcoin/p2p/index.html#:~:text=%E5%85%AC%E9%92%A5%E5%AF%B9%E3%80%82-,%E4%BA%A4%E6%98%93,-%E6%88%91%E4%BB%AC%E5%86%8D%E6%9D%A5%E7%9C%8B">参考</a></p><p>记录在区块链上的交易。每个区块都记录了至少一笔交易，一笔交易就是把一定金额的比特币从一个输入转移到一个输出</p><p>在实际的交易中，输入比输出要稍微大一点点，这个差额就是隐含的交易费用，交易费用会算入当前区块的矿工收入中作为矿工奖励的一部分：</p><p>比特币实际的交易记录是由一系列交易构成，每一个交易都包含一个或多个输入，以及一个或多个输出。未花费的输出被称为UTXO：Unspent Transaction Output。</p><p>当我们要简单验证某个交易的时候，例如，对于交易<code class="language-plaintext highlighter-rouge">f36abd</code>，它记录的输入是<code class="language-plaintext highlighter-rouge">3f96ab</code>，索引号是<code class="language-plaintext highlighter-rouge">1</code>（索引号从<code class="language-plaintext highlighter-rouge">0</code>开始，<code class="language-plaintext highlighter-rouge">0</code>表示第一个输出，<code class="language-plaintext highlighter-rouge">1</code>表示第二个输出，以此类推），我们就根据<code class="language-plaintext highlighter-rouge">3f96ab</code>找到前面已发生的交易，再根据索引号找到对应的输出是<code class="language-plaintext highlighter-rouge">0.5</code>个比特币，所以，这笔交易的输入总计是<code class="language-plaintext highlighter-rouge">0.5</code>个比特币，输出分别是<code class="language-plaintext highlighter-rouge">0.4</code>个比特币和<code class="language-plaintext highlighter-rouge">0.09</code>个比特币，隐含的交易费用是<code class="language-plaintext highlighter-rouge">0.01</code>个比特币：</p><h3 id="地址">地址</h3><p>要特别注意，比特币的地址并不是公钥，而是公钥的哈希，即从公钥能推导出地址，但从地址不能反推公钥，因为哈希函数是单向函数。</p><p>比特币的公钥是根据私钥由ECDSA算法推算出来的，公钥有压缩和非压缩两种表示方法，可互相转换。</p><p>比特币的地址是公钥哈希的编码，并不是公钥本身，通过公钥可推导出地址。</p><h2 id="挖矿原理">挖矿原理</h2><p>在比特币的P2P网络中，有一类节点，它们时刻不停地进行计算，试图把新的交易打包成新的区块并附加到区块链上，这类节点就是矿工。因为每打包一个新的区块，打包该区块的矿工就可以获得一笔比特币作为奖励。所以，打包新区块就被称为挖矿。</p><p>比特币的挖矿原理就是一种工作量证明机制。工作量证明POW是英文Proof of Work的缩写。</p><h3 id="pow">PoW</h3><p>要让计算机实现工作量证明，必须找到一种工作量算法，让计算机无法在短时间内算出来。这种算法就是哈希算法。</p><p>通过改变区块头部的一个<code class="language-plaintext highlighter-rouge">nonce</code>字段的值，计算机可以计算出不同的区块哈希值：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202507131205860.jpg" alt="计算区块哈希" /></p><p>直到计算出某个特定的哈希值的时候，计算结束。这个哈希和其他的哈希相比，它的特点是前面有好几个0：</p><pre><code class="language-plain">hash256(block data, nonce=0) = 291656f37cdcf493c4bb7b926e46fee5c14f9b76aff28f9d00f5cca0e54f376f
hash256(block data, nonce=1) = f7b2c15c4de7f482edee9e8db7287a6c5def1c99354108ef33947f34d891ea8d
hash256(block data, nonce=2) = b6eebc5faa4c44d9f5232631f39ddf4211443d819208da110229b644d2a99e12
hash256(block data, nonce=3) = 00aeaaf01166a93a2217fe01021395b066dd3a81daffcd16626c308c644c5246
hash256(block data, nonce=4) = 26d33671119c9180594a91a2f1f0eb08bdd0b595e3724050acb68703dc99f9b5
hash256(block data, nonce=5) = 4e8a3dcab619a7ce5c68e8f4abdc49f98de1a71e58f0ce9a0d95e024cce7c81a
hash256(block data, nonce=6) = 185f634d50b17eba93b260a911ba6dbe9427b72f74f8248774930c0d8588c193
hash256(block data, nonce=7) = 09b19f3d32e3e5771bddc5f0e1ee3c1bac1ba4a85e7b2cc30833a120e41272ed
...
hash256(block data, nonce=124709132) = 00000000fba7277ef31c8ecd1f3fef071cf993485fe5eab08e4f7647f47be95c
</code></pre><p>比特币挖矿的工作量证明原理就是，不断尝试计算区块的哈希，直到计算出一个特定的哈希值，它比难度值要小。</p><p><strong>对于比特币挖矿来说，就是先给定一个难度值，然后不断变换<code class="language-plaintext highlighter-rouge">nonce</code>，计算Block Hash，直到找到一个比给定难度值低的Block Hash，就算成功挖矿。</strong></p><p>注意，难度值的<em>数值</em>越小，说明哈希值前面的<code class="language-plaintext highlighter-rouge">0</code>越多，计算的难度越大。</p><p>比特币网络的难度是不断变化的，它的难度保证大约每10分钟产生一个区块，而难度值在每2015个区块调整一次：如果区块平均生成时间小于10分钟，说明全网算力增加，难度也会增加，如果区块平均生成时间大于10分钟，说明全网算力减少，难度也会减少。因此，难度随着全网算力的增减会动态调整。</p><p>根据比特币每个区块的难度值和产出时间，就可以推算出整个比特币网络的全网算力。所以比特币的工作量证明被通俗地称之为挖矿。在同一时间，所有矿工都在努力计算下一个区块的哈希。而挖矿难度取决于全网总算力的百分比。举个例子，假设小明拥有全网总算力的百分之一，那么他挖到下一个区块的可能性就是1%，或者说，每挖出100个区块，大约有1个就是小明挖的。</p><p>为什么区块可以安全广播？因为Merkle Hash锁定了该区块的所有交易，而该区块的第一个coinbase交易输出地址是该矿工地址。每个矿工在挖矿时产生的区块数据都是不同的，所以无法窃取别人的工作量。</p><p>比特币总量被限制为约2100万个比特币，初始挖矿奖励为每个区块50个比特币，以后每4年减半。</p><h3 id="分叉">分叉</h3><p>如果两个矿工在同一时间各自找到了有效区块，注意，这两个区块是不同的，因为coinbase交易不同，所以Merkle Hash不同，区块哈希也不同。但它们只要符合难度值，就都是有效的。这个时候，网络上的其他矿工应该接收哪个区块并添加到区块链的末尾呢？答案是，都有可能。</p><p>但是最终，总有一个分叉首先挖到后续区块，这个时候，由于比特币网络采用最长分叉的共识算法，绿色分叉胜出，蓝色分叉被废弃，整个网络上的所有矿工又会继续在最长的链上继续挖矿。</p><p>由于区块链虽然最终会保持数据一致，但是，一个交易可能被打包到一个后续被孤立的区块中。所以，要确认一个交易被永久记录到区块链中，需要对交易进行确认。如果后续的区块被追加到区块链上，实际上就会对原有的交易进行确认，因为链越长，修改的难度越大。一般来说，经过6个区块确认的交易几乎是不可能被修改的。</p><h2 id="可编程支付原理">可编程支付原理</h2><h3 id="锁定脚本和解锁脚本">锁定脚本和解锁脚本</h3><p>比特币采用脚本的方式进行可编程支付：通过执行解锁脚本确认某个UTXO的资产可以被私钥持有人转移给其他人。</p><p>比特币的支付实际上并不是直接支付到对方的地址，而是一个脚本，这个脚本的意思是：谁能够提供另外一个脚本，让这两个脚本能顺利执行通过，谁就能花掉这笔钱：</p><p>所以，比特币交易的输出是一个锁定脚本，而下一个交易的输入是一个解锁脚本。必须提供一个解锁脚本，让锁定脚本正确运行，那么该输入有效，就可以花费该输出。</p><p>当小明给小红支付一笔比特币时，实际上小明创建了一个锁定脚本，该锁定脚本中引入了小红的地址。要想通过解锁脚本花费该输出，只有持有对应私钥的小红才能创建正确的解锁脚本（因为解锁脚本包含的签名只有小红的私钥才能创建），因此，小红事实上拥有了花费该输出的权利。</p><p>使用钱包软件创建的交易都是标准的支付脚本，但是，比特币的交易本质是成功执行解锁脚本和锁定脚本，所以，可以编写各种符合条件的脚本。比如，有人创建了一个交易，它的锁定脚本像这样：</p><pre><code class="language-plain">OP_HASH256
      DATA 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000
  OP_EQUAL
</code></pre><p>这有点像一个数学谜题。它的意思是说，谁能够提供一个数据，它的hash256等于<code class="language-plaintext highlighter-rouge">6fe28c0a...</code>，谁就可以花费这笔输出。所以，解锁脚本实际上只需要提供一个正确的数据，就可以花费这笔输出。点<a href="https://btc.com/a4bfa8ab6435ae5f25dae9d89e4eb67dfa94283ca751f393c1ddc5a837bbc31b">这里</a>查看谁花费了该输出。</p><p>比特币的脚本通过不同的指令还可以实现更灵活的功能。例如，多重签名可以让一笔交易只有在多数人同意的情况下才能够进行。最常见的多重签名脚本可以提供3个签名，只要任意两个签名被验证成功，这笔交易就可以成功。</p><pre><code class="language-plain">FROM: UTXO Hash#index
AMOUNT: 10.5 btc
TO: P2SH: OP_2 pk1 pk2 pk3 OP_3 OP_CHECKMULTISIG
</code></pre><p>也就是说，3个人中，只要任意两个人同意用他们的私钥提供签名，就可以完成交易。这种方式也可以一定程度上防止丢失私钥的风险。3个人中如果只有一个人丢失了私钥，仍然可以保证这笔输出是可以被花费的。</p><p>比特币的脚本不含条件判断、循环等复杂结构。上述脚本就是对输入的两个数据视作签名和公钥，然后先验证公钥哈希是否与地址相同，再根据公钥验证签名，这种标准脚本称之为P2PKH（Pay to Public Key Hash）脚本。</p><h3 id="多重签名">多重签名</h3><p>由比特币的签名机制可知，如果丢失了私钥，没有任何办法可以花费对应地址的资金。</p><p>这样就使得因为丢失私钥导致资金丢失的风险会很高。为了避免一个私钥的丢失导致地址的资金丢失，比特币引入了多重签名机制，可以实现分散风险的功能。</p><p>具体来说，就是假设N个人分别持有N个私钥，只要其中M个人同意签名就可以动用某个“联合地址”的资金。</p><p>发送给多重签名地址的交易创建的是P2SH脚本，而花费多重签名地址的资金需要的脚本就是M个签名+Redeem Script。</p><p>注意：从多重签名的地址本身并无法得知该多重签名使用的公钥，以及M-N的具体数值。必须将Redeem Script公示给每个私钥持有人，才能够验证多重签名地址是否正确（即包含了所有人的公钥，以及正确的M-N数值）。要花费多重签名地址的资金，除了M个私钥签名外，必须要有Redeem Script（可由所有人的公钥构造）。只有签名，没有Redeem Script是不能构造出解锁脚本来花费资金的。因此，保存多重签名地址的钱包必须同时保存Redeem Script。</p><p>利用多重签名，可以实现：</p><ul><li>1-2，两人只要有一人同意即可使用资金；</li><li>2-2，两人必须都同意才可使用资金；</li><li>2-3，3人必须至少两人同意才可使用资金；</li><li>4-7，7人中多数人同意才可使用资金。</li></ul><p>最常见的多重签名是2-3类型。例如，一个提供在线钱包的服务，为了防止服务商盗取用户的资金，可以使用2-3类型的多重签名地址，服务商持有1个私钥，用户持有两个私钥，一个作为常规使用，一个作为应急使用。这样，正常情况下，用户只需使用常规私钥即可配合服务商完成正常交易，服务商因为只持有1个私钥，因此无法盗取用户资金。如果服务商倒闭或者被黑客攻击，用户可使用自己掌握的两个私钥转移资金。</p><p>大型机构的比特币通常都使用多重签名地址以保证安全。</p><p>利用多重签名，可以使得私钥丢失的风险被分散到N个人手中，并且，避免了少数人窃取资金的问题。</p><p>比特币的多重签名最多允许15个私钥参与签名，即可实现1-2至15-15的任意组合（1⩽M⩽N⩽15）。</p><p>多重签名可以实现N个人持有私钥，其中M个人同意即可花费资金的功能。</p><p>多重签名降低了单个私钥丢失的风险。</p><p>支付比特币到一个多重签名地址实际上是创建一个P2SH输出。</p><h2 id="utxo模型">UTXO模型</h2><p>比特币的区块链由一个个区块串联构成，而每个区块又包含一个或多个交易。</p><p>如果我们观察任何一个交易，它总是由若干个输入（Input）和若干个输出（Output）构成，一个Input指向的是前面区块的某个Output，只有Coinbase交易（矿工奖励的铸币交易）没有输入，只有凭空输出。所以，任何交易，总是可以由Input溯源到Coinbase交易。</p><p>这些交易的Input和Output总是可以串联起来：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│Block #1     │     │Block #2     │     │Block #3     │     │Block #4     │
│┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│
││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT││
│└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│
│             │  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│
│             │  │  ││  │8.70│OUT├┼──┼──▶│IN│    │   ││  └──▶│IN│25.0│OUT││
│             │  └──▶│IN├────┼───┤│  │  │├──┤58.7│OUT││     │├──┼────┼───┤│
│             │     ││  │41.3│OUT├┼─┐└──▶│IN│    │   ││  ┌──▶│IN│66.3│OUT││
│             │     │└──┴────┴───┘│ │   │└──┴────┴───┘│  │  │└──┴────┴───┘│
└─────────────┘     └─────────────┘ │   └─────────────┘  │  └─────────────┘
                                    └────────────────────┘
</code></pre></div></div><p>还没有被下一个交易花费的Output被称为UTXO：Unspent TX Output，即未花费交易输出。给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和。</p><p>因此，比特币的交易模型和我们平时使用的银行账号有所不同，它并没有账户这个说法，只有UTXO。想要确定某个人拥有的比特币，并无法通过某个账户查到，必须知道此人控制的所有UTXO金额之和。</p><p>在钱包程序中，钱包管理的是一组私钥，对应的是一组公钥和地址。钱包程序必须从创世区块开始扫描每一笔交易，如果：</p><ol><li>遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；</li><li>遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。</li></ol><p>钱包的当前余额总是钱包地址关联的所有UTXO金额之和。</p><p>如果刚装了一个新钱包，导入了一组私钥，在钱包扫描完整个比特币区块之前，是无法得知当前管理的地址余额的。</p><ul><li>比特币区块链本质上是不可修改的“修改日志”（类似 MySQL 的 binlog），记录的是交易变更而非账户状态。</li><li>要高效查询余额，需先重放所有区块交易，构建本地“地址-余额”状态数据库，钱包多使用 LevelDB 存储该状态。 重建整个地址-余额数据库需要扫描整个区块链，并按每个交易依次更新记录，即可得到当前状态。</li><li>实时余额查询并不读取区块链原始数据，而是查本地已构建的状态表或由服务器返回查询结果。</li></ul><h2 id="hd钱包">HD钱包</h2><p>HD是Hierarchical Deterministic的缩写，意思是分层确定性。先确定根私钥root，然后根据索引计算每一层的子私钥：</p><h3 id="派生私钥">派生私钥</h3><p>在比特币的链上，实际上并没有账户的概念，某个用户持有的比特币，实际上是其控制的一组UTXO，而这些UTXO可能是相同的地址（对应相同的私钥），也可能是不同的地址（对应不同的私钥）。</p><p>出于保护隐私的目的，同一用户如果控制的UTXO其地址都是不同的，那么很难从地址获知某个用户的比特币持币总额。但是，管理一组成千上万的地址，意味着管理成千上万的私钥，管理起来非常麻烦。</p><p>能不能只用一个私钥管理成千上万个地址？实际上是可以的。虽然椭圆曲线算法决定了一个私钥只能对应一个公钥，但是，可以通过某种确定性算法，先确定一个私钥k1，然后计算出k2、k3、k4……等其他私钥，就相当于只需要管理一个私钥，剩下的私钥可以按需计算出来。</p><p>这种根据某种确定性算法，只需要管理一个根私钥，即可实时计算所有“子私钥”的管理方式，称为HD钱包。</p><p>HD是Hierarchical Deterministic的缩写，意思是分层确定性。先确定根私钥root，然后根据索引计算每一层的子私钥：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root
│
├─────────────┬─────────────┐
│             │             │
▼             ▼             ▼
k0            k1            k2 ...
│             │             │
├──┬──┐       ├──┬──┐       ├──┬──┐
│  │  │       │  │  │       │  │  │
▼  ▼  ▼       ▼  ▼  ▼       ▼  ▼  ▼
k0 k1 k2 ...  k0 k1 k2 ...  k0 k1 k2 ...
</code></pre></div></div><p>对于任意一个私钥k，总是可以根据索引计算它的下一层私钥kn</p><p>HD钱包采用的计算子私钥的算法并不是一个简单的SHA-256，私钥也不是普通的256位ECDSA私钥，而是一个扩展的512位私钥，记作xprv，它通过SHA-512算法配合ECC计算出子扩展私钥，仍然是512位。通过扩展私钥可计算出用于签名的私钥以及公钥。</p><p>简单来说，只要给定一个根扩展私钥（随机512位整数），即可计算其任意索引的子扩展私钥。扩展私钥总是能计算出扩展公钥，记作xpub</p><p>从xprv及其对应的xpub可计算出真正用于签名的私钥和公钥。之所以要设计这种算法，是因为扩展公钥xpub也有一个特点，那就是可以直接计算其子层级的扩展公钥</p><p>因为xpub只包含公钥，不包含私钥，因此，可以安全地把xpub交给第三方（例如，一个观察钱包），它可以根据xpub计算子层级的所有地址，然后在比特币的链上监控这些地址的余额，但因为没有私钥，所以只能看，不能花。</p><p>因此，HD钱包通过分层确定性算法，实现了以下功能：</p><ul><li>只要确定了扩展私钥xprv，即可根据索引计算下一层的任何扩展私钥；</li><li>只要确定了扩展公钥xpub，即可根据索引计算下一层的任何扩展公钥；</li><li>用户只需保存顶层的一个扩展私钥，即可计算出任意一层的任意索引的扩展私钥。</li></ul><p>从理论上说，扩展私钥的层数是没有限制的，每一层的数量被限制在0～232，原因是扩展私钥中只有4字节作为索引，因此索引范围是0～232。</p><p>通常把根扩展私钥记作<code class="language-plaintext highlighter-rouge">m</code>，子扩展私钥按层级记作<code class="language-plaintext highlighter-rouge">m/x/y/z</code>等：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m
│
├──────────────────────┐
│                      │
▼                      ▼
m/0                    m/1 ...
│                      │
├─────┬─────┐          ├─────┬─────┐
│     │     │          │     │     │
▼     ▼     ▼          ▼     ▼     ▼
m/0/0 m/0/1 m/0/2 ...  m/1/0 m/1/1 m/1/2 ...
</code></pre></div></div><p>例如，<code class="language-plaintext highlighter-rouge">m/0/2</code>表示从<code class="language-plaintext highlighter-rouge">m</code>扩展到<code class="language-plaintext highlighter-rouge">m/0</code>（索引为0）再扩展到<code class="language-plaintext highlighter-rouge">m/0/2</code>（索引为2）。</p><p>但是HD钱包的扩展私钥算法有个潜在的安全性问题，就是如果某个层级的xprv泄露了，可反向推导出上层的xprv，继而推导出整个HD扩展私钥体系。为了避免某个子扩展私钥的泄漏导致上层扩展私钥被反向推导，HD钱包还有一种硬化的衍生计算方式（Hardened Derivation），它通过算法“切断”了母扩展私钥和子扩展私钥的反向推导。HD规范把索引0～231作为普通衍生索引，而索引231～232作为硬化衍生索引，硬化衍生索引通常记作0’、1’、2’……，即索引0’=231，1’=231+1，2’=231+2，以此类推。</p><p>因此，<code class="language-plaintext highlighter-rouge">m/44'/0</code>表示的子扩展私钥，它的第一层衍生索引<code class="language-plaintext highlighter-rouge">44'</code>是硬化衍生，实际索引是231+44=2147483692。从<code class="language-plaintext highlighter-rouge">m/44'</code>无法反向推导出<code class="language-plaintext highlighter-rouge">m</code>。</p><p>在只有扩展公钥的情况下，只能计算出普通衍生的子公钥，无法计算出硬化衍生的子扩展公钥，即可计算出的子扩展公钥索引被限制在0～231。因此，观察钱包能使用的索引是0～231。</p><h3 id="硬化派生-vs-普通派生bip-32">硬化派生 vs 普通派生（BIP-32）</h3><table><thead><tr><th>项目</th><th>普通派生（Normal）</th><th>硬化派生（Hardened）</th></tr></thead><tbody><tr><td>索引范围</td><td>0 ～ 2³¹ - 1</td><td>2³¹ ～ 2³² - 1（如 44’ 实为 2147483692）</td></tr><tr><td>输入</td><td>父 <strong>公钥</strong> + 子索引.<br />m/0 ← 子索引 0<br />m/1 ← 子索引 1<br />m/2 ← 子索引 2</td><td>父 <strong>私钥</strong> + 子索引</td></tr><tr><td>是否可逆</td><td>❌ 子私钥可推出父公钥，可能有风险</td><td>✅ 子私钥无法推出父密钥或公钥</td></tr><tr><td>适用场景</td><td>创建公钥链（如观察钱包）</td><td>增强安全性，防止私钥泄露推导父密钥</td></tr><tr><td>安全性</td><td>较低（若子私钥泄露 + 父公钥 → 推导父私钥）</td><td>高（子私钥无父密钥信息）</td></tr><tr><td>常用路径</td><td>如 <code class="language-plaintext highlighter-rouge">m/0/1</code></td><td>如 <code class="language-plaintext highlighter-rouge">m/44'/0'/0'</code></td></tr></tbody></table><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">普通派生</span><span class="err">：</span>
<span class="nc">ChildPubKey</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nc">ParentPubKey</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span>
<span class="o">→</span> <span class="n">可生成</span><span class="err">“</span><span class="n">观察钱包</span><span class="err">”</span>

<span class="n">硬化派生</span><span class="err">：</span>
<span class="nc">ChildPrivKey</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nc">ParentPrivKey</span><span class="o">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="err">³¹</span><span class="o">)</span>
<span class="o">→</span> <span class="n">只靠私钥能派生</span><span class="err">，</span><span class="n">防止反向推导</span>
</code></pre></div></div><h3 id="派生标准"><strong>派生标准</strong></h3><p>比特币的<a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a>规范定义了一种如何派生私钥的标准，它本身非常简单：</p><pre><code class="language-plain">m / purpose' / coin_type' / account' / change / address_index
</code></pre><p>其中，<code class="language-plaintext highlighter-rouge">purpose</code>总是<code class="language-plaintext highlighter-rouge">44</code>，<code class="language-plaintext highlighter-rouge">coin_type</code>在<a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">SLIP-44</a>中定义，例如，<code class="language-plaintext highlighter-rouge">0=BTC</code>，<code class="language-plaintext highlighter-rouge">2=LTC</code>，<code class="language-plaintext highlighter-rouge">60=ETH</code>等。<code class="language-plaintext highlighter-rouge">account</code>表示用户的某个“账户”，由用户自定义索引，<code class="language-plaintext highlighter-rouge">change=0</code>表示外部交易，<code class="language-plaintext highlighter-rouge">change=1</code>表示内部交易，<code class="language-plaintext highlighter-rouge">address_index</code>则是真正派生的索引为0～231的地址。</p><p>例如，某个比特币钱包给用户创建的一组HD地址实际上是：</p><ul><li>m/44’/0’/0’/0/0</li><li>m/44’/0’/0’/0/1</li><li>m/44’/0’/0’/0/2</li><li>m/44’/0’/0’/0/3</li><li>…</li></ul><p>如果是莱特币钱包，则用户的HD地址是：</p><ul><li>m/44’/2’/0’/0/0</li><li>m/44’/2’/0’/0/1</li><li>m/44’/2’/0’/0/2</li><li>m/44’/2’/0’/0/3</li><li>…</li></ul><h3 id="助记词">助记词</h3><p>BIP-39规范通过使用助记词+口令来生成HD钱包的种子，用户只需记忆助记词和口令即可随时恢复HD钱包。</p><p>丢失助记词或者丢失口令均会导致HD钱包丢失。</p><p>助记词是一组人类可读的单词，用于表示一个随机数种子，能<strong>恢复整个 HD 钱包的所有私钥、公钥和地址</strong>。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eg</span><span class="k">:</span> <span class="kt">legal</span> <span class="kt">winner</span> <span class="kt">thank</span> <span class="kt">year</span> <span class="kt">wave</span> <span class="kt">sausage</span> <span class="kt">worth</span> <span class="kt">useful</span> <span class="kt">legal</span> <span class="kt">winner</span> <span class="kt">thank</span> <span class="kt">yellow</span>
</code></pre></div></div><p>常见长度有：12 / 15 / 18 / 21 / 24 个单词</p><p><strong>种子和助记词的关系</strong></p><p>在 BIP-39 标准中：</p><ul><li><strong>助记词（mnemonic words）</strong> 是 12/15/18/24 个词的人类可读表示</li><li><strong>助记词 → 通过 PBKDF2 → 派生出 512 位的种子</strong></li><li><strong>种子 → 用于生成 HD 钱包的根密钥（m）</strong></li></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
助记词词组（24词） 
→ PBKDF2 加盐派生 
→ 生成种子（512位） 
→ BIP-32 生成根私钥 m 
→ 派生整个 HD 钱包树
</code></pre></div></div><h3 id="地址监控">地址监控</h3><p>一个HD钱包管理的是一组自动计算的地址。以比特币为例，在确定了根扩展私钥<code class="language-plaintext highlighter-rouge">m</code>后，得到一组地址为<code class="language-plaintext highlighter-rouge">m/44'/0'/0'/0/x</code>，其中x=0~231。</p><p>HD钱包需要在链上监控每个TX的输入和输出，看看上述管理的一组地址是否存在与输入和输出中。如果作为输入，则钱包余额减少，如果作为输出，则钱包余额增加。</p><p>现在问题来了：如何根据TX的输入和输出地址快速判断这些地址中是否存在HD钱包管理的地址？</p><p>首先，可用的地址高达231个，这个数太大了，用户不可能用完，因此，HD钱包只会预生成前1000个地址（即索引号为0～999）并保存在本地数据库中，如果不够了，再继续扩展1000个，这样，HD钱包管理的地址数量不会太大。</p><p>要做到高效的查询和低空间占用率，可以使用布隆过滤器（Bloom Filter），它是由Burton Howard Bloom在1970年提出的，其原理是将每个元素通过若干个哈希函数映射成一个位数组的若干个点，将其置1。检索的时候，先计算给定元素对应位是否全1，如果是全1，则给定元素很可能存在，否则，元素必定不存在。</p><p>因此，Bloom Filter有个重要特点，就是判断元素时，如果不存在，那么肯定不存在，如果存在，实际上是以一定概率存在（例如，99%），还需要再次从数据库查询以确定元素真的存在。</p></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
