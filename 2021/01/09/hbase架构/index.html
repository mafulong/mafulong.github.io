<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>hbase架构 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/01/09/hbase%E6%9E%B6%E6%9E%84/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="hbase架构"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="列式存储"><meta name="og:description" content="列式存储"><meta property="og:url" content="https://mafulong.github.io/2021/01/09/hbase%E6%9E%B6%E6%9E%84/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-01-09"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="hbase架构"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">hbase架构</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/09 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Database" title="Database">Database</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6406 字，约 19 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="列式存储">列式存储</h1><p>列式存储（Column-based）是相对于行式存储来说的，新兴的HBase，GP等分布式数据库均采用列式存储，一列中的数据在存储介质中以连续存储形式存在。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv8/v8/202306071207481.webp" alt="img" style="zoom:50%;" /></p><p>依然假设磁盘一次可以读取 3 个方框的数据(实际按 byte 读取)。可以看出按列存储组织数据的方式，只需要 1 次磁盘操作就可以完成。</p><p>对比</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv8/v8/202306071208084.png" alt="image-20230607120814050" style="zoom:50%;" /></p><p>基于列模式的存储，天然就会具备以下几个优点：</p><ul><li><p>自动索引</p><p>因为基于列存储，所以每一列本身就相当于索引。所以在做一些需要索引的操作时，就不需要额外的数据结构来为此列创建合适的索引。</p></li><li><p>利于数据压缩</p><p>利于压缩有两个原因。一来你会发现大部分列数据基数其实是重复的，拿上面的数据来说，因为同一个 author 会发表多篇博客，所以 author 列出现的所有值的基数肯定是小于博客数量的，因此在 author 列的存储上其实是不需要存储博客数量这么大的数据量的；二来相同的列数据类型一致，这样利于数据结构填充的优化和压缩，而且对于数字列这种数据类型可以采取更多有利的算法去压缩存储。</p></li></ul><h1 id="hbase架构">hbase架构</h1><p>Hadoop文件分发系统 ( Hadoop Distributed File System (HDFS) )和Hadoop数据库（HBase）是大数据生态系统的关键组成部分</p><p>Hbase全称为Hadoop Database，即hbase是hadoop的数据库，是一个分布式的存储系统。Hbase利用Hadoop的HDFS作为其文件存储系统，利用Hadoop的MapReduce来处理Hbase中的海量数据。利用zookeeper作为其协调工具。</p><blockquote><p><a href="https://juejin.cn/post/6844904103756169230">参考</a></p><p>HBase可以认为是山寨版的Bigtable，因此其架构也是类似的，只是各个部件换了名字，对应关系如下： Chubby ===&gt; Zookeeper Master ===&gt; Master GFS ===&gt; HDFS Tablet Server ===&gt; HRegion Server SSTable ===&gt; HFile Tablet Log ===&gt; HLog</p></blockquote><h1 id="1-hbase">1 HBase</h1><h2 id="11-hbase-架构">1.1 HBase 架构</h2><blockquote><p>HBase 是什么？其架构是怎样的？</p></blockquote><p>HBase（Hadoop DataBase），是一种非关系型分布式数据库（NoSQL），支持海量数据存储（官方：单表支持百亿行百万列）。HBase 采用经典的主从架构，底层依赖于 HDFS，并借助 ZooKeeper 作为协同服务，其架构大致如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/111.png" alt="img" /></p><p>其中，</p><ul><li>Master：HBase 管理节点。管理 Region Server，分配 Region 到 Region Server，提供负载均衡能力；执行创建表等 DDL 操作。</li><li>Region Server：HBase 数据节点。管理 Region，一个 Region Server 可包含多个 Region，Region 相当于表的分区。客户端可直接与 Region Server 通信，实现数据增删改查等 DML 操作。</li><li>ZooKeeper：协调中心。负责 Master 选举，节点协调，存储 hbase:meta 等元数据。</li><li>HDFS：底层存储系统。负责存储数据，Region 中的数据通过 HDFS 存储。</li></ul><p>对 HBase 全局有了基本理解后，我认为有几个比较重要的点值得关注：HBase 数据模型、Region 的概念、数据路由。</p><h2 id="12-hbase-数据模型">1.2 HBase 数据模型</h2><blockquote><p>HBase 如何管理数据？（逻辑层）</p></blockquote><p>HBase 的数据模型和 MySQL 等关系型数据库有比较大的区别，其是一种 ”Schema-Flexiable“ 的理念。</p><ol><li>在表的维度，其包含若干行，每一行以 RowKey 来区分。</li><li>在行的维度，其包含若干列族，列族类似列的归类，但不只是逻辑概念，底层物理存储也是以列族来区分的（一个列族对应不同 Region 中的一个 Store）。</li><li>在列族的维度，其包含若干列，列是动态的。与其说是列，不如说是一个个键值对，Key 是列名，Value 是列值。</li></ol><p>HBase 的表结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv2/v2/76.png" alt="img" /></p><ul><li>RowKey（行键）：RowKey 是字典有序的，HBase 基于 RowKey 实现索引；</li><li>Column Family（列族）：纵向切割，一行可有多个列族，一个列族可有任意个列；</li><li>Key-Value（键值对）：每一列存储的是一个键值对，Key 是列名，Value 是列值；</li><li>Byte（数据类型）：数据在 HBase 中以 Byte 存储，实际的数据类型交由用户转换；</li><li>Version（多版本）：每一列都可配置相应的版本，获取指定版本的数据（默认返回最新版本）；</li><li>稀疏矩阵：行与行之间的列数可以不同，但只有实际的列才会占用存储空间。</li></ul><h2 id="13-region">1.3 Region</h2><blockquote><p>HBase 如何管理数据？（物理层）</p></blockquote><p>Region 是 HBase 中的概念，类似 RDBMS 中的分区。</p><ol><li>Region 是表的横向切割，一个表由一个或多个 Region 组成，Region 被分配到各个 Region Server；</li><li>一个 Region 根据列族分为多个 Store，每个 Store 由 MemStore 和 StoreFile 组成；数据写入 MemStore，MemStore 类似输入缓冲区，持久化后为 StoreFile；数据写入的同时会更新日志 WAL，WAL 用于发生故障后的恢复，保障数据读写安全；</li><li>一个 StoreFile 对应一个 HFile，HFile 存储在 HDFS 。</li></ol><p>下面是我梳理的大致模型：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/115.png" alt="img" /></p><p><strong>1）Region 是一个 RowKey Range</strong></p><p>每个 Region 实际上是一个 RowKey Range，比如 Region A 存放的 RowKey 区间为 [aaa,bbb)，Region B 存放的 RowKey 区间为 [bbb,ccc) ，以此类推。Region 在 Region Server 中存储也是有序的，Region A 必定在 Region B 前面。</p><p><em>注：这里将 RowKey 设计为 aaa，而不是 1001 这样的数字，是为了强调 RowKey 并非只能是数字，只要能进行字典排序的字符都是可以的，如：abc-123456 。</em></p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/85.png" alt="img" /></p><p><strong>2）数据被路由到各个 Region</strong></p><p>表由一个或多个 Region 组成（逻辑），Region Server 包含一个或多个 Region（物理）。数据的路由首先要定位数据存储在哪张表的哪个 Region，表的定位直接根据表名，Region 的定位则根据 RowKey（因为每个 Region 都是一个 RowKey Range，因此根据 RowKey 很容易知道其对应的 Region）。</p><p><em>注：Master 默认采用 DefaultLoadBalancer 策略分配 Region 给 Region Server，类似轮询方式，可保证每个 Region Server 拥有相同数量的 Region（这里只是 Region 的数量相同，但还是有可能出现热点聚集在某个 Region，从而导致热点聚集在某个 Region Server 的情况）。</em></p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/159.png" alt="img" /></p><p><strong>3）当一个表太大时，Region 将自动分裂</strong></p><ul><li>自动分裂</li></ul><p>0.94 版本之前，Region 分裂策略为 ConstantSizeRegionSplitPolicy ，根据一个固定值触发分裂。</p><p>0.94 版本之后，分裂策略默认为 IncreasingToUpperBoundRegionSplitPolicy，该策略会根据 Region 数量和 StoreFile 的最大值决策。当 Region 的数量小于 9 且 StoreFile 的最大值小于某个值时，分裂 Region；当Region数量大于9 时，采用 ConstantSizeRegionSplitPolicy 。</p><ul><li>手动分裂</li></ul><p>在 ConstantSizeRegionSplitPolicy 下，通过设置 hbase.hregion.max.filesize 控制 Region 分裂。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/63.png" alt="img" /></p><h2 id="14-数据路由-hbasemeta">1.4 数据路由 hbase:meta</h2><blockquote><p>HBase 是分布式数据库，那数据怎么路由？</p></blockquote><p>数据路由借助 hbase:meta 表完成，hbase:meta 记录的是所有 Region 的元数据信息，hbase:meta 的位置记录在 ZooKeeper 。</p><p><em>注：一些比较老的文章可能会提到 .root 和 .meta 两个表。事实上， .root 和 .meta 两个表是 HBase 0.96 版本之前的设计。在 0.96 版本后，.root 表已经被移除，.meta 表更名为 hbase：meta。</em></p><p>hbase:meta 表的格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/89.png" alt="img" /></p><p>其中，</p><ul><li>table：表名；</li><li>region start key：Region 中的第一个 RowKey，如果 region start key 为空，表示该 Region 是第一个 Region；</li><li>region id：Region 的 ID，通常是 Region 创建时的 timestamp；</li><li>regioninfo：该 Region 的 HRegionInfo 的序列化值；</li><li>server：该 Region 所在的 Region Server 的地址；</li><li>serverstartcode：该 Region 所在的 Region Server 的启动时间。</li></ul><p><strong>一条数据的写入流程：</strong></p><p>数据写入时需要指定表名、Rowkey、数据内容。</p><ol><li>HBase 客户端访问 ZooKeeper，获取 hbase:meta 的地址，并缓存该地址；</li><li>访问相应 Region Server 的 hbase:meta；</li><li>从 hbase:meta 表获取 RowKey 对应的 Region Server 地址，并缓存该地址；</li><li>HBase 客户端根据地址直接请求 Region Server 完成数据读写。</li></ol><p><em>注 1：数据路由并不涉及Master，也就是说 DML 操作不需要 Master 参与。借助 hbase:meta，客户端直接与 Region Server 通信，完成数据路由、读写。</em></p><p><em>注 2：客户端获取 hbase:meta 地址后，会缓存该地址信息，以此减少对 ZooKeeper 的访问。同时，客户端根据 RowKey 查找 hbase:meta，获取对应的 Region Server 地址后，也会缓存该地址，以此减少对 hbase:meta 的访问。因为 hbase:meta 是存放在 Region Server 的一张表，其大小可能很大，因此不会缓存 hbase:meta 的完整内容。</em></p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/26.png" alt="img" /></p><h2 id="15-hbase-适用场景">1.5 HBase 适用场景</h2><ol><li>不需要复杂查询的应用。HBase 原生只支持基于 RowKey 的索引，对于某些复杂查询（如模糊查询，多字段查询），HBase 可能需要全表扫描来获取结果。</li><li>写密集应用。HBase 是一个写快读慢（慢是相对的）的系统。HBase 是根据 Google 的 BigTable 设计的，典型应用就是不断插入新数据（如 Google 的网页信息）。</li><li>对事务要求不高的应用。HBase 只支持基于 RowKey 的事务。</li><li>对性能、可靠性要求高的应用。HBase 不存在单点故障，可用性高。</li><li>数据量特别大的应用。HBase 支持百亿行百万列的数据量，单个 Region 过大将自动触发分裂，具备较好的伸缩能力。</li></ol><h1 id="2-hbase-与-mysql-的区别">2 HBase 与 MySQL 的区别？</h1><blockquote><p>HBase 和 MySQL 的主要区别？</p></blockquote><h2 id="21-mysql">2.1 MySQL</h2><p>MySQL 表结构规整，每一行有固定的列。</p><ul><li>创建表时，需要指定表名，预设字段（列）个数以及数据类型，Schema 是固定的。</li><li>插入数据时，只需根据表的 Schema 填充每个列的值即可。如果 Schema 没有该列，则无法插入。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv2/v2/35.png" alt="img" /></p><h2 id="22-hbase">2.2 HBase</h2><p>HBase 支持动态列，不同行可拥有不同数量的列，可动态增加新的列。HBase 的表结构看起来杂乱无章，但却有利于存储稀疏数据。</p><ul><li>创建表时，需指定表名、列族，无需指定列的个数、数据类型，Schema 是灵活的。</li><li>插入数据时，需要指定表名、列族、RowKey、若干个列（列名和列值），这里列的个数可以是一个或多个。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/9.png" alt="img" /></p><h2 id="23-对比">2.3 对比</h2><p>进一步，假设 ct_account_info_demo 表中只有一条记录（account_id = 1，account_owner = Owner1，account_amount = 23.0，is_deleted = n），分别通过 MySQL 和 HBase 查找该记录。</p><p>MySQL 返回的结果：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; select * from ct_account_info_demo;
+------------+---------------+----------------+------------+
| account_id | account_owner | account_amount | is_deleted |
+------------+---------------+----------------+------------+
|     1      |     Owner1    |      23.0      |     n      |
+------------+---------------+----------------+------------+
1 rows in set (0.01 sec)
复制代码
</code></pre></div></div><p>HBase 返回的结果：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hbase(main):001:0&gt; scan 'ct_account_info_demo';
ROW           COLUMN+CELL
 1            column=CT:account_amount, timestamp=1532502487735, value=23.0
 1            column=CT:account_id, timestamp=1532909576152, value=1
 1            column=CT:account_owner, timestamp=1532502487528, value=Owner1
 1            column=CT:is_deleted, timestamp=1532909576152, value=n
复制代码
</code></pre></div></div><p>上述结果都表示一行数据，MySQL 的返回结果比较直观，容易理解。</p><p>HBase 返回的结果其实是多个键值对，ROW 表示数据的 RowKey，COLUMN+CELL 表示该 RowKey 对应的内容。</p><p>COLUMN+CELL 中又是多个键值对，如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>column=CT:account_amount, timestamp=1532502487735, value=23.0
复制代码
</code></pre></div></div><p>表示列族 CT 的列 account_amount 的值为 23.0，时间戳为 1532502487735 。</p><p><em>注：ROW 为 1 是因为这里 RowKey = {account_id}，CT 是提前定义的列族（HBase 在插入数据时需要指定 RowKey、Column Family）。</em></p><p>总的来说，</p><ol><li>HBase 比 MySQL 多了 RowKey 和 Column Family 的概念，这里的 RowKey 类似 MySQL 中的主键，Column Family 相当于多个列的“归类”。</li><li>列族只有一个的情况下，HBase 的 Schema 和 MySQL 可以保持一致，但 HBase 允许某些字段为空或动态增加某个列，而 MySQL 只可根据 Schema 填充相应的列，不能动态增减列。</li><li>因为 HBase 的 Schema 是不固定的，所以每次插入、查找数据不像 MySQL 那么简洁，HBase 需要指定行键、列族、列等信息。</li></ol><p>更为详细的对比如下表（引自：<a href="https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-bigdata-hbase/index.html">HBase 深入浅出</a>）：</p><table><thead><tr><th> </th><th>RDBMS</th><th>HBase</th></tr></thead><tbody><tr><td>硬件架构</td><td>传统的多核系统，硬件成本昂贵</td><td>类似于 Hadoop 的分布式集群，硬件成本低廉</td></tr><tr><td>容错性</td><td>一般需要额外硬件设备实现 HA 机制</td><td>由软件架构实现，因为多节点，所以不担心单点故障</td></tr><tr><td>数据库大小</td><td>GB、TB</td><td>PB</td></tr><tr><td>数据排布</td><td>以行和列组织</td><td>稀疏的、分布的、多维的 Map</td></tr><tr><td>数据类型</td><td>丰富的数据类型</td><td>Bytes</td></tr><tr><td>事务支持</td><td>全面的 ACID 支持，支持 Row 和表</td><td>ACID 只支持单个 Row 级别</td></tr><tr><td>查询语言</td><td>SQL</td><td>只支持 Java API （除非与其他框架一起使用，如 Phoenix、Hive）</td></tr><tr><td>索引</td><td>支持</td><td>只支持 Row-key（除非与其他技术一起应用，如 Phoenix、Hive）</td></tr><tr><td>吞吐量</td><td>数千查询/每秒</td><td>百万查询/每秒</td></tr></tbody></table><h1 id="key-points">Key Points</h1><ul><li>hbase是列式存储，基于HDFS实现。</li><li>rowKey相当于主键，不过可以重复，存储上是按rowKey 范围分片的，每个分片叫region</li><li>区分去哪个region请求这些都是存在zookeeper上的，请求zookeeper后会缓存。</li><li>当表太大时，region会自动分裂</li><li>每个region的列也是分开存储的，对应多个文件，每个文件写入时经过WAL等技术，然后也是基于LSM技术，LSM能将业务的随机写转为顺序写，能有效提升写吞吐。</li><li>hbase适合大数据量存储，不支持复杂查询，查询只适合于Rowkey的前缀匹配，</li></ul></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
