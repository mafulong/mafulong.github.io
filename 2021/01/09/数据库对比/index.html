<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>数据库对比 Nosql vs Sql &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/01/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="数据库对比 Nosql vs Sql"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="数据库对比"><meta name="og:description" content="数据库对比"><meta property="og:url" content="https://mafulong.github.io/2021/01/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-01-09"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="数据库对比 Nosql vs "><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">数据库对比 Nosql vs Sql</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/09 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Database" title="Database">Database</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 10132 字，约 29 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="数据库对比">数据库对比</h2><blockquote><p><a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html">参考</a></p></blockquote><h3 id="关系型数据库管理系统rdbms">关系型数据库管理系统（RDBMS）</h3><p>像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p><p><strong>ACID</strong> 用来描述关系型数据库<a href="https://en.wikipedia.org/wiki/Database_transaction">事务</a>的特性。</p><ul><li><strong>原子性</strong> - 每个事务内部所有操作要么全部完成，要么全部不完成。</li><li><strong>一致性</strong> - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li><li><strong>隔离性</strong> - 并发执行事务的结果与顺序执行事务的结果相同。</li><li><strong>持久性</strong> - 事务提交后，对系统的影响是永久的。</li></ul><p>关系型数据库扩展包括许多技术：<strong>主从复制</strong>、<strong>主主复制</strong>、<strong>联合</strong>、<strong>分片</strong>、<strong>非规范化</strong>和 <strong>SQL调优</strong>。</p><h4 id="主从复制">主从复制</h4><p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p><h5 id="不利之处主从复制">不利之处：主从复制</h5><ul><li>将从库提升为主库需要额外的逻辑。</li><li>参考<a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#不利之处复制">不利之处：复制</a>中，主从复制和主主复制<strong>共同</strong>的问题。</li></ul><h4 id="主主复制">主主复制</h4><p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p><h5 id="不利之处-主主复制">不利之处： 主主复制</h5><ul><li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li><li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li><li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li><li>参考<a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#不利之处复制">不利之处：复制</a>中，主从复制和主主复制<strong>共同</strong>的问题。</li></ul><h5 id="不利之处复制">不利之处：复制</h5><ul><li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li><li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li><li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li><li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li><li>复制意味着更多的硬件和额外的复杂度。</li></ul><h4 id="联合按功能分库">联合(按功能分库)</h4><p>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：<strong>论坛</strong>、<strong>用户</strong>和<strong>产品</strong>，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p><h5 id="不利之处联合">不利之处：联合</h5><ul><li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li><li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li><li>用 <a href="http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers">server link</a> 从两个库联结数据更复杂。</li><li>联合需要更多的硬件和额外的复杂度。</li></ul><h4 id="分片">分片</h4><p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p><p>类似<a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#联合">联合</a>的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p><p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p><h5 id="不利之处分片">不利之处：分片</h5><ul><li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li><li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。<ul><li>再平衡会引入额外的复杂度。基于<a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html">一致性哈希</a>的分片算法可以减少这种情况。</li></ul></li><li>联结多个分片的数据操作更复杂。</li><li>分片需要更多的硬件和额外的复杂度。</li></ul><h4 id="非规范化">非规范化</h4><p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 <a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQl</a> 和 Oracle 支持<a href="https://en.wikipedia.org/wiki/Materialized_view">物化视图</a>，可以处理冗余信息存储和保证冗余副本一致。</p><p>当数据使用诸如<a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#联合">联合</a>和<a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#分片">分片</a>等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p><p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p><h5 id="不利之处非规范化">不利之处：非规范化</h5><ul><li>数据会冗余。</li><li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li><li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li></ul><h5 id="来源及延伸阅读非规范化">来源及延伸阅读：非规范化</h5><ul><li><a href="https://en.wikipedia.org/wiki/Denormalization">非规范化</a></li></ul><h4 id="sql-调优">SQL 调优</h4><p>SQL 调优是一个范围很广的话题，有很多相关的<a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=sql+tuning">书</a>可以作为参考。</p><p>利用<strong>基准测试</strong>和<strong>性能分析</strong>来模拟和发现系统瓶颈很重要。</p><ul><li><strong>基准测试</strong> - 用 <a href="http://httpd.apache.org/docs/2.2/programs/ab.html">ab</a> 等工具模拟高负载情况。</li><li><strong>性能分析</strong> - 通过启用如<a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">慢查询日志</a>等工具来辅助追踪性能问题。</li></ul><p>基准测试和性能分析可能会指引你到以下优化方案。</p><h5 id="改进模式">改进模式</h5><ul><li><p>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</p></li><li><p>使用CHAR类型存储固定长度的字段，不要用VARCHAR</p><ul><li><code class="language-plaintext highlighter-rouge">CHAR</code> 在快速、随机访问时效率很高。如果使用 <code class="language-plaintext highlighter-rouge">VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li></ul></li><li><p>使用 <code class="language-plaintext highlighter-rouge">TEXT</code> 类型存储大块的文本，例如博客正文。<code class="language-plaintext highlighter-rouge">TEXT</code> 还允许布尔搜索。使用 <code class="language-plaintext highlighter-rouge">TEXT</code> 字段需要在磁盘上存储一个用于定位文本块的指针。</p></li><li><p>使用 <code class="language-plaintext highlighter-rouge">INT</code> 类型存储高达 2^32 或 40 亿的较大数字。</p></li><li><p>使用 <code class="language-plaintext highlighter-rouge">DECIMAL</code> 类型存储货币可以避免浮点数表示错误。</p></li><li><p>避免使用 <code class="language-plaintext highlighter-rouge">BLOBS</code> 存储对象，存储存放对象的位置。</p></li><li><p><code class="language-plaintext highlighter-rouge">VARCHAR(255)</code> 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</p></li><li><p>在适用场景中设置 <code class="language-plaintext highlighter-rouge">NOT NULL</code> 约束来<a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search">提高搜索性能</a>。</p></li></ul><h5 id="使用正确的索引">使用正确的索引</h5><ul><li>你正查询（<code class="language-plaintext highlighter-rouge">SELECT</code>、<code class="language-plaintext highlighter-rouge">GROUP BY</code>、<code class="language-plaintext highlighter-rouge">ORDER BY</code>、<code class="language-plaintext highlighter-rouge">JOIN</code>）的列如果用了索引会更快。</li><li>索引通常表示为自平衡的 <a href="https://en.wikipedia.org/wiki/B-tree">B 树</a>，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li><li>设置索引，会将数据存在内存中，占用了更多内存空间。</li><li>写入操作会变慢，因为索引需要被更新。</li><li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li></ul><h5 id="避免高成本的联结操作">避免高成本的联结操作</h5><ul><li>有性能需要，可以进行非规范化。</li></ul><h5 id="分割数据表">分割数据表</h5><ul><li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li></ul><h5 id="调优查询缓存">调优查询缓存</h5><ul><li>在某些情况下，<a href="http://dev.mysql.com/doc/refman/5.7/en/query-cache">查询缓存</a>可能会导致<a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/">性能问题</a>。</li></ul><h3 id="nosql">NoSQL</h3><p>NoSQL 是<strong>键-值数据库</strong>、<strong>文档型数据库</strong>、<strong>列型数据库</strong>或<strong>图数据库</strong>的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持<a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#最终一致性">最终一致</a>。</p><p><strong>BASE</strong> 通常被用于描述 NoSQL 数据库的特性。相比 <a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#cap-理论">CAP 理论</a>，BASE 强调可用性超过一致性。</p><ul><li><strong>基本可用</strong> - 系统保证可用性。</li><li><strong>软状态</strong> - 即使没有输入，系统状态也可能随着时间变化。</li><li><strong>最终一致性</strong> - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li></ul><p>除了在 <a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#sql-还是-nosql">SQL 还是 NoSQL</a> 之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下 <strong>键-值存储</strong>、<strong>文档型存储</strong>、<strong>列型存储</strong>和<strong>图存储</strong>数据库。</p><h4 id="键-值存储">键-值存储</h4><blockquote><p>抽象模型：哈希表</p></blockquote><p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按<a href="https://en.wikipedia.org/wiki/Lexicographical_order">字典顺序</a>维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p><p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p><p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p><h5 id="来源及延伸阅读">来源及延伸阅读</h5><ul><li><a href="https://en.wikipedia.org/wiki/Key-value_database">键-值数据库</a></li><li><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or">键-值存储的劣势</a></li><li><a href="http://qnimate.com/overview-of-redis-architecture/">Redis 架构</a></li><li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/">Memcached 架构</a></li></ul><p>实现</p><ul><li>redis内存，hashmap 和 跳表当zset</li><li>lsm树，分层的有序结构，分层合并merge。 二分查找。</li></ul><h4 id="文档类型存储">文档类型存储</h4><blockquote><p>抽象模型：将文档作为值的键-值存储</p></blockquote><p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p><p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p><p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p><p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p><h5 id="来源及延伸阅读文档类型存储">来源及延伸阅读：文档类型存储</h5><ul><li><a href="https://en.wikipedia.org/wiki/Document-oriented_database">面向文档的数据库</a></li><li><a href="https://www.mongodb.com/mongodb-architecture">MongoDB 架构</a></li><li><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/">CouchDB 架构</a></li><li><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up">Elasticsearch 架构</a></li></ul><p>实现</p><p>MongoDB 中的文档类似于关系数据库中的一行数据，但它是结构化的，存储为键值对。每个文档在 MongoDB 中都是一个独立的实体，并可以具有灵活的结构。与关系型数据库不同，MongoDB 允许不同文档有不同的字段，甚至字段的类型也可以不同，这种灵活性使得 MongoDB 特别适合于需要快速迭代和灵活存储的数据模型。</p><p>ES底层也是基于Big Table这种LSM来构建的词id -&gt; doc id列表的索引。</p><h4 id="列型存储">列型存储</h4><blockquote><p>抽象模型：嵌套的 <code class="language-plaintext highlighter-rouge">ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p></blockquote><p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p><p>Google 发布了第一个列型存储数据库 <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">Bigtable</a>，它影响了 Hadoop 生态系统中活跃的开源数据库 <a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture">HBase</a> 和 Facebook 的 <a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html">Cassandra</a>。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p><p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p><p>大家都知道HDFS是分布式文件系统，hbase是基于HDFS的KV数据库，这两者的关系和GFS、BigTable的关系如出一辙</p><h5 id="来源及延伸阅读列型存储">来源及延伸阅读：列型存储</h5><ul><li><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html">SQL 与 NoSQL 简史</a></li><li><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">BigTable 架构</a></li><li><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture">Hbase 架构</a></li><li><a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html">Cassandra 架构</a></li></ul><p>列式数据库：</p><p>１．数据是按列存储的,每一列单独存放</p><p>２．数据既是索引</p><p>３．<strong>只访问查询涉及的列,大量降低系统io</strong></p><p>４．每一列有一个线程来处理,支持查询的高并发</p><p>５．数据类型一致,数据特征相似,<strong>高效的压缩</strong></p><p>为什么可以大量降低系统io: 复制代码比如查询表中所有人的名字;行式数据库需要查询所有行,列式数据库只需要查询name列.</p><h4 id="图数据库">图数据库</h4><blockquote><p>抽象模型： 图</p></blockquote><p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p><p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 <a href="https://wizardforcel.gitbooks.io/system-design-primer/content/20.html#表述性状态转移rest">REST API</a> 访问。</p><h5 id="相关资源和延伸阅读图">相关资源和延伸阅读：图</h5><ul><li><a href="https://en.wikipedia.org/wiki/Graph_database">图数据库</a></li><li><a href="https://neo4j.com/">Neo4j</a></li><li><a href="https://blog.twitter.com/2010/introducing-flockdb">FlockDB</a></li></ul><h5 id="来源及延伸阅读nosql">来源及延伸阅读：NoSQL</h5><ul><li><a href="http://stackoverflow.com/questions/3342497/explanation-of-base-terminology">数据库术语解释</a></li><li><a href="https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq">NoSQL 数据库 - 调查及决策指南</a></li><li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database">可扩展性</a></li><li><a href="https://www.youtube.com/watch?v=qI_g07C_Q5I">NoSQL 介绍</a></li><li><a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html">NoSQL 模式</a></li></ul><p>ByteGraph.</p><h3 id="hdfs">HDFS</h3><p>比如百度网盘等应用就是类似做法。</p><p>HDFS（<code class="language-plaintext highlighter-rouge">Hadoop Distributed File System</code> ），意为：<code class="language-plaintext highlighter-rouge">Hadoop</code>分布式文件系统。它是<code class="language-plaintext highlighter-rouge">Apache Hadoop</code>核心组件之一，作为大数据生态圈最底层的分布式存储服务而存在。也可以说大数据首先要解决的问题就是海量数据的存储问题。</p><ul><li>HDFS主要是解决大数据如何存储问题的。分布式意味着是HDFS是横跨在多台计算机上的存储系统。</li><li>HDFS是一种能够在普通硬件上运行的分布式文件系统，它是高度容错的，适应于具有大数据集的应用程序，它非常适于存储大型数据 (比如 TB 和 PB)。</li><li>HDFS使用多台计算机存储文件, 并且提供统一的访问接口, 像是访问一个普通文件系统一样使用分布式文件系统。</li></ul><p>HFDS采用分布式的架构，可能有成百上千的服务器组成，每一个组件都有可能出现故障。因此故障检测和自动快速恢复是HDFS的核心架构目标，下面是HDFS的官方架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv5/v5/202502211256612.awebp" alt="img" /></p><h4 id="主从架构">主从架构</h4><p>HDFS集群是标准的<code class="language-plaintext highlighter-rouge">master/slave</code>主从架构集群，一般一个HDFS集群是有一个<code class="language-plaintext highlighter-rouge">Namenode</code>和一定数目的<code class="language-plaintext highlighter-rouge">DataNode</code>组成。</p><p><strong>主角色：NameNode</strong></p><ul><li>NameNode是Hadoop分布式文件系统的核心，架构中的主角色。 </li><li>NameNode维护和管理文件系统元数据，包括名称空间目录树结构、文件和块的位置信息、访问权限等信息。 </li><li>基于此，NameNode成为了访问HDFS的唯一入口。</li></ul><p><strong>从角色：DataNode</strong></p><ul><li>DataNode是Hadoop HDFS中的从角色，负责具体的数据块存储。 </li><li>DataNode的数量决定了HDFS集群的整体数据存储能力，通过和NameNode配合维护着数据块。</li></ul><p><strong>主角色辅助角色： SecondaryNameNode</strong></p><p>此外，HDFS中还有一个SecondaryNameNode，虽然途中没有画出，那它有什么用呢？</p><ul><li>Secondary NameNode充当NameNode的辅助节点，但不能替代NameNode。 </li><li>主要是帮助主角色进行元数据文件的合并动作。可以通俗的理解为主角色的“秘书”。</li></ul><h4 id="分块存储">分块存储</h4><p>由于有的文件很大，一台机器也存不下，于是HDFS会对我们的文件做一个物理上的切割，也就是分块存储。</p><p>HDFS中的文件在物理上是分块存储（<code class="language-plaintext highlighter-rouge">block</code>）的，默认大小是<code class="language-plaintext highlighter-rouge">128M（134217728）</code>，不足<code class="language-plaintext highlighter-rouge">128M</code>则本身就是一块。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv5/v5/202502211258547.awebp" alt="img" /></p><h4 id="副本机制">副本机制</h4><p>既然分布式存储海量数据，那么肯定需要成千上百的机器，这样很有可能其中一台机器宕机，出故障了怎么办呢？</p><p>当然HDFS也想到了解决方案，文件的所有block都会有副本。副本系数可以在文件创建的时候指定，也可以在之后通过命令改变。副本数由参数<code class="language-plaintext highlighter-rouge">dfs.replication</code>控制，默认值是3，也就是会额外再复制2份，连同本身总共3份副本，而且这个副本尽量会分散在不同的机架上，规避风险。</p><h3 id="时序型数据库">时序型数据库</h3><p><a href="https://www.cnblogs.com/myshowtime/p/16445208.html">参考</a></p><p>理论下，常规数据库可以支持时间序列数据， 但是需要数据库专家级别的调优后，才能满足数据量比较大的场景需求。</p><p>具体点说，关系型数据库没有对时间序列数据进行优化，有以下几点原因</p><ul><li>在滚动时间窗口中计算平均值，需要编写复杂且难以阅读的 SQL。</li><li>为了支持标签（tag/label）数据，我们需要给每个标签加一个索引。</li><li>相比之下，关系型数据库在持续的高并发写入操作时表现不佳。</li></ul><p>相比之下，专门对时间序列数据优化的时序数据库，更适合这种场景。</p><p>OpenTSDB 是一个分布式时序数据库，但由于它基于 Hadoop 和 HBase，运行 Hadoop/HBase 集群也会带来复杂性。Twitter 使用了 MetricsDB 时序数据库存储指标数据，而亚马逊提供了 Timestream 时序数据库服务。</p><p>根据 DB-engines 的报告，两个最流行的时序数据库是 InfluxDB 和 Prometheus ，它们可以存储大量时序数据，并支持快速地对这些数据进行实时分析。</p><p>如下图所示，8 核 CPU 和 32 GB RAM 的 InfluxDB 每秒可以处理超过 250,000 次写入。</p><p>InfluxDB 使用的针对于时序数据的 Flux 查询语言会更简单更好理解，如下</p><div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">from</span><span class="o">(</span><span class="nt">db</span><span class="o">:</span><span class="s1">"telegraf"</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nt">range</span><span class="o">(</span><span class="nt">start</span><span class="nd">:-1h</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nt">filter</span><span class="o">(</span><span class="nt">fn</span><span class="o">:</span> <span class="o">(</span><span class="nt">r</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nt">r</span><span class="nc">._measurement</span> <span class="o">==</span> <span class="s1">"foo"</span><span class="o">)</span>
  <span class="o">|&gt;</span> <span class="nt">exponentialMovingAverage</span><span class="o">(</span><span class="nt">size</span><span class="nd">:-10s</span><span class="o">)</span>
</code></pre></div></div><p><strong>Tag</strong> 主要用于对数据进行 <strong>过滤</strong> 和 <strong>分组</strong> 操作。由于 <strong>Tag</strong> 是经常被用来做查询条件的字段，所以它们通常会被索引以提高查询效率。</p><p><strong>Field</strong>（字段）则是实际存储数据的部分，它是 <strong>Tag</strong> 的对立面，<strong>Field</strong> 不是索引的，查询时需要扫描整个数据表。</p><p>‌<strong>InfluxDB的读音是[‘ɪnflʌks]</strong>‌</p><ul><li><strong>高效写入</strong>：InfluxDB 采用了专门的存储引擎优化数据的写入速度。它使用了 <strong>Log-Structured Merge Tree (LSM-Tree)</strong> 存储引擎，确保在大量并发写入时，能够保持良好的写入性能。<ul><li>在 InfluxDB 的 LSM-Tree 实现中，<strong>key</strong> 由 <code class="language-plaintext highlighter-rouge">Measurement</code>、<code class="language-plaintext highlighter-rouge">Tag</code> 和 <code class="language-plaintext highlighter-rouge">Time</code> 组成，用来唯一标识每个时间序列数据点。<strong>value</strong> 存储的是 <code class="language-plaintext highlighter-rouge">field</code> 数据，即实际的测量值（如温度、湿度等）。通过时间戳和有序存储，InfluxDB 能够高效地执行时间范围查询，同时利用 MemTable 和 SSTables 来优化写入和查询性能。合并（Compaction）操作通过删除重复数据、压缩存储和优化磁盘空间来确保系统的高效运行。</li></ul></li><li><strong>时间序列数据压缩</strong>：InfluxDB 在存储时会对数据进行压缩，尤其是对时间序列数据中相似数据的压缩。这大大减少了存储空间的需求。它采用了 <strong>TSSD (Time-Structured Merge Tree)</strong> 结构进行存储，支持高效的数据压缩和合并。<ul><li>TSSD 使用的是基于时间的分层合并策略，这与传统的 LSM-Tree 合并策略有所不同。具体来说，TSSD 会根据时间顺序将数据分层存储，每个层包含一定时间范围内的数据。例如，第一层存储最新的数据，第二层存储稍早的数据，依此类推。合并过程中，InfluxDB 会选择具有相同时间范围的 SSTables 进行合并。</li><li>压缩，比如差分编码：利用相邻数据点之间的差值进行编码，而不是直接存储每个数据点的完整值。这样可以大大减少存储空间需求，特别是在数据变化较小时</li></ul></li></ul><p>InfluxDB 对 <strong>Tag</strong> 的每个键（key）都创建一个倒排索引，该索引的结构如下：</p><ul><li><strong>Key</strong>：Tag 键名（例如 <code class="language-plaintext highlighter-rouge">location</code>）。</li><li><strong>Value</strong>：包含该键的所有数据点的 ID 或时间戳。每个包含该 Tag 的数据点都会在该倒排索引中列出。</li></ul><p>例如，如果你有多个数据点都包含 <code class="language-plaintext highlighter-rouge">location=us-east-1</code>，倒排索引会记录哪些数据点的 <code class="language-plaintext highlighter-rouge">location</code> 是 <code class="language-plaintext highlighter-rouge">us-east-1</code>。这样，当你执行查询时，InfluxDB 可以快速根据索引找到所有符合条件的记录。</p><ul><li><strong>索引存储在内存中</strong>：为了提高查询性能，InfluxDB 会将 <strong>Tag</strong> 索引的数据存储在内存中（使用 LSM-Tree 和类似 Redis 的数据结构），并定期将其持久化到磁盘。</li><li><strong>支持多值索引</strong>：每个 Tag 可以具有多个不同的值，倒排索引会记录每个值对应的时间序列数据点。</li></ul><p>倒排索引的存储通常使用高效的 <strong>B+ 树</strong> 或 <strong>跳表</strong>（Skip List）等数据结构。通过这些数据结构，倒排索引能够支持快速的查找、插入和删除操作。</p><ul><li><strong>B+ 树</strong>：对于磁盘上的数据，倒排索引通常会存储在 <strong>B+ 树</strong> 结构中，这样可以利用 B+ 树的有序性实现高效的范围查询（如时间区间查询）。</li><li><strong>跳表（Skip List）</strong>：在内存中的倒排索引结构可能使用 <strong>跳表</strong>，它支持快速的查询和范围查找。</li></ul><h2 id="选型">选型</h2><h3 id="sql-还是-nosql">SQL 还是 NoSQL</h3><p>选取 <strong>SQL</strong> 的原因:</p><ul><li><strong>结构化</strong>数据</li><li>严格的模式</li><li>关系型数据</li><li>需要复杂的<strong>联结</strong>操作</li><li><strong>事务</strong></li><li>清晰的扩展模式</li><li>既有资源更丰富：开发者、社区、代码库、工具等</li><li>通过<strong>索引</strong>进行查询非常快</li></ul><p>选取 <strong>NoSQL</strong> 的原因：</p><ul><li>半结构化数据</li><li>动态或灵活的模式</li><li>非关系型数据</li><li>不需要复杂的联结操作</li><li>存储 TB （甚至 PB）级别的数据</li><li>高数据密集的工作负载</li><li>IOPS 高吞吐量</li></ul><p>适合 NoSQL 的示例数据：</p><ul><li>埋点数据和日志数据</li><li>排行榜或者得分数据</li><li>临时数据，如购物车</li><li>频繁访问的（“热”）表</li><li>元数据／查找表</li></ul><h3 id="为什么应该使用-nosql-数据库">为什么应该使用 NoSQL 数据库？</h3><p><a href="https://aws.amazon.com/cn/nosql/">参考</a></p><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><ul><li><strong>灵活性：</strong>NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li><li><strong>可扩展性：</strong>NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。一些云提供商在后台将这些操作处理为完全托管服务。</li><li><strong>高性能：</strong>NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li><strong>强大的功能：</strong>NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li></ul><h3 id="行式数据库和列式数据库区别">行式数据库和列式数据库区别</h3><p>行式数据库：</p><p>１．数据是按行存储的</p><p>２．没有建立索引的查询将消耗很大的io</p><p>３．建立索引和视图需要花费一定的物理空间和时间资源</p><p>４．面对大量的查询,复杂的查询,数据库必须被大量膨胀才能满足性能需求</p><p>列式数据库：</p><p>１．数据是按列存储的,每一列单独存放</p><p>２．数据既是索引</p><p>３．<strong>只访问查询涉及的列,大量降低系统io</strong></p><p>４．每一列有一个线程来处理,支持查询的高并发</p><p>５．数据类型一致,数据特征相似,<strong>高效的压缩</strong></p><p>为什么可以大量降低系统io: 复制代码比如查询表中所有人的名字;行式数据库需要查询所有行,列式数据库只需要查询name列.</p><p>行式与列式数据库优缺点:</p><ul><li>复制代码根据实际的业务场景来选择对应的数据库系统.</li><li>传统的crud操作应用适合行式数据库(表之间有关联关系);</li><li>列式数据库适用于数据仓库,数据分析,海量存储,涉及到不经常更新的数据库,列式在并行</li></ul><p>如果你主要处理的是事务性数据（频繁插入和更新），行存储通常更合适；而如果是大规模的批量分析或查询，列存储将更为高效。</p><h3 id="hash分片和range分片">hash分片和range分片</h3><p>分布式存储系统对数据分区一般有两种方式：<strong>Hash 分区和 Range 分区</strong>。Hash 分区对每条数据算一个哈希值，映射到一个逻辑分区上，然后通过另外一层映射将逻辑分区映射到具体的机器上，很多数据库中间件、缓存中间件都是这样做的。这种方式的优点是数据写入一般不会出现热点，缺点是原本连续的数据经过 Hash 后散落在不同的分区上变成了无序的，那么，如果需要扫描一个范围的数据，需要把所有的分区都扫描一遍。</p><p>相比而言，Range 分区对数据进行范围分区，连续的数据是存储在一起的，可以按需对相邻的分区进行合并，或者中间切一刀将一个分区一分为二。业界典型的系统像 HBase。这种分区方式的缺点是一、对于追加写处理不友好，因为请求都会打到最后一个分片，使得最后一个分片成为瓶颈。优点是更容易处理热点问题，当一个分区过热的时候，可以切分开，迁移到其他的空闲机器上。</p><p>从实际业务使用的角度来说，提供数据强一致性能够大大减小业务的负担。另外 Range 分区能够支持更丰富的访问模式，使用起来更加灵活。</p><p><strong>Range 分片</strong> 主要适用于需要按 <strong><code class="language-plaintext highlighter-rouge">row key</code> 范围</strong> 存取数据的场景，它能够提供高效的范围查询、负载均衡、存储优化等优点。许多现代分布式数据库，如 <strong>HBase、Bigtable、Cassandra、TiKV 和 CockroachDB</strong> 等，都采用了这种方式来分割和存储数据。</p><p>使用 range 分片的一个最大优势是可以高效地执行 <strong>范围查询</strong>（range queries）。由于数据是按 <code class="language-plaintext highlighter-rouge">row key</code> 范围进行分片的，查询某个 <code class="language-plaintext highlighter-rouge">row key</code> 范围的数据时，系统能够直接定位到对应的 Region 或 shard，避免了全表扫描。比如，查询某一时间段的数据，系统只需要查找该时间范围内的 <code class="language-plaintext highlighter-rouge">row key</code>，而不是扫描整个数据集。</p><h3 id="选型-1">选型</h3><p><a href="https://www.cnblogs.com/theseventhson/p/16575556.html">参考</a></p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv5/v5/202503011709824.png" alt="img" /></p><p>　　按照数据存放形态划分，主要分一下3种：</p><ul><li>　unstructured data 非结构化数据：指的是文件类，包括但不限于音视频、各种文档、日志等，通常存放于各种文件系统File System。<ul><li>　这类数据没有“规则”，适合存放在OS的本地磁盘。</li><li>如果有分布式distribute、冗余备份redundant backp等需求，可以考虑HDFS、对象存储cos/oss、Amazon的S3等！</li></ul></li><li>structed data 结构化数据： 这类数据非常规整，整齐划一，适合存放在excel类的表格型table数据库中。</li><li>常见的关系型数据库有mysql、sql server、Oracle、db2等，支持事务transaction；</li><li>大数据类的分布式数据库有hive、pg、mpp等，不支持tramsaction；</li><li>简而言之：能存放在excel的数据，也能存放在这些数据库中；</li><li>因为增删改查这种规则数据长用的就是SQL语句，所以这类也成为sql数据库</li><li>semi-structed data 半结构化数据：这类数据相比上一种结构化数据，也是一行一行的，但是没那么规整，主要是KV结构的数据，比如key是uid，value是各种属性，包括但不限于name、age、height、weight、friends等！</li><li>　key是固定长度的，但是value的长度可变，相比于上面的sql数据库，下面的这种明显扩展性extensibility更好！</li><li>平时写代码时，这种结构的数据常用hashmap存储，但hashmap的数据都放在内存memory，一旦断电，数据全丢，为能持久化保存这种KV数据，最终肯定是要存放在硬盘disck上的，所以衍生出了很多著名的KV半结构化数据库: hbase、redis、mongoDB、Cassandra等！因为存放的数据没那么“规整”（毕竟value时可变的嘛），所以又被成为NoSql数据库！</li></ul><p>存储考虑点， 对数据库的需求有：</p><table><thead><tr><th>需求</th><th>是否必须</th></tr></thead><tbody><tr><td>低延迟</td><td>必须</td></tr><tr><td>支持CP模型</td><td>必须</td></tr><tr><td>支持非结构化数据存储</td><td>必须</td></tr><tr><td>有亿级数据的存储方案</td><td>必须</td></tr><tr><td>有成熟的扩容方案</td><td>必须</td></tr><tr><td>冷热数据</td><td>非必须</td></tr></tbody></table></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
