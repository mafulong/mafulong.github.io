<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>mysql原理2-索引 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/01/06/mysql%E5%8E%9F%E7%90%862-%E7%B4%A2%E5%BC%95/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="mysql原理2-索引"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="B+ Tree原理"><meta name="og:description" content="B+ Tree原理"><meta property="og:url" content="https://mafulong.github.io/2021/01/06/mysql%E5%8E%9F%E7%90%862-%E7%B4%A2%E5%BC%95/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-01-06"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="mysql原理2-索引"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">mysql原理2-索引</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/06 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Mysql" title="Mysql">Mysql</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5527 字，约 16 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="b-tree原理">B+ Tree原理</h2><h3 id="1-数据结构">1. 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/73.png" alt="image-20210113205819442" style="zoom:50%;" /></p><h3 id="2-操作">2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h3 id="3-与红黑树的比较">3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p><p>（一）B+ 树有更低的树高</p><p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p><p>（二）磁盘访问原理</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p><p>（三）磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h3 id="4-btree性质">4. B+tree性质：</h3><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p><h3 id="5-b树和b树的区别">5. <strong>B树和B+树的区别</strong></h3><ul><li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li><li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/17.png" alt="image-20210106224625313" /></p><h3 id="6-数据库为什么使用b树而不是b树">6. 数据库为什么使用B+树而不是B树</h3><ul><li><p>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p></li><li><p>B+树空间利用率更高，非叶子节点占用空间小，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</p></li><li><p>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</p></li><li><p>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</p></li><li><p>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p></li></ul><h2 id="mysql-索引">MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="1-btree-索引">1. B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/199.png" alt="image-20210113205854610" style="zoom:50%;" /></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/122.png" alt="image-20210113205903435" style="zoom:50%;" /></p><h3 id="2-哈希索引">2. 哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="3-全文索引">3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="4-空间数据索引">4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="联合索引原理">联合索引原理</h3><p>比如3个字段，就是三个列值组合后的索引。 每个索引节点的键都是3个值</p><p>可以理解为叶子节点是有序列表。只有第一个键是有序排列的，剩下的都是在联合索引前面的键相等的情况下有序。</p><p>所有是最左前缀匹配原则。</p><h2 id="索引设计及优化">索引设计及优化</h2><h3 id="索引设计的原则">索引设计的原则</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>9) 基数大的索引在前。</p><p>10) 如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p><h3 id="索引失效情况">索引失效情况</h3><blockquote><p><a href="https://segmentfault.com/a/1190000021464570">参考，重要的已摘要</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220107220243.png" alt="image-20220107220243341" style="zoom:50%;" /></p><p>和索引顺序无关，MySQL底层的优化器会进行优化，调整索引的顺序。</p><p>索引失效情况:</p><ul><li><p>违反最左前缀法则会索引失效： 如果索引有多列，要遵守最左前缀法则， 即查询从索引的最左前列开始并且不跳过索引中的列</p></li><li><p>在索引列上做任何操作会索引失效: 如计算、函数、（自动or手动）类型转换等操作，会导致索引失效从而全表扫描</p></li><li><p>索引范围条件右边的索引列会失效</p><ul><li><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select * from myTest  where a=3 and b&gt;7 and c=3;     ---- b范围值，断点，阻塞了c的索引
a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引
</code></pre></div></div></li></ul></li><li><p>在使用不等于（!=、&lt;&gt;）的时候无法使用索引会导致全表扫描（除覆盖索引外）</p></li><li><p>like以通配符开头（’%abc’）会索引失效。因为是字典序排序的</p></li><li><p>字符串不加单引号索引失效 会索引失效。<strong>类型转换导致索引失效</strong></p></li><li><p>or连接 会索引失效。如果 <code class="language-plaintext highlighter-rouge">OR</code> 两侧的列分别有索引，可以使用 <code class="language-plaintext highlighter-rouge">UNION ALL</code> 分开查询。MySQL 5.6+ 支持 <code class="language-plaintext highlighter-rouge">INDEX MERGE</code> 优化，允许 <code class="language-plaintext highlighter-rouge">OR</code> 语句分别使用索引，然后合并结果</p></li><li><p>order by会索引失效，正常（索引参与了排序）备注：索引有两个作用：排序和查找。实际上是先order by然后order by用索引进行了排序。</p></li><li><p>group by会索引失效， 正常（索引参与了排序）备注：分组之前必排序（排序同order by）</p></li></ul><h3 id="覆盖索引">覆盖索引</h3><p><strong>索引包含所有需要查询的字段的值。对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</strong></p><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><h3 id="索引下推">索引下推</h3><p>索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h3 id="查询性能优化">查询性能优化</h3><h4 id="使用-explain-进行分析">使用 Explain 进行分析</h4><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h4 id="优化数据访问">优化数据访问</h4><h5 id="1-减少请求的数据量">1. 减少请求的数据量</h5><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h5 id="2-减少服务器端扫描的行数">2. 减少服务器端扫描的行数</h5><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="索引实现">索引实现</h2><h3 id="innodb-引擎和-myisam-引擎的实现"><strong>Innodb 引擎和 Myisam 引擎的实现</strong></h3><ul><li><p><strong>MyISAM</strong>：索引存储的是数据的物理地址，查询快，但不支持事务。</p></li><li><p><strong>InnoDB</strong>：主键索引存储整行数据，辅助索引存储主键值，可能需要二次回表，但支持事务，适合高并发场景。</p></li></ul><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td><strong>存储文件</strong></td><td><code class="language-plaintext highlighter-rouge">frm</code>（表结构）<br /><code class="language-plaintext highlighter-rouge">MYD</code>（数据）<br /><code class="language-plaintext highlighter-rouge">MYI</code>（索引）</td><td><code class="language-plaintext highlighter-rouge">frm</code>（表结构）<br /><code class="language-plaintext highlighter-rouge">idb</code>（数据 + 索引）</td></tr><tr><td><strong>索引存储</strong></td><td><strong>非聚簇索引</strong>（数据和索引分离）</td><td><strong>聚簇索引</strong>（数据和索引一起存储）</td></tr><tr><td><strong>主键索引</strong></td><td><strong>主索引 B+ 树，叶子节点存的是数据物理地址</strong></td><td><strong>主键索引 B+ 树，叶子节点存的是整行数据</strong></td></tr><tr><td><strong>辅助索引</strong></td><td><strong>存储的是数据物理地址</strong></td><td><strong>存储的是主键值，需要回表查询</strong></td></tr><tr><td><strong>查询效率</strong></td><td>索引叶子节点直接存数据地址，查询效率高</td><td><strong>主键查询快</strong>，但<strong>辅助索引查询需要二次回表（若无索引覆盖）</strong></td></tr><tr><td><strong>适用场景</strong></td><td>读多写少，对 <code class="language-plaintext highlighter-rouge">SELECT</code> 查询友好</td><td><strong>事务处理、并发、更新操作多的场景</strong></td></tr></tbody></table><ul><li><strong>Innodb 关键特性</strong><ul><li><strong>主键索引（聚簇索引）</strong><ul><li>叶子节点存储<strong>整行数据</strong>。</li><li><strong>一个表只能有一个聚簇索引</strong>（通常是 <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code>）。</li><li><strong>如果没有主键，InnoDB 会自动创建隐藏主键</strong>。</li></ul></li><li><strong>辅助索引（二级索引）</strong><ul><li>叶子节点存储的是<strong>主键值</strong>，查询时可能需要<strong>回表查询</strong>数据。</li></ul></li></ul></li><li><strong>MyISAM 关键特性</strong><ul><li><strong>非聚簇索引</strong><ul><li>索引叶子节点存的是<strong>数据的物理地址</strong>，索引和数据文件是<strong>分开的</strong>。</li><li><strong>查询效率高</strong>（索引直接定位物理位置）。</li></ul></li><li><strong>索引存储</strong><ul><li><strong>主索引和辅助索引存储结构相同</strong>，都存储数据的物理地址。</li></ul></li></ul></li></ul><h3 id="为什么使用辅助索引">为什么使用辅助索引</h3><p>因为 InnoDB 需要节省存储空间。一个表里可能有很多个索引，InnoDB 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余了）</p><h3 id="查询性能比较myisam查询更快">查询性能比较，myisam查询更快</h3><p>MyISAM 直接找到物理地址后就可以直接定位到数据记录，但是 InnoDB 查询到叶子节点后，还需要再查询一次主键索引树，才可以定位到具体数据。等于 MyISAM 一步就查到了数据，但是 InnoDB 要两步，那当然 MyISAM 查询性能更高。</p><h3 id="innodb聚簇索引实现">Innodb聚簇索引实现</h3><blockquote><p><a href="https://juejin.cn/post/6844903793423810568">参考</a></p><p><a href="https://smartkeyerror.com/MySQL-physical-structure">https://smartkeyerror.com/MySQL-physical-structure</a></p></blockquote><p><strong>索引里的指针都是文件偏移量。实际上就是个链表。</strong></p><p>文件通过页面缓存，都是按页读的，比如一页4KB.</p><p>因此聚簇索引是按主键id有序存的，但不会改动其他数据偏移位置。本质上是个链表，每条数据指向了下条数据以及上条数据偏移量也就是指针。</p><p><strong>聚簇索引具有唯一性</strong>，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p><p><strong>表中行的物理顺序和索引中行的物理顺序是相同的</strong>，<strong>在创建任何非聚簇索引之前创建聚簇索引</strong>，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p><p><strong>聚簇索引默认是主键</strong></p><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/113917726">参考</a></p></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
