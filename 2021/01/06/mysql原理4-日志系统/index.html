<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>mysql原理4-日志存储系统 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/01/06/mysql%E5%8E%9F%E7%90%864-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="mysql原理4-日志存储系统"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="mysql原理-日志存储系统"><meta name="og:description" content="mysql原理-日志存储系统"><meta property="og:url" content="https://mafulong.github.io/2021/01/06/mysql%E5%8E%9F%E7%90%864-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-01-06"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="mysql原理4-日志存储系统"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">mysql原理4-日志存储系统</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/06 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Mysql" title="Mysql">Mysql</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5126 字，约 15 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="mysql原理-日志存储系统">mysql原理-日志存储系统</h2><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/126.png" alt="" /></p><h2 id="各个log的作用">各个log的作用</h2><h3 id="1重做日志redo-log">1：重做日志（redo log）</h3><p><strong>作用：</strong>确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p><ul><li>Innodb 特有的。</li><li>redolog其实是类似于一个环形队列的概念，是可以重复利用的。像下面这个图，绿色的部分就是可以写入区的大小，如果写满了，那么这个时候就需要根据redolog，将内存中的数据，同步到磁盘里面去，这样才可以继续利用redolog记录数据变更。redolog其实记录的是针对具体数据页的操作，而不是记录的执行的sql。</li><li>WAL技术，write ahead log</li><li>一次事务，redolog至少更新两次，一次是update操作，一次是标记提交状态。</li></ul><p><code class="language-plaintext highlighter-rouge">redo log</code> 是一种二进制日志文件，记录了物理层面的页修改操作。 不是sql， 例子</p><ul><li><strong>Page #:</strong> 数据页编号，表明修改的是哪个数据页。</li><li><strong>Change Data:</strong> 对该页的具体修改内容。</li></ul><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+----------------+----------------+------------------+-------------+</span>
<span class="o">|</span> <span class="nc">Log</span> <span class="nc">Sequence</span> <span class="k">#</span> <span class="o">|</span> <span class="nc">Transaction</span> <span class="nc">ID</span> <span class="o">|</span> <span class="nc">Page</span> <span class="k">#</span>           <span class="o">|</span> <span class="nc">Change</span> <span class="nc">Data</span> <span class="o">|</span>
<span class="o">+----------------+----------------+------------------+-------------+</span>

</code></pre></div></div><p><strong>产生与释放：</strong>事务开始之后就产生redo log；当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了。</p><h3 id="2回滚日志undo-log">2：回滚日志（undo log）</h3><p><strong>作用：</strong>保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚。 <strong>产生与释放：</strong>事务开始之前，将当前版本生成undo log；当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，最后决定是否可以清理undo log的日志空间。</p><p>undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p><p>和redolog一样其实也是存储引擎层维护的，undolog是回退日志，提供回滚操作。undo log 用来回滚行记录到某个版本。undo log 一般是逻辑日志，根据每行记录进行记录。保证事务的原子性，innodb使用它来实现MVCC.Undo 记录某 数据 被修改 前 的值，可以用来在事务失败时进行 rollback。Redo 记录某 数据块 被修改 后 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。</p><h3 id="3二进制日志binlog">3：二进制日志（binlog）</h3><p><strong>作用：</strong>在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。 <strong>产生与释放：</strong>事务提交的时候，一次性将事务中的sql语句按照一定的格式记录到binlog中；超过配置的天数之后会被自动删除(默认永久不删除</p><p>binlog 是 mysql server 层维护的，跟采用何种引擎没有关系，记录的是所有引擎的更新操作的日志记录。最开始没有第三方存储引擎开发的时候其实mysql只有binglog，这个历史原因导致了binlog其实只是逻辑层面的。redo/undo 记录的是 每个页/每个数据 的修改情况，属于物理日志+逻辑日志结合的方式（redo log 是物理日志，undo log 是逻辑日志）。binlog 记录的都是事务操作内容，</p><p>binlog 有三种模式：</p><p><strong>Statement（基于 SQL 语句的复制）、Row（基于行的复制，修改前后的数据） 以及 Mixed（混合模式）</strong>。不管采用的是什么模式，当然格式是二进制的。redo/undo 在 事务执行过程中 会不断的写入，而 binlog 是在 事务最终提交前 写入的。也就是二阶段提交。</p><p>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</p><ul><li>在这种格式下，binlog 记录的是每一行的具体变化，而不是 SQL 语句本身。</li></ul><p>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。 此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><ul><li>结合了 <strong>STATEMENT</strong> 和 <strong>ROW</strong> 格式的优点，MySQL 会根据 SQL 语句的类型自动选择最合适的格式</li></ul><h2 id="buffer-pool-vs-change-buffer">Buffer pool vs change buffer</h2><table><thead><tr><th><strong>特点</strong></th><th><strong>Buffer Pool</strong></th><th><strong>Change Buffer</strong></th></tr></thead><tbody><tr><td><strong>作用对象</strong></td><td>数据页、索引页、Undo log 页</td><td><strong>二级索引（非唯一索引）</strong></td></tr><tr><td><strong>工作目的</strong></td><td>提升整体查询性能，减少读取 I/O</td><td>延迟二级索引的磁盘更新，减少随机写 I/O</td></tr><tr><td><strong>更新机制</strong></td><td>修改后标记为脏页，异步刷盘</td><td>修改写入 Change Buffer，后续合并</td></tr><tr><td><strong>配置参数</strong></td><td><code class="language-plaintext highlighter-rouge">innodb_buffer_pool_size</code></td><td><code class="language-plaintext highlighter-rouge">innodb_change_buffer_max_size</code></td></tr><tr><td><strong>主要优化场景</strong></td><td>缓存常用数据，提升查询性能</td><td>写操作较多、二级索引较多的场景</td></tr><tr><td><strong>兼容性限制</strong></td><td>支持所有类型的数据</td><td>仅支持二级索引，且必须是非唯一索引</td></tr></tbody></table><h3 id="buffer-pool"><strong>Buffer Pool</strong></h3><ul><li><strong>定义：</strong> Buffer Pool 是 InnoDB 存储引擎用于缓存数据页的主要内存区域。 它是一个缓存层，用来存储表和索引的数据页，以减少磁盘 I/O。</li><li><strong>功能：</strong><ol><li>缓存经常访问的表数据和索引。</li><li>提高读取性能，因为数据可以直接从内存中读取，而不需要每次都从磁盘加载。</li><li>对数据页的修改先在 Buffer Pool 中完成，之后再异步刷新到磁盘。</li></ol></li><li><strong>作用对象：</strong><ul><li>数据页（table data pages）</li><li>索引页（index pages）</li><li>Undo log 页等</li></ul></li><li><strong>工作流程：</strong><ol><li>当需要读取或修改数据时，InnoDB 首先尝试从 Buffer Pool 中获取。</li><li>如果数据不在 Buffer Pool 中，则从磁盘加载到 Buffer Pool。</li><li>数据修改后，标记为脏页（Dirty Pages），稍后再通过刷盘（flush）写入磁盘。</li></ol></li><li><strong>特点：</strong><ul><li>大小可以通过 <code class="language-plaintext highlighter-rouge">innodb_buffer_pool_size</code> 配置。</li><li>用于提升整体的查询和写入性能。</li></ul></li></ul><hr /><h3 id="change-buffer"><strong>Change Buffer</strong></h3><ul><li><p><strong>定义：</strong> Change Buffer 是 InnoDB 存储引擎中专门为二级索引的写操作（<code class="language-plaintext highlighter-rouge">INSERT</code>、<code class="language-plaintext highlighter-rouge">DELETE</code> 和 <code class="language-plaintext highlighter-rouge">UPDATE</code>）设计的缓存区域，用于延迟写入磁盘。</p></li><li><p><strong>功能：</strong></p><ol><li>延迟对二级索引的非唯一键的磁盘更新，减少随机 I/O。</li><li>将多个写操作合并，优化磁盘写入性能。</li></ol></li><li><p><strong>作用对象：</strong></p><ul><li><strong>仅用于二级索引</strong>，且必须是非唯一索引。</li><li>不涉及主键和唯一索引。</li><li><strong>适合批量插入、更新、删除，减少磁盘 I/O</strong>，如：<ul><li><strong>批量 <code class="language-plaintext highlighter-rouge">INSERT</code>（索引页不在内存中时提升效率）</strong></li><li><strong>批量 <code class="language-plaintext highlighter-rouge">UPDATE</code>（只修改索引，不涉及数据）</strong></li><li><strong>批量 <code class="language-plaintext highlighter-rouge">DELETE</code>（不立即修改索引页）</strong></li></ul></li></ul></li><li><p><strong>工作流程：</strong></p><p>当对<strong>非唯一二级索引</strong>进行 <code class="language-plaintext highlighter-rouge">INSERT</code>、<code class="language-plaintext highlighter-rouge">UPDATE</code> 或 <code class="language-plaintext highlighter-rouge">DELETE</code> 时：</p><ol><li><strong>如果索引页在 Buffer Pool</strong>（内存）中，直接修改内存页，并标记为<strong>脏页（Dirty Page）</strong>，后续写入磁盘（Flush）。</li><li>如果索引页不在 Buffer Pool<ul><li><strong>正常情况</strong>：需要从磁盘读取索引页到 Buffer Pool，然后修改后再写回磁盘（随机 I/O，性能低）。</li><li><strong>使用 Change Buffer</strong>：先<strong>将变更写入 Change Buffer（内存）</strong>，不立即访问磁盘，后续<strong>通过合并（Merge）批量更新磁盘</strong>，减少 I/O 开销。</li></ul></li></ol></li><li><p><strong>特点：</strong></p><ul><li>大小可以通过 <code class="language-plaintext highlighter-rouge">innodb_change_buffer_max_size</code>（默认是 Buffer Pool 的 25%）来配置。</li><li>改变的是磁盘 I/O 的时机，提升了写入性能。</li></ul></li></ul><h3 id="插入一条数据的过程">插入一条数据的过程</h3><blockquote><p><a href="https://blog.csdn.net/Kindle_code/article/details/107761447">参考</a></p></blockquote><p>插入一条数据: insert into t(id,k) values(id1,k1),(id2,k2); 假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/10.png" alt="在这里插入图片描述" /> 分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。 这条更新语句做了如下的操作（按照图中的数字顺序）： 1、Page 1 在内存中，直接更新内存。 2、Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息。 3、将上述两个动作记入 redo log 中（图中 3 和 4）。 做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p></blockquote><h3 id="查询一条语句的过程">查询一条语句的过程</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/189.png" alt="在这里插入图片描述" /> 1、读 Page 1 的时候，直接从内存返回。WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用的。你可以看一下图 3 的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。 2、要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。 可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。 所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</p></blockquote><h2 id="qa">QA</h2><h3 id="为什么不能只用redolog或者undolog">为什么不能只用redolog或者undolog？</h3><ul><li>Redo Log 保证事务的持久性</li><li>Undo Log 保证事务的原子性</li></ul><blockquote><p>比如某一时刻数据库DOWN机了，有两个事务，一个事务已经提交，另一个事务正在处理。数据库重启的时候就要根据日志进行前滚及回滚，把已提交事务的更改写到数据文件，未提交事务的更改恢复到事务开始前的状态。即，当数据库 crash-recovery 时，通过 redo log将所有已经在存储引擎内部提交的事务应用 redo log 恢复，所有已经 prepared 但是没有 commit 的 transactions 将会应用 undo log 做 roll back。</p></blockquote><ul><li>假设只有 undo-log：那么就必须保证提交前刷脏完成，否则宕机时有些修改就在内存中丢失了，破坏了持久性。（这样带来了一个问题，那就是前面提到的性能差）</li><li>假设只有 redo-log：那么就不能随心所欲地在事务提交前刷脏，即无法支持大事务。（假如、某张表有 100 亿的 8 字节整数数据，就算不考虑其他东西带来的损耗，光 update 整张表至少要消耗 80G 的内存。如前所述，有了 undo-log，就可以随便刷脏。）</li></ul><h3 id="redo-log和binlog区别">redo log和binlog区别</h3><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h2 id="mysql抖动">Mysql抖动</h2><p>第一种是“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。</p><p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：第一种是，还没有使用的；第二种是，使用了并且是干净页；第三种是，使用了并且是脏页。</p><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
