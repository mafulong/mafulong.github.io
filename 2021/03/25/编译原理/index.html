<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>编译原理 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2021/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="编译原理"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="##"><meta name="og:description" content="##"><meta property="og:url" content="https://mafulong.github.io/2021/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-03-25"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="编译原理"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">编译原理</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/03/25 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Others" title="Others">Others</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 3669 字，约 11 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>##</p><h2 id="编译原理">编译原理</h2><blockquote><p><a href="https://juejin.cn/post/6844903486258151431">参考</a></p></blockquote><h3 id="预处理">预处理</h3><p>最后简单描述一下预处理。预处理主要是处理一些宏定义，比如 <code class="language-plaintext highlighter-rouge">#define</code>、<code class="language-plaintext highlighter-rouge">#include</code>、<code class="language-plaintext highlighter-rouge">#if</code> 等。预处理的实现有很多种，有的编译器会在词法分析前先进行预处理，替换掉所有 # 开头的宏，而有的编译器则是在词法分析的过程中进行预处理。当分析到 # 开头的单词时才进行替换。虽然先预处理再词法分析比较符合直觉，但在实际使用中，GCC 使用的却是一边词法分析，一边预处理的方案。</p><h3 id="词法分析">词法分析</h3><ul><li>输入：源代码</li><li>输出：中间代码</li><li>把源代码分割开，形成若干个单词。原理主要是状态机。处理之后，编译器就知道了每个单词</li></ul><h3 id="语法分析">语法分析</h3><ul><li>思路是模板匹配，把单词组合起来</li><li>成功解析语法以后，我们会得到抽象语法树(AST: Abstract Syntax Tree)</li></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int fun(int a, int b) {    int c = 0;    c = a + b;    return c;}
</code></pre></div></div><p>它的语法树如下:</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325142313" alt="img" style="zoom:25%;" /></p><h3 id="生成中间代码">生成中间代码</h3><ul><li>意义：<strong>不同cpu的汇编语法不一致。因此需要生成和语言无关、也和cpu无关的中间代码，然后再生成各个cpu的汇编代码</strong>。可以理解为中间代码是一种非常抽象，又非常普适的代码。它客观中立的描述了代码要做的事情，如果用中文、英文来分别表示 C 和 Java 的话，中间码某种意义上可以被理解为世界语。</li><li>eg. 如gcc,<ul><li>语法树转高端gimple<ul><li>主要处理寄存器和栈，如c=a+b变成寄存器处理。</li><li>函数调用则建栈</li></ul></li><li>高端gimple转低端gimple<ul><li>主要是把变量定义，语句执行和返回语句区分存储<ul><li>好处是容易计算一个函数需要多少栈空间</li></ul></li></ul></li><li>低端gimple转中间代码<ul><li>（略）</li></ul></li></ul></li></ul><h3 id="生成目标代码生成汇编代码">生成目标代码（生成汇编代码）</h3><ul><li>主要的工作量在于兼容各种 CPU 以及填写模板。在最终生成的汇编代码中，不仅有汇编命令，也有一些对文件的说明。</li></ul><h3 id="汇编生成二进制机器码">汇编，生成二进制机器码</h3><ul><li><p>把汇编代码转成 二进制的机器码，机器码可以直接被 CPU 识别并执行</p></li><li><p>从目标代码可以猜出来，最终的目标文件(机器码)也是分段的，这主要有以下三个原因:</p></li></ul><ol><li>分段可以将数据和代码区分开。其中代码只读，数据可写，方便权限管理，避免指令被改写，提高安全性。</li><li>现代 CPU 一般有自己的数据缓存和指令缓存，区分存储有助于提高缓存命中率。</li><li>当多个进程同时运行时，他们的指令可以被共享，这样能节省内存。</li></ol><p>对于一个目标文件来说，文件的最开头(也叫作 ELF 头)记录了目标文件的基本信息，程序入口地址，以及段表的位置，相当于是对文件的整体描述。接下来的重点是段表，它记录了每个段的段名，长度，偏移量。比较常用的段有:</p><ul><li>.strtab 段: 字符串长度不定，分开存放浪费空间(因为需要内存对齐)，因此可以统一放到字符串表(也就是 .strtab 段)中进行管理。字符串之间用 <code class="language-plaintext highlighter-rouge">\0</code> 分割，所以凡是引用字符串的地方用一个数字就可以代表。</li><li>.symtab: 表示符号表。符号表统一管理所有符号，比如变量名，函数名。符号表可以理解为一个表格，每行都有符号名(数字)、符号类型和符号值(存储地址)</li><li>.rel 段: 它表示一系列重定位表。这个表主要在链接时用到，下面会详细解释。</li></ul><h2 id="编译-vs-解释">编译 VS 解释</h2><p>总结一下，对于 C 语言来说，从源码到运行结果大致上需要经历编译、汇编和链接三个步骤。编译器接收源代码，输出目标代码(也就是汇编代码)，汇编器接收汇编代码，输出由机器码组成的目标文件(二进制格式，.o 后缀)，最后链接器将各个目标文件链接起来，执行重定位，最终生成可执行文件。</p><h3 id="解释型语言">解释型语言</h3><ul><li>解释型语言：源代码 -&gt; 解释器 -&gt; 运行结果</li><li>编译型语言：源代码 -&gt; 中间代码 -&gt; 目标代码 -&gt; 运行结果</li></ul><p>解释型语言和编译型语言的根本区别在于，对于用户来说，到底是直接从源码开始执行，还是从中间代码开始执行。以 C 语言为例，所有的可执行程序都是二进制文件。而对于传统意义的 Python 或者 JavaScript，用户并没有拿到中间代码，他们直接从源码开始执行。从这个角度来看， Java 不可能是解释型语言，虽然 Java 虚拟机会解释字节码，但是对于用户来说，他们是从编译好的 .class 文件开始执行，而非源代码。</p><p>解释程序和编译程序的根本区别：是否生成目标代码。有没有虚拟机，虚拟机是不是解释执行，会不会生成中间代码，这些都不重要，重要的是如果从中间代码开始执行，而且 AST 已经事先生成好，那就是编译型的语言。</p><h2 id="运行时">运行时</h2><h3 id="运行时库的基本概念">运行时库的基本概念</h3><p>以 C 语言为例，有非常多的操作最终都依赖于 <strong>glibc</strong> 这个动态链接库。包括但不限于字符串处理(<code class="language-plaintext highlighter-rouge">strlen</code>、<code class="language-plaintext highlighter-rouge">strcpy</code>)、信号处理、socket、线程、IO、动态内存分配(malloc)等等。这一点很好理解，如果回忆一下之前编译器的工作原理，我们会发现它仅仅是处理了语言的语法，比如变量定义，函数声明和调用等等。至于语言的功能， 比如内存管理，內建的类型，一些必要功能的实现等等。如果要对运行时库进行分类，大概有两类。一种是语言自身功能的实现，比如一些內建类型，内置的函数；另一种则是语言无关的基础功能，比如文件 IO，socket 等等。</p><p>由于每个程序都依赖于运行时库，这些库一般都是动态链接的，比如 C 语言的 (g)libc。这样一来，运行时库可以存储在操作系统中，节省内存占用空间和应用程序大小。</p><p>对于 Java 语言来说，它的垃圾回收功能，文件 IO 等都是在虚拟机中实现，并提供给 Java 层调用。从这个角度来看，虚拟机/解释器也可以被看做语言的运行时环境(库)。</p><h2 id="链接和装入">链接和装入</h2><h3 id="链接">链接</h3><p>在一个目标文件中，不可能所有变量和函数都定义在文件内部。比如 <code class="language-plaintext highlighter-rouge">strlen</code> 函数就是一个被调用的外部函数，此时就需要把 <code class="language-plaintext highlighter-rouge">main.o</code> 这个目标文件和包含了 <code class="language-plaintext highlighter-rouge">strlen</code> 函数实现的目标文件链接起来。我们知道函数调用对应到汇编其实是 <code class="language-plaintext highlighter-rouge">jump</code> 指令，后面写上被调用函数的地址，但在生成 <code class="language-plaintext highlighter-rouge">main.o</code> 的过程中，<code class="language-plaintext highlighter-rouge">strlen()</code> 函数的地址并不知道，所以只能先用 0 来代替，直到最后链接时，才会修改成真实的地址。</p><p>链接器就是靠着重定位表来知道哪些地方需要被重定位的。每个可能存在重定位的段都会有对应的重定位表。在链接阶段，链接器会根据重定位表中，需要重定位的内容，去别的目标文件中找到地址并进行重定位。</p><p><strong>链接</strong>是将多个目标文件（<code class="language-plaintext highlighter-rouge">.o</code> 文件）和库文件（<code class="language-plaintext highlighter-rouge">.a</code> / <code class="language-plaintext highlighter-rouge">.so</code>）合并为一个可执行文件的过程。</p><p>编译后是否已经完成链接，取决于链接方式</p><ul><li><strong>静态链接</strong>：编译完成 = 链接完成，可独立运行</li><li><strong>动态链接</strong>：编译完成 ≠ 链接完成，运行时仍需加载 <code class="language-plaintext highlighter-rouge">.so</code> 库</li></ul><h3 id="装入loading">装入（Loading）</h3><p><strong>装入</strong>是指<strong>操作系统</strong>将程序从磁盘加载到内存，并准备运行的过程。</p><p><strong>装入的三种方式</strong></p><ol><li><strong>绝对装入（Absolute Loading）</strong><ul><li>代码只能装入到固定的内存地址（如嵌入式设备）</li><li><strong>缺点</strong>：不同机器或不同进程可能导致冲突</li></ul></li><li><strong>可重定位装入（Relocatable Loading）</strong><ul><li><strong>常见于现代操作系统</strong>，程序可装入任意空闲地址</li><li><strong>需要重定位表（Relocation Table）</strong>，装入时修改地址引用</li></ul></li><li><strong>动态装入（Dynamic Loading）</strong><ul><li><strong>按需装入</strong>程序或库，如 <code class="language-plaintext highlighter-rouge">dlopen()</code> 方式</li><li><strong>常用于共享库、插件系统</strong>，如 Python 的 <code class="language-plaintext highlighter-rouge">import</code> 机制</li></ul></li></ol><h2 id="go-的编译链接装入概览"><strong>Go 的编译、链接、装入概览</strong></h2><table><thead><tr><th><strong>阶段</strong></th><th><strong>作用</strong></th><th><strong>执行者</strong></th><th><strong>输出</strong></th></tr></thead><tbody><tr><td><strong>编译（Compilation）</strong></td><td>源代码 → 汇编/机器码</td><td><code class="language-plaintext highlighter-rouge">go build</code>（调用 <code class="language-plaintext highlighter-rouge">cmd/compile</code>）</td><td><code class="language-plaintext highlighter-rouge">.o</code> 目标文件</td></tr><tr><td><strong>链接（Linking）</strong></td><td>目标文件 + 库 → 可执行文件</td><td><code class="language-plaintext highlighter-rouge">cmd/link</code></td><td>可执行文件</td></tr><tr><td><strong>装入（Loading）</strong></td><td>加载可执行文件到内存并执行</td><td>OS Loader</td><td>进程</td></tr></tbody></table><h3 id="编译步骤"><strong>编译步骤</strong></h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
go build -o myapp main.go
</code></pre></div></div><p><strong>内部执行流程</strong></p><ol><li><strong>词法分析</strong>（Lexical Analysis）：将 Go 代码转换为 Token。</li><li><strong>语法分析</strong>（Parsing）：生成 AST（抽象语法树）。</li><li><strong>类型检查</strong>（Type Checking）：检查变量、函数、结构体等是否正确。</li><li><strong>优化</strong>（Optimization）：移除无用代码（dead code elimination）、内联（inlining）等。</li><li><strong>代码生成</strong>（Code Generation）：生成中间代码（SSA）。</li><li><strong>寄存器分配</strong>（Register Allocation）：为变量分配 CPU 寄存器。</li><li><strong>机器码生成</strong>（Machine Code Generation）：最终生成 <code class="language-plaintext highlighter-rouge">.o</code> 目标文件。</li></ol><p><strong>中间文件</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
go build -gcflags="-m" main.go
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">-m</code> 选项会显示编译优化情况。</li><li>可以用 <code class="language-plaintext highlighter-rouge">-S</code> 选项查看 Go 生成的汇编代码。</li></ul><h3 id="go-默认静态链接"><strong>Go 默认静态链接</strong></h3><p>Go 默认使用 <strong>静态链接（Static Linking）</strong>，不会依赖外部动态库（除非使用 CGO）。</p><p><strong>静态链接过程</strong></p><ol><li><p><strong>合并所有目标文件（.o）</strong></p></li><li><p><strong>链接 Go 标准库（runtime）</strong></p></li><li><p>生成完整可执行文件</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   
go build -o myapp main.go
</code></pre></div></div><p>生成的</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myapp
</code></pre></div></div><p>不依赖 任何外部库。</p></li></ol><h3 id="go-的装入过程"><strong>Go 的装入过程</strong></h3><p><strong>（1）装入流程</strong></p><p>当运行 <code class="language-plaintext highlighter-rouge">./myapp</code> 时，OS 执行以下步骤：</p><ol><li><strong>加载 ELF 文件</strong>（Linux）或 Mach-O 文件（macOS）。</li><li><strong>解析 Go 运行时</strong>（Go runtime）。</li><li><strong>初始化全局变量</strong>。</li><li><strong>调用 <code class="language-plaintext highlighter-rouge">main.main()</code></strong> 并开始执行。</li></ol><p><strong>（2）Go 运行时（Runtime）</strong></p><ul><li><strong>垃圾回收（GC）</strong>：Go 运行时自带 GC，不依赖外部库。</li><li><strong>goroutine 调度</strong>：Go 运行时管理协程调度，而非 OS 线程调度。</li><li><strong>系统调用（Syscall）</strong>：Go 通过 <code class="language-plaintext highlighter-rouge">runtime</code> 处理系统调用。</li></ul></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
