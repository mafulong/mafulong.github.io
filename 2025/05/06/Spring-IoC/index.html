<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Spring IoC &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2025/05/06/Spring-IoC/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="Spring IoC"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="Sprint IoC"><meta name="og:description" content="Sprint IoC"><meta property="og:url" content="https://mafulong.github.io/2025/05/06/Spring-IoC/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2025-05-06"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Spring IoC"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Spring IoC</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2025/05/06 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Spring" title="Spring">Spring</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4384 字，约 13 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="sprint-ioc">Sprint IoC</h2><h3 id="谈谈自己对于-spring-ioc-的了解">谈谈自己对于 Spring IoC 的了解</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>IOC 是一种思想，<strong>DI</strong> 是实现 IOC 的具体方式，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。</p><h3 id="将一个类声明为-bean-的注解有哪些">将一个类声明为 Bean 的注解有哪些?</h3><ul><li><code class="language-plaintext highlighter-rouge">@Component</code>：通用的注解，可标注任意类为 <code class="language-plaintext highlighter-rouge">Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code class="language-plaintext highlighter-rouge">@Component</code> 注解标注。</li><li><code class="language-plaintext highlighter-rouge">@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code class="language-plaintext highlighter-rouge">@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code class="language-plaintext highlighter-rouge">@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code class="language-plaintext highlighter-rouge">Service</code> 层返回数据给前端页面。</li></ul><h3 id="component-和-bean-的区别是什么">@Component 和 @Bean 的区别是什么？</h3><ul><li><code class="language-plaintext highlighter-rouge">@Component</code> 注解作用于类，而<code class="language-plaintext highlighter-rouge">@Bean</code>注解作用于方法。</li><li><code class="language-plaintext highlighter-rouge">@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code class="language-plaintext highlighter-rouge">@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code class="language-plaintext highlighter-rouge">@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code class="language-plaintext highlighter-rouge">@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code class="language-plaintext highlighter-rouge">@Bean</code> 注解比 <code class="language-plaintext highlighter-rouge">@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code class="language-plaintext highlighter-rouge">@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code class="language-plaintext highlighter-rouge">Spring</code>容器时，则只能通过 <code class="language-plaintext highlighter-rouge">@Bean</code>来实现。</li></ul><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@Configuration</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="n">public</span> <span class="nc">TransferService</span> <span class="nf">transferService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">TransferServiceImpl</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div><h3 id="注入-bean-的注解有哪些">注入 Bean 的注解有哪些？</h3><p>Spring 内置的 <code class="language-plaintext highlighter-rouge">@Autowired</code> 以及 JDK 内置的 <code class="language-plaintext highlighter-rouge">@Resource</code> 和 <code class="language-plaintext highlighter-rouge">@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotation</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">@Autowired</code></td><td><code class="language-plaintext highlighter-rouge">org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code class="language-plaintext highlighter-rouge">@Resource</code></td><td><code class="language-plaintext highlighter-rouge">javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code class="language-plaintext highlighter-rouge">@Inject</code></td><td><code class="language-plaintext highlighter-rouge">javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">@Autowired</code> 和<code class="language-plaintext highlighter-rouge">@Resource</code>使用的比较多一些。</p><p>推荐构造函数注入。</p><h3 id="autowired-和-resource-的区别是什么">@Autowired 和 @Resource 的区别是什么？</h3><ul><li><code class="language-plaintext highlighter-rouge">@Autowired</code> 是 Spring 提供的注解，<code class="language-plaintext highlighter-rouge">@Resource</code> 是 JDK 提供的注解。</li><li><code class="language-plaintext highlighter-rouge">Autowired</code> 默认的注入方式为<code class="language-plaintext highlighter-rouge">byType</code>（根据类型进行匹配），<code class="language-plaintext highlighter-rouge">@Resource</code>默认注入方式为 <code class="language-plaintext highlighter-rouge">byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code class="language-plaintext highlighter-rouge">@Autowired</code> 和<code class="language-plaintext highlighter-rouge">@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code class="language-plaintext highlighter-rouge">Autowired</code> 可以通过 <code class="language-plaintext highlighter-rouge">@Qualifier</code> 注解来显式指定名称，<code class="language-plaintext highlighter-rouge">@Resource</code>可以通过 <code class="language-plaintext highlighter-rouge">name</code> 属性来显式指定名称。</li><li><code class="language-plaintext highlighter-rouge">@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code class="language-plaintext highlighter-rouge">@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul><h3 id="注入-bean-的方式有哪些">注入 Bean 的方式有哪些？</h3><p>依赖注入 (Dependency Injection, DI) 的常见方式：</p><ol><li>构造函数注入：通过类的构造函数来注入依赖项。</li><li>Setter 注入：通过类的 Setter 方法来注入依赖项。</li><li>Field（字段） 注入：直接在类的字段上使用注解（如 <code class="language-plaintext highlighter-rouge">@Autowired</code> 或 <code class="language-plaintext highlighter-rouge">@Resource</code>）来注入依赖项。</li></ol><p><strong>Spring 官方推荐构造函数注入</strong>，这种注入方式的优势如下：</p><ol><li>依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。</li><li>不可变性：有助于创建不可变对象，提高了线程安全性。</li><li>初始化保证：组件在使用前已完全初始化，减少了潜在的错误。</li><li>测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。</li></ol><p>构造函数注入适合处理<strong>必需的依赖项</strong>，而 <strong>Setter 注入</strong> 则更适合<strong>可选的依赖项</strong>，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 <code class="language-plaintext highlighter-rouge">@Autowired</code> 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。</p><p>在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是<strong>唯一的选择</strong>。</p><h3 id="bean-的作用域有哪些">Bean 的作用域有哪些?</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code class="language-plaintext highlighter-rouge">getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><h3 id="bean-的生命周期了解么">Bean 的生命周期了解么?</h3><ol><li><p><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</p></li><li><p><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code class="language-plaintext highlighter-rouge">@Autowired</code> 等注解注入的对象、<code class="language-plaintext highlighter-rouge">@Value</code> 注入的值、<code class="language-plaintext highlighter-rouge">setter</code>方法或构造函数注入依赖和值、<code class="language-plaintext highlighter-rouge">@Resource</code>注入的各种资源。</p></li><li><p>Bean 初始化</p><p>：</p><ul><li>如果 Bean 实现了 <code class="language-plaintext highlighter-rouge">BeanNameAware</code> 接口，调用 <code class="language-plaintext highlighter-rouge">setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code class="language-plaintext highlighter-rouge">BeanClassLoaderAware</code> 接口，调用 <code class="language-plaintext highlighter-rouge">setBeanClassLoader()</code>方法，传入 <code class="language-plaintext highlighter-rouge">ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code class="language-plaintext highlighter-rouge">BeanFactoryAware</code> 接口，调用 <code class="language-plaintext highlighter-rouge">setBeanFactory()</code>方法，传入 <code class="language-plaintext highlighter-rouge">BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code class="language-plaintext highlighter-rouge">*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> 对象，执行<code class="language-plaintext highlighter-rouge">postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code class="language-plaintext highlighter-rouge">InitializingBean</code>接口，执行<code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 <code class="language-plaintext highlighter-rouge">init-method</code> 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> 对象，执行<code class="language-plaintext highlighter-rouge">postProcessAfterInitialization()</code> 方法。</li></ul></li><li><p>销毁 Bean</p><p>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。</p><ul><li>如果 Bean 实现了 <code class="language-plaintext highlighter-rouge">DisposableBean</code> 接口，执行 <code class="language-plaintext highlighter-rouge">destroy()</code> 方法。</li><li>如果 Bean 在配置文件中的定义包含 <code class="language-plaintext highlighter-rouge">destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code class="language-plaintext highlighter-rouge">@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li></ul></li></ol><p>Bean 的生命周期大致分为五个阶段：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062341884.png" alt="三分恶面渣逆袭：Bean生命周期五个阶段" />三分恶面渣逆袭：Bean生命周期五个阶段</p><ul><li><strong>实例化</strong>：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。</li><li><strong>属性赋值</strong>：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为依赖注入，确保 Bean 所需的所有依赖都被注入。</li><li><strong>初始化</strong>：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。</li><li><strong>使用中</strong>：Bean 准备好可以使用了。</li><li><strong>销毁</strong>：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。</li></ul><p><strong>如何记忆呢？</strong></p><ol><li>整体上可以简单分为四步：实例化 —&gt; 属性赋值 —&gt; 初始化 —&gt; 销毁。</li><li>初始化这一步涉及到的步骤比较多，包含 <code class="language-plaintext highlighter-rouge">Aware</code> 接口的依赖注入、<code class="language-plaintext highlighter-rouge">BeanPostProcessor</code> 在初始化前后的处理以及 <code class="language-plaintext highlighter-rouge">InitializingBean</code> 和 <code class="language-plaintext highlighter-rouge">init-method</code> 的初始化操作。</li><li>销毁这一步会注册相关销毁回调接口，最后通过<code class="language-plaintext highlighter-rouge">DisposableBean</code> 和 <code class="language-plaintext highlighter-rouge">destory-method</code> 进行销毁。</li></ol><p>最后，再分享一张清晰的图解（图源：<a href="https://chaycao.github.io/2020/02/15/如何记忆Spring-Bean的生命周期.html">如何记忆 Spring Bean 的生命周期</a>）。</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062339187.png" alt="img" /></p><h3 id="spring-中的单例-bean-会存在线程安全问题吗">Spring 中的单例 Bean 会存在线程安全问题吗？</h3><p>Spring Bean 的默认作用域是单例（Singleton），这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会被多个线程共享。</p><p>如果单例 Bean 是无状态的，也就是没有成员变量，那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，基本上都是无状态的。</p><p>但如果 Bean 的内部状态是可变的，且没有进行适当的同步处理，就可能出现线程安全问题。</p><p>对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：</p><ol><li><strong>避免可变成员变量</strong>: 尽量设计 Bean 为无状态。</li><li><strong>使用<code class="language-plaintext highlighter-rouge">ThreadLocal</code></strong>: 将可变成员变量保存在 <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 中，确保线程独立。</li><li><strong>使用同步机制</strong>: 利用 <code class="language-plaintext highlighter-rouge">synchronized</code> 或 <code class="language-plaintext highlighter-rouge">ReentrantLock</code> 来进行同步控制，确保线程安全。</li></ol></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
