<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://mafulong.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mafulong.github.io/" rel="alternate" type="text/html" /><updated>2025-08-27T08:58:44+08:00</updated><id>https://mafulong.github.io/feed.xml</id><title type="html">Fulongのblog</title><subtitle>Fulongのblog</subtitle><author><name>Fulong Ma</name></author><entry><title type="html">香港办卡</title><link href="https://mafulong.github.io/2025/08/24/%E9%A6%99%E6%B8%AF%E5%8A%9E%E5%8D%A1/" rel="alternate" type="text/html" title="香港办卡" /><published>2025-08-24T00:00:00+08:00</published><updated>2025-08-24T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/24/%E9%A6%99%E6%B8%AF%E5%8A%9E%E5%8D%A1</id><content type="html" xml:base="https://mafulong.github.io/2025/08/24/%E9%A6%99%E6%B8%AF%E5%8A%9E%E5%8D%A1/">&lt;h2 id=&quot;香港办卡&quot;&gt;香港办卡&lt;/h2&gt;

&lt;p&gt;内地人开香港账户都需要注意什么呢？ 1️⃣首先人必须在香港，进入香港后，连上本地的wifi，机场、公园、地铁站都有免费🛜WiFi，手机下载好中银和汇丰两个App，我以汇丰为例。&lt;/p&gt;

&lt;p&gt;身份验证： ✅用手机NFC功能扫描港澳通行证（贴手机背部上方）； ✅人脸识别（摘眼镜！光线要亮，别遮挡）； ✅上传移民局出入境记录（微信提前搜索：“移民局12367”下载好出入境记录，注意是是PDF格式）&lt;/p&gt;

&lt;p&gt;注意事项： ✅手机要开通漫游，接收验证码 ✅身份证、港澳通行证有效期必须大于6个月以上 ✅入境时如果走人工通道保留好签证小白条，如果走自助通道，去出入境网站截屏入境记录。 ✅收到实体卡后， 别忘了在手机银行里激活，存100元 ✅开卡后牢记账户和密码，最好写下来 ✅实体卡约20个工作日寄到内地家中&lt;/p&gt;

&lt;p&gt;、&lt;/p&gt;

&lt;p&gt;https://www.xiaohongshu.com/explore/67de7a2c0000000009039ee1?xsec_token=ABSpfbH7nGGPDEp91QFWP_ospSxrGufHQLykJzflM2Iv0=&amp;amp;xsec_source=pc_search&amp;amp;source=web_explore_feed&lt;/p&gt;

&lt;p&gt;我办的卡：有汇丰、中银、工银、建亚、信银、ZA、天星、永隆。&lt;/p&gt;

&lt;p&gt;推荐办理：
汇丰、中银、工银、ZA、天星。&lt;/p&gt;

&lt;p&gt;ZA(众安)银-行码：HW2B47
开-户时填我的邀-请码，达-标后我个人返100港-币给你
怎么才能达－标：1、在香港开投-资账-户(必须在香港才能开)，2、审核通过后放1000港币在账-户里，其中100要买基-金，3、一天左右就能达。
办-理理由：
1.中银、汇丰、工银资-金免费出国。
2.建亚、工银、ATM直接取现。
5.信银大富翁存-款利-率高，玩信-用卡必开。
4.ZA对虚-拟货-币友好，香港排名第一的虚-拟-银行。
5.天星换汇很好。&lt;/p&gt;

&lt;p&gt;开卡注意事项：
1.中银理由投-资理-财，下面都用这个。会需要你提供投-资-证明，你提前在支-付宝买-个几百块基-金就好。
2.汇丰可能会看投-资证明，最容易的，也可以手机开户，存100激活。
3.&lt;strong&gt;工银网上申-请，之后预约网点，还有一个渠道在落马洲地铁站和罗湖口岸出境方向有vtm开户，我就在那开的，理由理-财，开-不了投-资。&lt;/strong&gt;建议有空去申领密码器和设置ATM海外取-款，最长5年(打人工电话或在香港ATM设置)，日2W，有些网点可能要存1W有些不用。
4.建亚先在公众号或app填表，之后会有总行的人联系你，帮你预-约你选的开-户行，就算没预约上到了分行他们核-实后一般也会帮你办理，不用存-钱。
5.&lt;strong&gt;信银预约直接去开-户，申领提款卡免费邮寄的，不用存-钱。网上开-户想要提款卡，某些网点等1天，大多数要等7天才可申领，避坑香港岛。&lt;/strong&gt;
6.&lt;strong&gt;ZA和天星，直接开。&lt;/strong&gt;
7.招商永隆，资-金没达标50w给你开受限账-户，普通账-户也要验-资，没啥用。
8.其他虚拟银行没啥大用，除非有活动送钱才开。&lt;/p&gt;

&lt;p&gt;资-金出国：
1.兴业环宇人生(购汇5折最推荐)→汇丰
2.中行→中银，中行购汇不优，我第一次被薅了200多元，建议下午购汇。
3.工行→工银，大亚湾免费，其他地区免费到6月30日。
4.要手续费的像熊猫速汇，WISE、支付宝和腾讯跨境汇款。
7.人-肉背每次限2W人民币美元我暂不考虑，能存人-民币的有ATM柜台中银、工银、南洋、永隆，汇丰柜台。&lt;/p&gt;

&lt;p&gt;资-金回内地ATM机取-现或汇-款：
1.建亚无损取的人-民币。
2.&lt;strong&gt;工银有损取港-币转换，但汇率优，损耗小。&lt;/strong&gt;
3.&lt;strong&gt;汇丰蓝狮子取现&lt;/strong&gt;
4.&lt;strong&gt;中银→中行免费&lt;/strong&gt;
5.&lt;strong&gt;工银→工行免费&lt;/strong&gt;
6.&lt;strong&gt;汇丰和中银的扣账卡绑定支-付宝200内免手-续费。&lt;/strong&gt;
7.收费熊猫速汇、WISE、支付-宝和腾讯跨境汇-款&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="DailyLife" /><category term="DailyLife" /><summary type="html">香港办卡</summary></entry><entry><title type="html">win11游戏主机配置</title><link href="https://mafulong.github.io/2025/08/17/win11%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="win11游戏主机配置" /><published>2025-08-17T00:00:00+08:00</published><updated>2025-08-17T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/17/win11%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="https://mafulong.github.io/2025/08/17/win11%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/">&lt;h1 id=&quot;主机&quot;&gt;主机&lt;/h1&gt;

&lt;h2 id=&quot;win11游戏主机配置&quot;&gt;win11游戏主机配置&lt;/h2&gt;

&lt;h2 id=&quot;电脑必装软件&quot;&gt;电脑必装软件&lt;/h2&gt;

&lt;h3 id=&quot;电脑配置&quot;&gt;电脑配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;：AMD R7 9800X3D —— ¥3299&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;主板&lt;/strong&gt;：技嘉 B850 大冰雕 WiFi d5 —— ¥1649&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;：阿斯加特女武神二代 24×2 48G DDR5 6000MHz C28 —— ¥1089&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;固态&lt;/strong&gt;：致钛 TiPlus 7100 4TB —— ¥1799&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显卡&lt;/strong&gt;：影驰 RTX 5080 金属大师白金 OC —— ¥9299&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;电源&lt;/strong&gt;：海韵 FOCUS GX 1000W ATX3.1 白金牌全模组 —— ¥1249&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU散热&lt;/strong&gt;：瓦尔基里 B360GT —— ¥549&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;机箱&lt;/strong&gt;：爱国者 星璨大岚 —— ¥449&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;风扇&lt;/strong&gt;：棱镜 6Pro ×7 —— ¥140&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;驱动&quot;&gt;驱动&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;机箱下面有个屏显，没装&lt;/li&gt;
  &lt;li&gt;散热的屏显: myth.Cool 同时可以展示系统信息&lt;/li&gt;
  &lt;li&gt;NVIDIA app： 显卡驱动&lt;/li&gt;
  &lt;li&gt;GIBGABYTE control center: 技嘉主板软件，同时可以自动下电脑网卡等驱动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;软件&quot;&gt;软件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;clash. 花云上下载&lt;/li&gt;
  &lt;li&gt;ea app&lt;/li&gt;
  &lt;li&gt;steam app&lt;/li&gt;
  &lt;li&gt;uu加速器&lt;/li&gt;
  &lt;li&gt;epic games app&lt;/li&gt;
  &lt;li&gt;xbox app&lt;/li&gt;
  &lt;li&gt;xbox 配件 蓝牙连手柄用，否则只能有线连&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;游戏&quot;&gt;游戏&lt;/h2&gt;

&lt;h3 id=&quot;快捷键&quot;&gt;快捷键&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;cmd + G: 唤醒xbox游戏工具箱&lt;/li&gt;
  &lt;li&gt;option + cmd + b: 切换Hdr开关&lt;/li&gt;
  &lt;li&gt;option + z: 唤醒nvidia 游戏工具箱&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;电脑设置&quot;&gt;电脑设置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;调整游戏录制时长。 设置 -&amp;gt; 游戏 -&amp;gt; 摄像 -&amp;gt; 录制游戏过程 下拉箭头 -&amp;gt; 录制上次内容 时间30s 改成 5分钟&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;视频录制分享&quot;&gt;视频录制分享&lt;/h3&gt;

&lt;p&gt;cmd + G回放下载。&lt;/p&gt;

&lt;p&gt;cmd + G点图库就可以点开视频。 微软自带champin可以编辑视频，编辑后保存到onedrive，再手机onedrive里下载。&lt;/p&gt;

&lt;h3 id=&quot;游戏模式&quot;&gt;游戏模式&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;开启游戏模式&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;打开 &lt;em&gt;设置 → 游戏 → 游戏模式&lt;/em&gt;，确保开启。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开启硬件加速 GPU 计划&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;设置 → 显示 → 图形 → 更改默认图形设置 → 开启“硬件加速 GPU 计划”。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Steam 玩家注意事项&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;打开 Steam → 好友 → 离线模式。&lt;/li&gt;
      &lt;li&gt;避免后台好友列表占用，帧数会更稳定。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;独显直连&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;确保开启独显直连（特别是笔记本用户）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;电源模式&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;联想用户：超能模式 &amp;lt; 野兽模式 → 建议开启“野兽模式”。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;网络加速&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;推荐使用加速器（如雷神），能降低延迟。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;系统设置优化&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;显卡控制面板 → 调整为性能模式&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显存不足时 → 开启内存回退&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;电源管理 → 最高性能优先&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;系统 → 屏幕 → 图形 → 开启 GPU 硬件加速 → 重启电脑&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;显示器设置&quot;&gt;显示器设置&lt;/h2&gt;

&lt;p&gt;小米电视gpro27u&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关闭自动亮度&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认开启 → 会错误调整伽马和亮度，导致观感不好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;游戏模式优化&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;进入方式&lt;/strong&gt;：遥控器 → 长按“三条杠” → 二级菜单 → 设置。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;推荐参数&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;亮度：40（默认 70，过高伤眼）&lt;/li&gt;
      &lt;li&gt;色温：改为 &lt;strong&gt;标准&lt;/strong&gt;（避免暖色 / 偏红）&lt;/li&gt;
      &lt;li&gt;色彩增强：关闭&lt;/li&gt;
      &lt;li&gt;色彩空间：P3&lt;/li&gt;
      &lt;li&gt;FreeSync：开启（防撕裂）&lt;/li&gt;
      &lt;li&gt;响应时间：普通（快速模式会过冲）.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;📌 调整后：画面不再发红，色彩自然，适合日常与游戏使用。&lt;/p&gt;

&lt;p&gt;不建议在 NVIDIA 控制面板里修改数字通道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HDR 下可能有效，但会影响 SDR 下的色准。&lt;/li&gt;
  &lt;li&gt;尽量在显示器硬件里直接调节。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;暗部增强功能&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提升暗部细节辨识度（例如黑夜地图能更容易发现敌人）。&lt;/li&gt;
  &lt;li&gt;对 FPS 玩家非常实用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;游戏-1&quot;&gt;游戏&lt;/h1&gt;

&lt;h2 id=&quot;软件设置-cod&quot;&gt;软件设置 Cod&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;显示设置&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;显示模式&lt;/strong&gt;：全屏专用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显示器&lt;/strong&gt;：选择主显示器&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显卡&lt;/strong&gt;：确保使用独显，不要用集显&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;刷新率&lt;/strong&gt;：与屏幕一致&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分辨率&lt;/strong&gt;：根据自己屏幕设置&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;垂直同步&lt;/strong&gt;：关闭&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;关闭语音聊天&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;路径：音频设置 → 语音聊天 → 全关（推荐）。&lt;/li&gt;
  &lt;li&gt;效果：从 130 FPS → 160–200 FPS，大幅提升帧数，掉帧问题明显改善。&lt;/li&gt;
  &lt;li&gt;原因：语音频道后台占用系统资源，影响帧数。COD19、20 也有类似问题，但 COD21 更严重。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DLSS / 帧生成&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;DLSS / DLSSR&lt;/strong&gt;：建议开启（提升画质和性能）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;帧生成（Frame Generation）&lt;/strong&gt;：不建议开启。
    &lt;ul&gt;
      &lt;li&gt;开启后帧数可冲到 200+ FPS，但输入延迟明显增加（从 &amp;lt;20ms → 40ms）。&lt;/li&gt;
      &lt;li&gt;FPS 游戏对延迟敏感 → 关掉更合适。&lt;/li&gt;
      &lt;li&gt;单机 / 画面党可开启，但多人 FPS 建议关闭。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：需要在系统里开启 &lt;strong&gt;GPU 硬件加速&lt;/strong&gt; 才能生效。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;提示&lt;/strong&gt;：开启后帧数更高，但可能带来输入延迟 → FPS 游戏需谨慎。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;显卡驱动务必保持最新&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次新作发布，官方都会更新驱动优化性能。&lt;/li&gt;
  &lt;li&gt;NVIDIA → GeForce Experience 可一键更新。&lt;/li&gt;
  &lt;li&gt;AMD 用户去官网输入显卡型号下载即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;锁定画面设置（视觉增强）&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;：设置 → 界面 → 易读性 → 定制颜色 → 打开。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;敌方颜色饱和度 / 亮度拉满&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;滤镜&lt;/strong&gt;：选择滤镜 2，两个颜色强度拉满。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：敌人更明显，画面更干净，提升发现敌人的效率。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;缺点：色调可能部分玩家不喜欢，可随时改回默认。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;质量设置&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;渲染分辨率&lt;/strong&gt;：100（不要降低，否则会模糊）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动态分辨率&lt;/strong&gt;：关闭（帧数不足时可以开，但可能模糊/撕裂）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;图像锐化&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;推荐 &lt;strong&gt;CAS&lt;/strong&gt;（75 左右），画质比大力水手更清晰&lt;/li&gt;
      &lt;li&gt;大力水手帧数高，但噪点和模糊严重&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;超分辨率生成&lt;/strong&gt;：关闭&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显存比例&lt;/strong&gt;：默认 80（显存不足可开到 90）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;着色器预缓存&lt;/strong&gt;：一定要关闭，否则会频繁卡顿&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;画质与帧数测试结论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作者花费 7–8 小时测试，逐项调整后得到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对帧数影响最大&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;子弹撞击效果&lt;/strong&gt;：关闭后可提升 ~30 帧。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;屏幕反射&lt;/strong&gt;：关闭或调低可提升 ~10–20 帧。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对帧数影响中等&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;环境&lt;/strong&gt;：影响适中，需根据需求调整。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对帧数影响小但画质影响大&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;全局质量、阴影和光照&lt;/strong&gt;：画质显著提升，但帧数损耗小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;材质分辨率&lt;/strong&gt;：必须设高，对画质影响大，对帧数影响小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;景深&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;开启 → 开镜后枪模糊&lt;/li&gt;
      &lt;li&gt;关闭 → 枪更清晰（推荐关闭）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;材质与细节&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;细节质量（石头草木等）&lt;/strong&gt;：低（性能优化明显）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;网格解析度&lt;/strong&gt;：高（对帧率影响小，但能提升视觉和武器贴图特效）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;粒子效果&lt;/strong&gt;：低（高会掉 10-20 帧）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;材质加载与传输&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;高清材质流&lt;/strong&gt;：开优化（对画质有帮助，显存占用适中）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地材质传输&lt;/strong&gt;：低（对战区大地图远景才有用，一般影响不大，显存占用高）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;其他提示&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;锁帧设置&lt;/strong&gt;：COD20 有效，但本作无明显作用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DLSS Bug&lt;/strong&gt;：有时切换后会自动变成 CAS → 需留意。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据监控&lt;/strong&gt;：界面 → 状态 → 选择显示 FPS、延迟、显存占用等信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次修改画质设置后，&lt;strong&gt;一定要重新预载着色器&lt;/strong&gt;：
 进入显示界面 → 预载 → 保存 → 退出游戏 → 重启再进游戏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;软件设置-apex&quot;&gt;软件设置 Apex&lt;/h2&gt;

&lt;h3 id=&quot;关键参数解释与建议&quot;&gt;关键参数解释与建议&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;以“稳定帧率优先”为导向；如需更好画质可在稳定后微调。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;① 各向异性过滤（Anisotropic Filtering）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;影响&lt;/strong&gt;：主要吃显卡，&lt;strong&gt;对帧数影响仅几帧&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;建议&lt;/strong&gt;：在中低端卡上也能开到 &lt;strong&gt;8×&lt;/strong&gt;（示例：&lt;strong&gt;GTX 1050 Ti @ 8×&lt;/strong&gt; 运行良好）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;取舍&lt;/strong&gt;：更高带来更清晰的斜向纹理，性价比高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;② 碰撞痕迹/冲击痕迹（Decals / Impact Marks）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;影响&lt;/strong&gt;：&lt;strong&gt;吃 CPU&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;建议&lt;/strong&gt;：&lt;strong&gt;调为 0&lt;/strong&gt;，明显减负。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;③ 纹理串流预算（Texture Streaming Budget）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;：与&lt;strong&gt;显存大小&lt;/strong&gt;绑定，决定可加载纹理体量与切换速度。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;操作&lt;/strong&gt;：
    &lt;ol&gt;
      &lt;li&gt;先在游戏里选择接近你显存的档位，&lt;strong&gt;查看/记下实际“流内存大小”&lt;/strong&gt;；&lt;/li&gt;
      &lt;li&gt;回到配置文件写入相应值；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;特殊规则&lt;/strong&gt;：如果你想设为 &lt;strong&gt;2GB 显存&lt;/strong&gt;，配置文件中&lt;strong&gt;该字段需写“1”&lt;/strong&gt;；&lt;strong&gt;其余情况写“0”&lt;/strong&gt;（按原作者说明）。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;策略&lt;/strong&gt;：在&lt;strong&gt;不爆显存&lt;/strong&gt;前提下尽量拉高，提升清晰度与加载体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;④ 模型刷新/细节（Model LOD/Detail）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;建议&lt;/strong&gt;：&lt;strong&gt;0.6&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：再低会让&lt;strong&gt;中距离对枪“果冻/方块化”&lt;/strong&gt;（人物像块状），影响观察。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⑤ 阴影 &amp;amp; 环境光遮蔽（Shadows / Ambient Occlusion）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;建议&lt;/strong&gt;：&lt;strong&gt;全部关闭&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：这两项对视觉收益有限、对性能影响大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⑥ 自适应分辨率 / 帧率目标（Dynamic Resolution / Adaptive）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;定位&lt;/strong&gt;：本方案的&lt;strong&gt;关键项&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：为保持&lt;strong&gt;目标帧数&lt;/strong&gt;，在负载高时&lt;strong&gt;动态降低分辨率/画质&lt;/strong&gt;，负载回落再提升。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用法&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;启用&lt;/strong&gt;自适应（配置项打开），设置&lt;strong&gt;目标帧率&lt;/strong&gt;（如 60/75/90/100）。&lt;/li&gt;
      &lt;li&gt;分辨率基准建议 &lt;strong&gt;1080p&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;抗锯齿&lt;/strong&gt;（TAA 等）建议&lt;strong&gt;开启&lt;/strong&gt;，与自适应配合可减轻低分辨率时的锯齿与闪烁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实测参考（GTX 1050 Ti）&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;启用自适应时，&lt;strong&gt;上限约 ~100FPS&lt;/strong&gt;；&lt;/li&gt;
      &lt;li&gt;若 100FPS 仍不满足，可将&lt;strong&gt;与自适应相关的 3 项置 0&lt;/strong&gt;（等同关闭/限制），实际读数出现 &lt;strong&gt;100–144FPS&lt;/strong&gt; 的波动；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;代价&lt;/strong&gt;：中距离识别变差（“红点看缘分”），画面锐度随负载波动较明显。&lt;/li&gt;
      &lt;li&gt;建议：&lt;strong&gt;先求稳再求高&lt;/strong&gt;，优先稳定的目标帧（如 90/100），再考虑进一步抬上限。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⑦ 抗锯齿（AA）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;建议&lt;/strong&gt;：本方案里&lt;strong&gt;默认开启&lt;/strong&gt;，与自适应联动更顺眼。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;说明&lt;/strong&gt;：如极度追求清晰边缘与响应，可在稳定后尝试调低或关闭，但可能出现闪烁。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;#&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">主机</summary></entry><entry><title type="html">mac mini做nas+小米电视</title><link href="https://mafulong.github.io/2025/08/10/mac-mini%E5%81%9Anas+%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86/" rel="alternate" type="text/html" title="mac mini做nas+小米电视" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/10/mac%20mini%E5%81%9Anas+%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86</id><content type="html" xml:base="https://mafulong.github.io/2025/08/10/mac-mini%E5%81%9Anas+%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86/">&lt;h2 id=&quot;mac-mini做nas小米电视&quot;&gt;mac mini做nas+小米电视&lt;/h2&gt;

&lt;h2 id=&quot;nas&quot;&gt;nas&lt;/h2&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unless&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mafulong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Downloads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NAS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emby_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8096&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;8096&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;linuxserver/emby&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;自己ip&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ipconfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getifaddr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;en1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;adb&quot;&gt;adb&lt;/h2&gt;

&lt;p&gt;adb可以远程connect&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;31.148&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;安装软件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TVBox_takagen99_20250706&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1456&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arm64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;apk&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;传输文件&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;但小米电视无法读adb的文件&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/Users/mafulong/Downloads/爱、死亡与机器人.Love.Death.and.Robots.S01E01.中英字幕.WEBrip.720P-人人影视.V2.mp4&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sdcard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">mac mini做nas+小米电视</summary></entry><entry><title type="html">Goland的external tool</title><link href="https://mafulong.github.io/2025/08/09/Goland%E7%9A%84external-tool/" rel="alternate" type="text/html" title="Goland的external tool" /><published>2025-08-09T00:00:00+08:00</published><updated>2025-08-09T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/09/Goland%E7%9A%84external%20tool</id><content type="html" xml:base="https://mafulong.github.io/2025/08/09/Goland%E7%9A%84external-tool/">&lt;h2 id=&quot;goland的external-tool&quot;&gt;Goland的external tool&lt;/h2&gt;

&lt;p&gt;goland external open in xx 配置&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;```&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;用zsh&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;下面open&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;参数&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;REPO_ROOT=$(git -C \&quot;$ProjectFileDir$\&quot; rev-parse --show-toplevel); PROJECT=$(basename \&quot;$REPO_ROOT\&quot;); BRANCH=$(git -C \&quot;$REPO_ROOT\&quot; rev-parse --abbrev-ref HEAD); FILE=\&quot;$FilePathRelativeToProjectRoot$\&quot;; LINE=$LineNumber$; URL=\&quot;xxxxxx/$PROJECT/-/blob/$BRANCH/$FILE?ref_type=heads#L$LINE\&quot;; open \&quot;$URL\&quot;&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;下面copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;参数&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;REPO_ROOT=$(git -C \&quot;$ProjectFileDir$\&quot; rev-parse --show-toplevel); PROJECT=$(basename \&quot;$REPO_ROOT\&quot;); BRANCH=$(git -C \&quot;$REPO_ROOT\&quot; rev-parse --abbrev-ref HEAD); FILE=\&quot;$FilePathRelativeToProjectRoot$\&quot;; LINE=$LineNumber$; URL=\&quot;xxxx/$PROJECT/-/blob/$BRANCH/$FILE?ref_type=heads#L$LINE\&quot;; echo \&quot;$URL\&quot; | pbcopy&quot;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;```&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">Goland的external tool</summary></entry><entry><title type="html">浦东公租房</title><link href="https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF/" rel="alternate" type="text/html" title="浦东公租房" /><published>2025-05-15T00:00:00+08:00</published><updated>2025-05-15T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF</id><content type="html" xml:base="https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF/">&lt;h2 id=&quot;公租房&quot;&gt;公租房&lt;/h2&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/720027504&lt;/p&gt;

&lt;h2 id=&quot;浦东地图&quot;&gt;浦东地图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505152350009.png&quot; alt=&quot;image-20250515235026893&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;房源&quot;&gt;房源&lt;/h2&gt;

&lt;h3 id=&quot;公租房-1&quot;&gt;公租房&lt;/h3&gt;

&lt;h4 id=&quot;仁文公寓&quot;&gt;仁文公寓&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=9765&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3700&lt;/strong&gt;元/月 53平。&lt;/p&gt;

&lt;p&gt;一室一厅，停车300一月。&lt;/p&gt;

&lt;p&gt;靠近二甲 上海明珠医院。&lt;/p&gt;

&lt;p&gt;48分钟，41km， 26分钟。&lt;/p&gt;

&lt;h4 id=&quot;浦三路930弄-艾东苑&quot;&gt;浦三路930弄 艾东苑&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=8613486F-AA0F-4AD6-9BD1-B6D62BCFA29B&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;49.87&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4128&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;48分钟，44km，17分钟，12km.&lt;/p&gt;

&lt;h4 id=&quot;川和路399弄张江兴科苑&quot;&gt;川和路399弄（张江兴科苑）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;4081&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;47.72&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 205&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-03-16&lt;/li&gt;
  &lt;li&gt;地址： 川和路399弄（张江兴科苑）/11-12号/02楼/205&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没有车位。&lt;/p&gt;

&lt;p&gt;52分钟，48km， 14分钟，4.5km。&lt;/p&gt;

&lt;h3 id=&quot;公租房三林&quot;&gt;公租房三林&lt;/h3&gt;

&lt;h4 id=&quot;三舒路-城林美苑&quot;&gt;三舒路 城林美苑&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=706833db-607b-4f3c-846b-96f144c516d7&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2850&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;67.55&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 08楼&lt;/p&gt;

&lt;p&gt;房号： 806&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 三舒路33弄（城林美苑）/04号/08楼/806&lt;/li&gt;
  &lt;li&gt;室内配套：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;52 分 ，18km, 32 分钟。&lt;/p&gt;

&lt;h4 id=&quot;永泰路136弄&quot;&gt;永泰路136弄&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=B3EC3477-2161-4A31-8441-ACD494761328&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2963&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：2准入资格证202517140007390 （2025-05-19）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;51.61&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 203&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 永泰路136弄/33号/2楼/203&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;56mins, 27mins.&lt;/p&gt;

&lt;h4 id=&quot;三旋路506弄绿波家园&quot;&gt;三旋路506弄（绿波家园&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=34BE3519-D644-4915-AC8F-DE4864AF83FB&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2793&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：9准入资格证202317140008848 （2023-06-07）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;64.99&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 21楼&lt;/p&gt;

&lt;p&gt;房号： 2104&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 三旋路506弄（绿波家园）/19号/21楼/2104&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;52mins, 31mins。&lt;/p&gt;

&lt;h4 id=&quot;杨南路&quot;&gt;杨南路&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=8633&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3365&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：2准入资格证202317140018617 （2023-11-30）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;56.80&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 202&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 杨南路694弄/81号/2楼/202&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;55mins, 25mins&lt;/p&gt;

&lt;h4 id=&quot;和炯路77弄盛世南苑&quot;&gt;和炯路77弄（盛世南苑）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;2633&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：6准入资格证202317140009994 （2023-06-25）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;65.26&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 01楼&lt;/p&gt;

&lt;p&gt;房号： 101&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-09&lt;/li&gt;
  &lt;li&gt;地址： 和炯路77弄（盛世南苑）/13号/1楼/101&lt;/li&gt;
  &lt;li&gt;室内配套：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;55mins, 32mins&lt;/p&gt;

&lt;h3 id=&quot;非公租房&quot;&gt;非公租房&lt;/h3&gt;

&lt;h4 id=&quot;高科苑&quot;&gt;高科苑&lt;/h4&gt;

&lt;p&gt;高科苑，就在复旦大学和曙光医院旁边，距离中科路不远，这个小区环境不错，可以租一室一厅&lt;/p&gt;

&lt;p&gt;小区没有二房东，是张江高科集团建的对外出租，不存在二房东改造问题&lt;/p&gt;

&lt;p&gt;地下车库地上车库都有，停车费也不贵&lt;/p&gt;

&lt;p&gt;52分钟，50km, 距离公司 3km&lt;/p&gt;

&lt;h4 id=&quot;张江万科翡翠公园&quot;&gt;张江万科翡翠公园&lt;/h4&gt;

&lt;p&gt;53分钟，50km, 14分钟，4.5km。&lt;/p&gt;

&lt;h3 id=&quot;保租房&quot;&gt;保租房&lt;/h3&gt;

&lt;h4 id=&quot;纳仕&quot;&gt;纳仕&lt;/h4&gt;

&lt;p&gt;纳什国际，新的&lt;/p&gt;

&lt;p&gt;贵的不行&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="DailyLife" /><category term="DailyLife" /><summary type="html">公租房</summary></entry><entry><title type="html">Spring AOP</title><link href="https://mafulong.github.io/2025/05/06/Spring-AOP/" rel="alternate" type="text/html" title="Spring AOP" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20AOP</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-AOP/">&lt;h2 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h2&gt;

&lt;h2 id=&quot;谈谈自己对于-aop-的了解&quot;&gt;谈谈自己对于 AOP 的了解&lt;/h2&gt;

&lt;p&gt;AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。&lt;/p&gt;

&lt;p&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;

&lt;p&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;strong&gt;JDK Proxy&lt;/strong&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;strong&gt;Cglib&lt;/strong&gt; 生成一个被代理对象的子类来作为代理&lt;/p&gt;

&lt;p&gt;当然你也可以使用 &lt;strong&gt;AspectJ&lt;/strong&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;

&lt;p&gt;AOP 切面编程涉及到的一些专业术语：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;术语&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;目标(Target)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被通知的对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代理(Proxy)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;连接点(JoinPoint)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切入点(Pointcut)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通知(Advice)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切面(Aspect)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Weaving(织入)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Spring&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AOP&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AspectJ&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;注解&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;如&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;来声明切面&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;它是单独的aop框架&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;可以在非spring里使用&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;和spring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aop是两套&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;它是编译时织入&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使用代理方式实现&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AOP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JDK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;动态代理&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;接口型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CGLIB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;动态代理&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;类型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;aop-常见的通知类型有哪些&quot;&gt;AOP 常见的通知类型有哪些？&lt;/h2&gt;

&lt;p&gt;AOP 一般有 &lt;strong&gt;5 种&lt;/strong&gt;环绕方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前置通知 (@Before)&lt;/li&gt;
  &lt;li&gt;返回通知 (@AfterReturning)&lt;/li&gt;
  &lt;li&gt;异常通知 (@AfterThrowing)&lt;/li&gt;
  &lt;li&gt;后置通知 (@After)&lt;/li&gt;
  &lt;li&gt;环绕通知 (@Around)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062358585.png&quot; alt=&quot;三分恶面渣逆袭：环绕方式&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;aspectj-是什么&quot;&gt;AspectJ 是什么？&lt;/h2&gt;

&lt;h3 id=&quot;aspectj&quot;&gt;AspectJ&lt;/h3&gt;

&lt;p&gt;AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 表示这是一个切面类&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Spring 管理该类的 Bean&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 定义一个切入点，匹配 HelloService 中的所有方法&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Pointcut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;execution(* com.example.demo.HelloService.*(..))&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;helloServiceMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 方法执行之前的通知（Before Advice）&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloServiceMethods()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logBefore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Method is about to execute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 方法执行之后的通知（After Advice）&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@After&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloServiceMethods()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logAfter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Method has executed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;spring-aop-和-aspectj-aop-有什么区别&quot;&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;Spring AOP&lt;/th&gt;
      &lt;th&gt;AspectJ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;增强方式&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时增强（基于动态代理）&lt;/td&gt;
      &lt;td&gt;编译时增强、类加载时增强（直接操作字节码）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;切入点支持&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;方法级（Spring Bean 范围内，不支持 final 和 staic 方法）&lt;/td&gt;
      &lt;td&gt;方法级、字段、构造器、静态方法等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时依赖代理，有一定开销，切面多时性能较低&lt;/td&gt;
      &lt;td&gt;运行时无代理开销，性能更高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;简单，易用，适合大多数场景&lt;/td&gt;
      &lt;td&gt;功能强大，但相对复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Spring 应用下比较简单的 AOP 需求&lt;/td&gt;
      &lt;td&gt;高性能、高复杂度的 AOP 需求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;如何选择？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能考量&lt;/strong&gt;：AspectJ 支持更复杂的 AOP 场景，Spring AOP 更简单易用。如果你需要增强 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 方法、静态方法、字段访问、构造器调用等，或者需要在非 Spring 管理的对象上应用增强逻辑，AspectJ 是唯一的选择。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能考量&lt;/strong&gt;：切面数量较少时两者性能差异不大，但切面较多时 AspectJ 性能更优。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一句话总结&lt;/strong&gt;：简单场景优先使用 Spring AOP；复杂场景或高性能需求时，选择 AspectJ。&lt;/p&gt;

&lt;p&gt;Spring AOP 属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;运行时增强&lt;/code&gt;，主要具有如下特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现&lt;/li&gt;
  &lt;li&gt;Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现&lt;/li&gt;
  &lt;li&gt;在性能上，由于 Spring AOP 是基于&lt;strong&gt;动态代理&lt;/strong&gt;来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。&lt;/li&gt;
  &lt;li&gt;Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AspectJ 是一个易用的功能强大的 AOP 框架，属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;编译时增强&lt;/code&gt;， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。&lt;/p&gt;

&lt;p&gt;AspectJ 属于&lt;strong&gt;静态织入&lt;/strong&gt;，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。&lt;/li&gt;
  &lt;li&gt;编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。&lt;/li&gt;
  &lt;li&gt;类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sprint-aop&quot;&gt;Sprint AOP&lt;/h2&gt;

&lt;h3 id=&quot;spring-aop-发生在什么时候&quot;&gt;Spring AOP 发生在什么时候？&lt;/h3&gt;

&lt;p&gt;Spring AOP 基于运行时代理机制，这意味着 Spring AOP 是在运行时通过动态代理生成的，而不是在编译时或类加载时生成的。&lt;/p&gt;

&lt;p&gt;在 Spring 容器初始化 Bean 的过程中，Spring AOP 会检查 Bean 是否需要应用切面。如果需要，Spring 会为该 Bean 创建一个代理对象，并在代理对象中织入切面逻辑。这一过程发生在 Spring 容器的后处理器（BeanPostProcessor）阶段。&lt;/p&gt;

&lt;h3 id=&quot;说说-jdk-动态代理和-cglib-代理&quot;&gt;说说 JDK 动态代理和 CGLIB 代理？&lt;/h3&gt;

&lt;p&gt;AOP 是通过&lt;a href=&quot;https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg&quot;&gt;动态代理&lt;/a&gt;实现的，代理方式有两种：JDK 动态代理和 CGLIB 代理。&lt;/p&gt;

&lt;p&gt;①、JDK 动态代理是基于接口的代理，只能代理实现了接口的类。&lt;/p&gt;

&lt;p&gt;使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：只需依赖 JDK 自带的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类，不需要额外的库；缺点：只能代理接口，不能代理类本身。&lt;/p&gt;

&lt;p&gt;②、CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。&lt;/p&gt;

&lt;p&gt;使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：可以代理没有实现接口的类，灵活性更高；缺点：需要依赖 CGLIB 库，创建代理对象的开销相对较大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;只能代理实现了接口的类。它的实现基于 Java 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InvocationHandler&lt;/code&gt; 接口，&lt;strong&gt;运行时在内存中动态生成代理类的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 文件并加载执行&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;JDK Proxy 是通过在内存中动态创建一个实现了同样接口的代理类来“代理”目标对象的方法调用。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;比较维度&lt;/th&gt;
      &lt;th&gt;JDK 动态代理&lt;/th&gt;
      &lt;th&gt;CGLIB 动态代理&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;代理对象&lt;/td&gt;
      &lt;td&gt;必须实现接口&lt;/td&gt;
      &lt;td&gt;不需要接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;实现方式&lt;/td&gt;
      &lt;td&gt;JDK Proxy + 反射&lt;/td&gt;
      &lt;td&gt;继承 + 字节码增强&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;性能（早期）&lt;/td&gt;
      &lt;td&gt;较低&lt;/td&gt;
      &lt;td&gt;较高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;限制&lt;/td&gt;
      &lt;td&gt;不能代理类本身&lt;/td&gt;
      &lt;td&gt;不能代理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 类/方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Spring 默认策略&lt;/td&gt;
      &lt;td&gt;有接口：JDK 动态代理无接口：CGLIB&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;选择-cglib-还是-jdk-动态代理&quot;&gt;选择 CGLIB 还是 JDK 动态代理？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果目标对象没有实现任何接口，则只能使用 CGLIB 代理。如果目标对象实现了接口，通常首选 JDK 动态代理。&lt;/li&gt;
  &lt;li&gt;虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能。对于性能敏感且代理对象创建频率不高的场景，可以考虑使用 CGLIB。&lt;/li&gt;
  &lt;li&gt;JDK 动态代理是 Java 原生支持的，不需要额外引入库。而 CGLIB 需要将 CGLIB 库作为依赖加入项目中。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring AOP</summary></entry><entry><title type="html">Spring IoC</title><link href="https://mafulong.github.io/2025/05/06/Spring-IoC/" rel="alternate" type="text/html" title="Spring IoC" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20IoC</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-IoC/">&lt;h2 id=&quot;sprint-ioc&quot;&gt;Sprint IoC&lt;/h2&gt;

&lt;h3 id=&quot;谈谈自己对于-spring-ioc-的了解&quot;&gt;谈谈自己对于 Spring IoC 的了解&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IoC（Inversion of Control:控制反转）&lt;/strong&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么叫控制反转？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;控制&lt;/strong&gt;：指的是对象创建（实例化、管理）的权力&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;反转&lt;/strong&gt;：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;

&lt;p&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;

&lt;p&gt;IOC 是一种思想，&lt;strong&gt;DI&lt;/strong&gt; 是实现 IOC 的具体方式，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。&lt;/p&gt;

&lt;h3 id=&quot;将一个类声明为-bean-的注解有哪些&quot;&gt;将一个类声明为 Bean 的注解有哪些?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;：通用的注解，可标注任意类为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 组件。如果一个 Bean 不知道属于哪个层，可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解标注。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Repository&lt;/code&gt; : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service&lt;/code&gt; : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt; : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 层返回数据给前端页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;component-和-bean-的区别是什么&quot;&gt;@Component 和 @Bean 的区别是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注入-bean-的注解有哪些&quot;&gt;注入 Bean 的注解有哪些？&lt;/h3&gt;

&lt;p&gt;Spring 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 以及 JDK 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Annotation&lt;/th&gt;
      &lt;th&gt;Package&lt;/th&gt;
      &lt;th&gt;Source&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;org.springframework.bean.factory&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Spring 2.5+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.annotation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-250&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-330&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;使用的比较多一些。&lt;/p&gt;

&lt;p&gt;推荐构造函数注入。&lt;/p&gt;

&lt;h3 id=&quot;autowired-和-resource-的区别是什么&quot;&gt;@Autowired 和 @Resource 的区别是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;
  &lt;li&gt;当一个接口存在多个实现类的情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;都需要通过名称才能正确匹配到对应的 Bean。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Qualifier&lt;/code&gt; 注解来显式指定名称，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 属性来显式指定名称。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 支持在构造函数、方法、字段和参数上使用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注入-bean-的方式有哪些&quot;&gt;注入 Bean 的方式有哪些？&lt;/h3&gt;

&lt;p&gt;依赖注入 (Dependency Injection, DI) 的常见方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造函数注入：通过类的构造函数来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Setter 注入：通过类的 Setter 方法来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Field（字段） 注入：直接在类的字段上使用注解（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;）来注入依赖项。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Spring 官方推荐构造函数注入&lt;/strong&gt;，这种注入方式的优势如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。&lt;/li&gt;
  &lt;li&gt;不可变性：有助于创建不可变对象，提高了线程安全性。&lt;/li&gt;
  &lt;li&gt;初始化保证：组件在使用前已完全初始化，减少了潜在的错误。&lt;/li&gt;
  &lt;li&gt;测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;构造函数注入适合处理&lt;strong&gt;必需的依赖项&lt;/strong&gt;，而 &lt;strong&gt;Setter 注入&lt;/strong&gt; 则更适合&lt;strong&gt;可选的依赖项&lt;/strong&gt;，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。&lt;/p&gt;

&lt;p&gt;在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是&lt;strong&gt;唯一的选择&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;bean-的作用域有哪些&quot;&gt;Bean 的作用域有哪些?&lt;/h3&gt;

&lt;p&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;singleton&lt;/strong&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean()&lt;/code&gt; 两次，得到的是不同的 Bean 实例。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;request&lt;/strong&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;session&lt;/strong&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;application/global-session&lt;/strong&gt; （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;websocket&lt;/strong&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bean-的生命周期了解么&quot;&gt;Bean 的生命周期了解么?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;创建 Bean 的实例&lt;/strong&gt;：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bean 属性赋值/填充&lt;/strong&gt;：为 Bean 设置相关属性和依赖，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 等注解注入的对象、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Value&lt;/code&gt; 注入的值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法或构造函数注入依赖和值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;注入的各种资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bean 初始化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。
     - 如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;与上面的类似，如果实现了其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterPropertiesSet()&lt;/code&gt;方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 属性，执行指定的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessAfterInitialization()&lt;/code&gt; 方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;销毁 Bean&lt;/p&gt;

    &lt;p&gt;：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 接口，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy()&lt;/code&gt; 方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy-method&lt;/code&gt; 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PreDestroy&lt;/code&gt; 注解标记 Bean 销毁之前执行的方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bean 的生命周期大致分为五个阶段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062341884.png&quot; alt=&quot;三分恶面渣逆袭：Bean生命周期五个阶段&quot; /&gt;三分恶面渣逆袭：Bean生命周期五个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;实例化&lt;/strong&gt;：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;属性赋值&lt;/strong&gt;：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为依赖注入，确保 Bean 所需的所有依赖都被注入。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用中&lt;/strong&gt;：Bean 准备好可以使用了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;销毁&lt;/strong&gt;：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何记忆呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整体上可以简单分为四步：实例化 —&amp;gt; 属性赋值 —&amp;gt; 初始化 —&amp;gt; 销毁。&lt;/li&gt;
  &lt;li&gt;初始化这一步涉及到的步骤比较多，包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aware&lt;/code&gt; 接口的依赖注入、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 在初始化前后的处理以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 的初始化操作。&lt;/li&gt;
  &lt;li&gt;销毁这一步会注册相关销毁回调接口，最后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destory-method&lt;/code&gt; 进行销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再分享一张清晰的图解（图源：&lt;a href=&quot;https://chaycao.github.io/2020/02/15/如何记忆Spring-Bean的生命周期.html&quot;&gt;如何记忆 Spring Bean 的生命周期&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062339187.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-中的单例-bean-会存在线程安全问题吗&quot;&gt;Spring 中的单例 Bean 会存在线程安全问题吗？&lt;/h3&gt;

&lt;p&gt;Spring Bean 的默认作用域是单例（Singleton），这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会被多个线程共享。&lt;/p&gt;

&lt;p&gt;如果单例 Bean 是无状态的，也就是没有成员变量，那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，基本上都是无状态的。&lt;/p&gt;

&lt;p&gt;但如果 Bean 的内部状态是可变的，且没有进行适当的同步处理，就可能出现线程安全问题。&lt;/p&gt;

&lt;p&gt;对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;避免可变成员变量&lt;/strong&gt;: 尽量设计 Bean 为无状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;&lt;/strong&gt;: 将可变成员变量保存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 中，确保线程独立。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用同步机制&lt;/strong&gt;: 利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 来进行同步控制，确保线程安全。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Sprint IoC</summary></entry><entry><title type="html">Spring 循环依赖</title><link href="https://mafulong.github.io/2025/05/06/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="alternate" type="text/html" title="Spring 循环依赖" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">&lt;h2 id=&quot;spring-循环依赖&quot;&gt;Spring 循环依赖&lt;/h2&gt;

&lt;h2 id=&quot;循环依赖&quot;&gt;循环依赖&lt;/h2&gt;

&lt;p&gt;多个bean。A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃。。。。&lt;/p&gt;

&lt;p&gt;循环依赖只发生在 Singleton 作用域的 Bean 之间，因为如果是 Prototype 作用域的 Bean，Spring 会直接抛出异常。&lt;/p&gt;

&lt;h2 id=&quot;spring-可以解决哪些情况的循环依赖&quot;&gt;Spring 可以解决哪些情况的循环依赖？&lt;/h2&gt;

&lt;p&gt;看看这几种情形（AB 循环依赖）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062344583.png&quot; alt=&quot;三分恶面渣逆袭：循环依赖的几种情形&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AB 均采用构造器注入，不支持&lt;/li&gt;
  &lt;li&gt;AB 均采用 setter 注入，支持&lt;/li&gt;
  &lt;li&gt;AB 均采用属性自动注入，支持&lt;/li&gt;
  &lt;li&gt;A 中注入的 B 为 setter 注入，B 中注入的 A 为构造器注入，支持&lt;/li&gt;
  &lt;li&gt;B 中注入的 A 为 setter 注入，A 中注入的 B 为构造器注入，不支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第四种可以，第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。&lt;/p&gt;

&lt;p&gt;简单总结下，当循环依赖的实例都采用 setter 方法注入时，Spring 支持，都采用构造器注入的时候，不支持；构造器注入和 setter 注入同时存在的时候，看天&lt;/p&gt;

&lt;h2 id=&quot;spring-怎么解决循环依赖呢&quot;&gt;Spring 怎么解决循环依赖呢？&lt;/h2&gt;

&lt;p&gt;Spring 通过三级缓存机制来解决循环依赖：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一级缓存：存放完全初始化好的单例 Bean。&lt;/li&gt;
  &lt;li&gt;二级缓存：存放正在创建但未完全初始化的 Bean 实例。&lt;/li&gt;
  &lt;li&gt;三级缓存：存放 Bean 工厂对象，用于提前暴露 Bean。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062345571.png&quot; alt=&quot;三分恶面渣逆袭：三级缓存&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;三级缓存解决循环依赖的过程是什么样的&quot;&gt;三级缓存解决循环依赖的过程是什么样的？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;实例化 Bean 时，将其早期引用放入三级缓存。&lt;/li&gt;
  &lt;li&gt;其他依赖该 Bean 的对象，可以从缓存中获取其引用。&lt;/li&gt;
  &lt;li&gt;初始化完成后，将 Bean 移入一级缓存。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实就是三级缓存存了代理对象/原始对象的堆地址，初始化动作后移。 细节参考&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#_16-spring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%91%A2&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;为什么要三级缓存级不吗&quot;&gt;为什么要三级缓存？⼆级不⾏吗？&lt;/h3&gt;

&lt;p&gt;不行，主要是为了 &lt;strong&gt;⽣成代理对象&lt;/strong&gt;。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。&lt;/p&gt;

&lt;p&gt;因为三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。&lt;/p&gt;

&lt;p&gt;当涉及到 AOP 时，三级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。&lt;/p&gt;

&lt;p&gt;假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。&lt;/p&gt;

&lt;h4 id=&quot;如果缺少第二级缓存会有什么问题&quot;&gt;如果缺少第二级缓存会有什么问题？&lt;/h4&gt;

&lt;p&gt;如果没有二级缓存，Spring 无法在未完成初始化的情况下暴露 Bean。会导致代理 Bean 的循环依赖问题，因为某些代理逻辑无法在三级缓存中提前暴露。最终可能抛出 BeanCurrentlyInCreationException。&lt;/p&gt;

&lt;h2 id=&quot;lazy-能解决循环依赖吗&quot;&gt;@Lazy 能解决循环依赖吗？&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 用来标识类是否需要懒加载/延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。&lt;/p&gt;

&lt;p&gt;Spring Boot 2.2 新增了&lt;strong&gt;全局懒加载属性&lt;/strong&gt;，开启后全局 bean 被设置为懒加载，需要时再去创建。&lt;/p&gt;

&lt;p&gt;如非必要，尽量不要用全局懒加载。全局懒加载会让 Bean 第一次使用的时候加载会变慢，并且它会延迟应用程序问题的发现（当 Bean 被初始化时，问题才会出现）。&lt;/p&gt;

&lt;p&gt;如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lazy&lt;/code&gt; 解决循环依赖的关键点在于代理对象的使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;没有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 的情况下&lt;/strong&gt;：在 Spring 容器初始化 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 时会立即尝试创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;，而在创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的过程中又会尝试创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;，最终导致循环依赖（即无限递归，最终抛出异常）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 的情况下&lt;/strong&gt;：Spring 不会立即创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;，而是会注入一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的代理对象。由于此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 仍未被真正初始化，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 的初始化可以顺利完成。等到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 实例实际调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的方法时，代理对象才会触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的真正初始化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 能够在一定程度上打破循环依赖链，允许 Spring 容器顺利地完成 Bean 的创建和注入。但这并不是一个根本性的解决方案，尤其是在构造函数注入、复杂的多级依赖等场景中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 无法有效地解决问题。因此，最佳实践仍然是尽量避免设计上的循环依赖。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring 循环依赖</summary></entry><entry><title type="html">Spring基础</title><link href="https://mafulong.github.io/2025/05/06/Spring%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html" title="Spring基础" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring%E5%9F%BA%E7%A1%80/">&lt;h2 id=&quot;spring基础&quot;&gt;Spring基础&lt;/h2&gt;

&lt;p&gt;一句话概括：&lt;strong&gt;Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062328358.png&quot; alt=&quot;三分恶面渣逆袭：Spring特性&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;IoC&lt;/strong&gt; 和 &lt;strong&gt;DI&lt;/strong&gt; 的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现&lt;strong&gt;高内聚低耦合&lt;/strong&gt;的设计理念。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AOP 编程的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 提供了&lt;strong&gt;面向切面编程&lt;/strong&gt;，可以方便的实现对程序进行权限拦截、运行监控等切面功能。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;声明式事务的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;快捷测试的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 对 Junit 提供支持，可以通过&lt;strong&gt;注解&lt;/strong&gt;快捷地测试 Spring 程序。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;快速集成功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复杂 API 模板封装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。&lt;/p&gt;

&lt;h2 id=&quot;1-简单说一下什么是aop-和-ioc&quot;&gt;1. &lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#简单说一下什么是aop-和-ioc&quot;&gt;简单说一下什么是AOP 和 IoC？&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;AOP&lt;/strong&gt;：面向切面编程，是一种编程范式，它的主要作用是将那些与核心业务逻辑无关，但是对多个对象产生影响的公共行为封装起来，如日志记录、性能统计、事务等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC&lt;/strong&gt;：控制反转，是一种设计思想，它的主要作用是将对象的创建和对象之间的调用过程交给 Spring 容器来管理。&lt;/p&gt;

&lt;h2 id=&quot;2spring-有哪些模块呢&quot;&gt;2.Spring 有哪些模块呢？&lt;/h2&gt;

&lt;p&gt;Spring 框架是分模块存在，除了最核心的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring Core Container&lt;/code&gt;是必要模块之外，其他模块都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可选&lt;/code&gt;，大约有 20 多个模块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062329603.png&quot; alt=&quot;Spring模块划分&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最主要的七大模块：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Spring Core&lt;/strong&gt;：Spring 核心，它是框架最基础的部分，提供 IoC 和依赖注入 DI 特性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Context&lt;/strong&gt;：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Web&lt;/strong&gt;：它提供 Web 应用开发的支持。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt;：它针对 Web 应用中 MVC 思想的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring DAO&lt;/strong&gt;：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3spring-有哪些常用注解呢&quot;&gt;3.Spring 有哪些常用注解呢？&lt;/h2&gt;

&lt;p&gt;Spring 提供了大量的注解来简化 Java 应用的开发和配置，主要用于 Web 开发、往容器注入 Bean、AOP、事务控制等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062329372.png&quot; alt=&quot;三分恶面渣逆袭：Spring常用注解&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;web-开发方面有哪些注解呢&quot;&gt;Web 开发方面有哪些注解呢？&lt;/h4&gt;

&lt;p&gt;①、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt;：用于标注控制层组件。&lt;/p&gt;

&lt;p&gt;②、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RestController&lt;/code&gt;：是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ResponseBody&lt;/code&gt; 的结合体，返回 JSON 数据时使用。&lt;/p&gt;

&lt;p&gt;③、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestMapping&lt;/code&gt;：用于映射请求 URL 到具体的方法上，还可以细分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GetMapping&lt;/code&gt;：只能用于处理 GET 请求&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PostMapping&lt;/code&gt;：只能用于处理 POST 请求&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DeleteMapping&lt;/code&gt;：只能用于处理 DELETE 请求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;④、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ResponseBody&lt;/code&gt;：直接将返回的数据放入 HTTP 响应正文中，一般用于返回 JSON 数据。  &lt;strong&gt;把对象转json&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⑤、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestBody&lt;/code&gt;：表示一个方法参数应该绑定到 Web 请求体。&lt;strong&gt;json转对象，参数上。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⑥、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PathVariable&lt;/code&gt;：用于接收路径参数，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestMapping(“/hello/{name}”)&lt;/code&gt;，这里的 name 就是路径参数。&lt;/p&gt;

&lt;p&gt;⑦、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam&lt;/code&gt;：用于接收请求参数。比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam(name = &quot;key&quot;) String key&lt;/code&gt;，这里的 key 就是请求参数。&lt;/p&gt;

&lt;h4 id=&quot;容器类注解有哪些呢&quot;&gt;容器类注解有哪些呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;：标识一个类为 Spring 组件，使其能够被 Spring 容器自动扫描和管理。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service&lt;/code&gt;：标识一个业务逻辑组件（服务层）。比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service(&quot;userService&quot;)&lt;/code&gt;，这里的 userService 就是 Bean 的名称。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Repository&lt;/code&gt;：标识一个数据访问组件（持久层）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;：按类型自动注入依赖。 配合@Qualifier可以按name.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;：用于定义配置类，可替换 XML 配置文件。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Value&lt;/code&gt;：用于将 Spring Boot 中 application.properties 配置的属性值赋值给变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;aop-方面有哪些注解呢&quot;&gt;AOP 方面有哪些注解呢？&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Aspect&lt;/code&gt; 用于声明一个切面，可以配合其他注解一起使用，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@After&lt;/code&gt;：在方法执行之后执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Before&lt;/code&gt;：在方法执行之前执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Around&lt;/code&gt;：方法前后均执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PointCut&lt;/code&gt;：定义切点，指定需要拦截的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个方法上被多个 AOP 注解拦截时，&lt;strong&gt;默认执行顺序如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Around（前）
   └─ @Before
       └─ ——【目标方法执行】——
           └─ @After
@Around（后）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;事务注解有哪些&quot;&gt;事务注解有哪些？&lt;/h4&gt;

&lt;p&gt;主要就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt;，用于声明一个方法需要事务支持。&lt;/p&gt;

&lt;h2 id=&quot;springspring-mvcspring-boot-之间什么关系&quot;&gt;Spring,Spring MVC,Spring Boot 之间什么关系?&lt;/h2&gt;

&lt;p&gt;很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。&lt;/p&gt;

&lt;p&gt;Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。&lt;/p&gt;

&lt;p&gt;Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;

&lt;p&gt;使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！&lt;/p&gt;

&lt;p&gt;Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。&lt;/p&gt;

&lt;p&gt;Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！&lt;/p&gt;

&lt;h2 id=&quot;spring-框架中用到了哪些设计模式&quot;&gt;Spring 框架中用到了哪些设计模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于下面这些设计模式的详细介绍，可以看我写的 &lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html&quot;&gt;Spring 中的设计模式详解&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;工厂设计模式&lt;/strong&gt; : Spring 使用工厂模式通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;代理设计模式&lt;/strong&gt; : Spring AOP 功能的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;单例设计模式&lt;/strong&gt; : Spring 中的 Bean 默认都是单例的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt; : Spring 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jdbcTemplate&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hibernateTemplate&lt;/code&gt; 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;包装器设计模式&lt;/strong&gt; : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;观察者模式:&lt;/strong&gt; Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring基础</summary></entry><entry><title type="html">Java并发包和线程池</title><link href="https://mafulong.github.io/2025/05/04/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="alternate" type="text/html" title="Java并发包和线程池" /><published>2025-05-04T00:00:00+08:00</published><updated>2025-05-04T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/04/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0</id><content type="html" xml:base="https://mafulong.github.io/2025/05/04/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/">&lt;h2 id=&quot;java并发包和线程池&quot;&gt;Java并发包和线程池&lt;/h2&gt;

&lt;h2 id=&quot;jdk-并发包-juc&quot;&gt;JDK 并发包 JUC&lt;/h2&gt;

&lt;p&gt;java.util.concurrent&lt;/p&gt;

&lt;h3 id=&quot;重入锁-reentrantlock&quot;&gt;重入锁 ReentrantLock&lt;/h3&gt;

&lt;p&gt;几个重要方法
re-entrance-lock&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获得锁，如占用，则等待&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lockInteruptibly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获得锁，但优先响应中断，就是可以中断的&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//失败返回false,不等待&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//在给定时间内尝试获得锁&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//释放锁&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;newCondition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;不符合条件&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;signalAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Java 中，重入锁（Reentrant Lock）是一种支持&lt;strong&gt;同一线程重复获取锁而不会被阻塞&lt;/strong&gt;的锁机制。它的实现可以分为两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一种是基于 JVM 的内置锁（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;）；&lt;/li&gt;
  &lt;li&gt;一种是基于 JUC 包的显示锁（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;synchronized 的重入原理（基于 JVM 实现）&lt;/strong&gt; &lt;strong&gt;非公平锁&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 是基于&lt;strong&gt;对象头（Object Monitor）&lt;/strong&gt;的 Monitor Lock 实现的。&lt;/li&gt;
  &lt;li&gt;每个对象都有一个 Monitor，如果一个线程已经获取了该 Monitor，再次进入时会&lt;strong&gt;增加一个计数器&lt;/strong&gt;（称为重入计数）。&lt;/li&gt;
  &lt;li&gt;只有当线程完全退出所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 块后，才会真正释放这个锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;📌 &lt;strong&gt;JVM 中的重入机制依赖于 Monitor 的 Owner 和计数器：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;记录当前持锁线程（Owner）。&lt;/li&gt;
  &lt;li&gt;如果当前线程再次请求锁，只需将计数器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+1&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;退出时递减计数器，直到为 0 时释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ReentrantLock 的重入原理（基于 AQS 实现）&lt;/strong&gt;  &lt;strong&gt;公平锁&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 是基于 &lt;strong&gt;AbstractQueuedSynchronizer（AQS）&lt;/strong&gt; 实现的。&lt;/li&gt;
  &lt;li&gt;AQS 使用一个 volatile 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; 字段记录加锁次数，支持可重入。&lt;/li&gt;
  &lt;li&gt;线程第一次获得锁时：
    &lt;ul&gt;
      &lt;li&gt;设置 state = 1，并记录当前线程为 owner。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果 owner 线程再次请求：
    &lt;ul&gt;
      &lt;li&gt;检查线程是否为当前 owner，如果是就直接 state++。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;释放锁时：
    &lt;ul&gt;
      &lt;li&gt;每释放一次 state–；&lt;/li&gt;
      &lt;li&gt;当 state 为 0 时才真正释放锁并唤醒等待线程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;重入锁的好搭档condition-条件&quot;&gt;重入锁的好搭档：Condition 条件&lt;/h3&gt;

&lt;p&gt;condition.await()和 wait()类似&lt;/p&gt;

&lt;p&gt;condition.signal()和 notify()类似&lt;/p&gt;

&lt;p&gt;要在 lock 块内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;condition可以有多个，每个condition.await阻塞只能通过该condition的signal/signalall来唤醒！这是synchronized关键字所达不到的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意如果signal在await之前，可能会通知丢失，变成死锁，随意最好用状态变量来循环解决。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Condition&lt;/code&gt; 的实现基于 &lt;strong&gt;AQS&lt;/strong&gt;，也就是 &lt;strong&gt;AbstractQueuedSynchronizer&lt;/strong&gt;。它背后的核心原理是通过 &lt;strong&gt;等待队列&lt;/strong&gt; 和 &lt;strong&gt;通知机制&lt;/strong&gt; 来协调线程的执行。 线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await()&lt;/code&gt; 方法时，&lt;strong&gt;当前线程会被挂起并加入到 AQS 的队列中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;唤醒是通过 &lt;strong&gt;设置线程的状态&lt;/strong&gt; 来实现的。AQS 会通过 &lt;strong&gt;CAS 操作&lt;/strong&gt; 原子地改变线程的状态，保证线程安全。&lt;/p&gt;

&lt;h3 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h3&gt;

&lt;p&gt;信号量机制&lt;/p&gt;

&lt;p&gt;允许多个线程同时访问&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;permits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//permits是个许可证&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SemaphoreExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clientCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalRequestCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clientCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalRequestCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()-&amp;gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;availablePermits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resutl:
2 1 2 2 2 2 2 1 2 2&lt;/p&gt;

&lt;p&gt;循环打印ABC.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ABCPrinter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 创建三个信号量，用于控制线程的执行顺序&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphoreA&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphoreB&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphoreC&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printA&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nv&quot;&gt;semaphoreA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 等待A的信号&lt;/span&gt;
                    &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;nv&quot;&gt;semaphoreB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 释放B的信号&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;。。。&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt; 的实现基于 &lt;strong&gt;AQS（AbstractQueuedSynchronizer）&lt;/strong&gt;，通过维护一个计数器来控制并发线程数。每当线程请求资源时，计数器减少，当计数器为 0 时，后续线程会被挂起。通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release()&lt;/code&gt; 方法可以释放资源并增加计数器的值，唤醒等待的线程。&lt;/p&gt;

&lt;h3 id=&quot;reentrantreadwritelock&quot;&gt;ReentrantReadWriteLock&lt;/h3&gt;

&lt;p&gt;读写分离锁，可以减少锁竞争，提升性能&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantReadWriteLock&lt;/code&gt; 内部通过一个 &lt;strong&gt;state&lt;/strong&gt; 字段来表示锁的状态。这个状态由 &lt;strong&gt;高 16 位&lt;/strong&gt; 和 &lt;strong&gt;低 16 位&lt;/strong&gt; 两部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;高 16 位&lt;/strong&gt;：表示写锁的数量。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;低 16 位&lt;/strong&gt;：表示读锁的数量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantReadWriteLock&lt;/code&gt; 是其常见的实现，它使用 &lt;strong&gt;AQS（AbstractQueuedSynchronizer）&lt;/strong&gt; 来协调线程间的并发访问。读锁是共享锁，多个线程可以同时持有；写锁是独占锁，只有一个线程能持有写锁，且在写锁持有期间，不允许任何线程读取或写入资源。&lt;/p&gt;

&lt;h4 id=&quot;stampedlock&quot;&gt;StampedLock&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StampedLock&lt;/code&gt; 是 Java 8 中引入的一个新型锁，提供比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantReadWriteLock&lt;/code&gt; 更高效的并发控制机制，尤其适用于需要大量读操作的场景。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StampedLock&lt;/code&gt; 也通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 的机制来实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;写锁&lt;/strong&gt;：独占锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;悲观读锁&lt;/strong&gt;：类似于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantReadWriteLock&lt;/code&gt; 的读锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;乐观读锁&lt;/strong&gt;：允许在不持有锁的情况下读取数据，在提交之前检查数据是否被修改过。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;countdownlatch&quot;&gt;CountdownLatch&lt;/h3&gt;

&lt;p&gt;就是倒计数的锁存期，可以让线程等待直到倒计时结束，再开始执行&lt;/p&gt;

&lt;p&gt;用来控制一个线程等待多个线程。&lt;/p&gt;

&lt;p&gt;维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt; 的底层通过 AQS 实现，使用一个 volatile 的 state 变量表示倒计时，线程通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await()&lt;/code&gt; 进入 AQS 的 CLH 双向等待队列阻塞。
 每个调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;countDown()&lt;/code&gt; 的线程原子性地将 state 减一，当 state 变为 0 时，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;releaseShared()&lt;/code&gt; 唤醒所有等待线程。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountdownLatchExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countDownLatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;run..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;countDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;countDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;countDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;end&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;result:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;run..run..run..run..run..run..run..run..run..run..end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cyclicbarrier&quot;&gt;CyclicBarrier&lt;/h3&gt;

&lt;p&gt;允许一组线程互相等待，直到都到达某个公共屏障点&lt;/p&gt;

&lt;p&gt;用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p&gt;

&lt;p&gt;和 CountdownLatch 相似，都是通过维护计数器来实现的。但是它的计数器是递增的，每次执行 await() 方法之后，计数器会加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。和 CountdownLatch 的另一个区别是，CyclicBarrier 的计数器可以循环使用，所以它才叫做循环屏障。&lt;/p&gt;

&lt;p&gt;这个是规定多少个线程，这一定数量的线程都到达 await()时才开始都唤醒，继续执行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt; 内部通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Condition&lt;/code&gt; 控制线程的阻塞与唤醒，每次有线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await()&lt;/code&gt;，都会将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 减 1，当最后一个线程到达时执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;barrierAction&lt;/code&gt;（如果有），然后唤醒所有线程；为了支持多轮使用，它通过一个叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generation&lt;/code&gt; 的对象标记每一轮屏障；其设计体现了经典的“屏障”同步模式，非常适用于多线程并发阶段任务。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CyclicBarrierExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;CyclicBarrier&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cyclicBarrier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CyclicBarrier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;cyclicBarrier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BrokenBarrierException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;result:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;exchanger&quot;&gt;Exchanger&lt;/h3&gt;

&lt;p&gt;用于两个线程之间数据的同步交换，都准备好才交换&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exchanger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exchanger&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exchanger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// Thread 1: Producer&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello from producer!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Producer before exchange: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exchanger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;exchange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 交换数据&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Producer after exchange: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Thread 2: Consumer&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello from consumer!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Consumer before exchange: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exchanger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;exchange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 交换数据&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Consumer after exchange: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt; 底层的核心结构是一个 &lt;strong&gt;双向链表&lt;/strong&gt; 或 &lt;strong&gt;节点（Node）&lt;/strong&gt;。每当一个线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 方法时，它会创建一个节点并将自己插入链表中，表示它正等待交换数据。另一线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 时，也会创建一个节点，等待与第一个线程交换数据。&lt;/p&gt;

&lt;p&gt;一旦两个线程都准备好交换数据，它们会在这个链表中交换各自的数据。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transferer&lt;/code&gt;&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt; 内部使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transferer&lt;/code&gt; 接口的实现类来管理线程间的交换。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transferer&lt;/code&gt; 实际上是用来实现数据交换的接口，它有多个实现类，用于不同的同步需求。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Item&lt;/code&gt;&lt;/strong&gt;: 用来存放线程交换的数据的对象。在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt; 内部，线程会持有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Item&lt;/code&gt;，每个线程传入的数据都会存储在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Item&lt;/code&gt; 中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 是一个双向链表的节点。每当一个线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 时，线程就会在内部的双向链表中创建一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 来等待交换。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;锁与条件变量&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt;：用于确保对共享资源的互斥访问。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Condition&lt;/code&gt;：用于实现线程的等待与通知机制。每个线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 调用时都会被放入一个等待队列中，直到与另一个线程交换数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;核心流程&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 时，它会创建一个节点并加入到交换的队列中。节点保存了当前线程的数据，并等待另一个线程来交换数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程 A 调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt;，并将其数据存储在节点中，等待与线程 B 交换数据。&lt;/li&gt;
  &lt;li&gt;线程 B 调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt;，并将其数据存储在节点中，等待与线程 A 交换数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;线程阻塞与等待&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;当线程 A 调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exchange()&lt;/code&gt; 后，它会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock.lock()&lt;/code&gt; 获取锁，然后检查是否有另一个线程已经在等待交换。&lt;/li&gt;
  &lt;li&gt;如果线程 B 也已经在等待，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt; 会交换它们的数据。&lt;/li&gt;
  &lt;li&gt;如果线程 A 没有找到线程 B 来交换数据，它会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition.await()&lt;/code&gt; 阻塞自己，直到线程 B 准备好交换数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;线程交换数据&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;一旦线程 A 和线程 B 都准备好了交换数据，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt; 会将它们各自的数据交换。线程 A 会从线程 B 获取数据，而线程 B 会从线程 A 获取数据。&lt;/li&gt;
  &lt;li&gt;交换完成后，线程会被通知继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;通知与继续执行&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;交换完成后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt; 会使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition.signalAll()&lt;/code&gt; 来通知所有等待的线程，让它们继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;Semaphore synchronized CountDownLatch 不依赖于重入锁。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FutureTask&lt;/code&gt;：不是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt;，而是 AQS 实现&lt;/p&gt;

&lt;p&gt;其他JUC基本依赖于重入锁。&lt;/p&gt;

&lt;h2 id=&quot;并发数据结构&quot;&gt;并发数据结构&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类名&lt;/th&gt;
      &lt;th&gt;数据结构&lt;/th&gt;
      &lt;th&gt;同步机制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;数组 + 链表/红黑树 + 分段锁/CAS&lt;/td&gt;
      &lt;td&gt;分段锁（JDK7），CAS + synchronized（JDK8）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳表（SkipList）&lt;/td&gt;
      &lt;td&gt;CAS + volatile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentLinkedQueue&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;链表&lt;/td&gt;
      &lt;td&gt;CAS（无锁）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentLinkedDeque&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;双向链表&lt;/td&gt;
      &lt;td&gt;CAS（无锁）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedBlockingQueue&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;链表&lt;/td&gt;
      &lt;td&gt;ReentrantLock（put/take 两把锁）长度不可为0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayBlockingQueue&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;数组环形缓冲区&lt;/td&gt;
      &lt;td&gt;ReentrantLock（put/take 两把锁） 是有界的，初始化需要提供数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PriorityBlockingQueue&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;最小堆&lt;/td&gt;
      &lt;td&gt;ReentrantLock&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DelayQueue&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;最小堆（内部是 PriorityQueue）&lt;/td&gt;
      &lt;td&gt;ReentrantLock&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;无缓冲/虚拟队列&lt;/td&gt;
      &lt;td&gt;CAS + Lock（公平时）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedTransferQueue&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;链表 + 匹配节点&lt;/td&gt;
      &lt;td&gt;CAS + 自旋&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;数组&lt;/td&gt;
      &lt;td&gt;写时复制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArraySet&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;写时复制&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linkedblockingqueue&quot;&gt;LinkedBlockingQueue&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedBlockingQueue&lt;/code&gt; 是基于 &lt;strong&gt;链表&lt;/strong&gt; 实现的，并通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt;&lt;/strong&gt; 进行同步管理。它使用两把锁：一把用于生产者线程（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 操作），一把用于消费者线程（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 操作）。这样设计保证了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 操作可以并发执行，提高了吞吐量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt;：链表的头部和尾部节点。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;：队列中的当前元素数量。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putLock&lt;/code&gt;：用于控制 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 操作的锁。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeLock&lt;/code&gt;：用于控制 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 操作的锁。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notFull&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notEmpty&lt;/code&gt;：分别控制当队列满时生产者线程的等待和当队列空时消费者线程的等待。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReentrantLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putLock&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;putLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;putLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lockInterruptibly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 当队列满时&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;notFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 等待队列有空间&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// 插入队列&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 唤醒等待的消费者&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;putLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;双锁机制（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putLock&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeLock&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putLock&lt;/code&gt;&lt;/strong&gt;：控制 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 操作，保证在插入时不会与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 操作冲突。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeLock&lt;/code&gt;&lt;/strong&gt;：控制 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 操作，保证在移除时不会与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 操作冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;条件变量（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notFull&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notEmpty&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notFull&lt;/code&gt;&lt;/strong&gt;：当队列满时，生产者线程会阻塞在该条件变量上，直到队列有空间。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notEmpty&lt;/code&gt;&lt;/strong&gt;：当队列为空时，消费者线程会阻塞在该条件变量上，直到队列有元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;synchronousqueue&quot;&gt;SynchronousQueue&lt;/h3&gt;

&lt;h4 id=&quot;底层数据结构&quot;&gt;底层数据结构&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; 的底层实现并不是传统意义上的基于 &lt;strong&gt;数组&lt;/strong&gt; 或 &lt;strong&gt;链表&lt;/strong&gt; 的数据结构，而是通过 &lt;strong&gt;双向链表&lt;/strong&gt; 和 &lt;strong&gt;阻塞队列&lt;/strong&gt; 的机制来实现元素的交换。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点（Node）&lt;/strong&gt;：
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; 中维护了两个节点：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个用于等待生产者线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 数据的节点。&lt;/li&gt;
      &lt;li&gt;一个用于等待消费者线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 数据的节点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同步双向链表&lt;/strong&gt;：
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; 内部维护一个双向链表，这个链表只有两个节点：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个节点是生产者线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 操作时等待的数据。&lt;/li&gt;
      &lt;li&gt;另一个节点是消费者线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 操作时等待的数据。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;双向链表的作用是帮助管理等待的线程。生产者和消费者线程的交换就是通过这两个节点来实现的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;锁与条件变量&lt;/strong&gt;：
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; 使用了 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Condition&lt;/code&gt;&lt;/strong&gt; 来实现线程同步和等待。生产者线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 数据时会持有锁并等待，如果没有消费者线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 数据，生产者线程会阻塞。消费者线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 数据时也会持有锁并等待，如果没有生产者线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 数据，消费者线程会阻塞。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;核心方法&quot;&gt;核心方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put(E e)&lt;/code&gt;&lt;/strong&gt;：当生产者调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 方法时，它会尝试将数据放入队列。由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; 是一个不存储元素的队列，生产者线程必须等待消费者线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 来取走这个数据。如果消费者线程没有取走数据，生产者线程会被阻塞。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take()&lt;/code&gt;&lt;/strong&gt;：消费者线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt; 方法时，它会等待生产者线程将数据放入队列。如果生产者线程没有放入数据，消费者线程会被阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nc&quot;&gt;SynchronousQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SynchronousQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;delayqueue&quot;&gt;DelayQueue&lt;/h3&gt;

&lt;p&gt;DelayQueue一般用于生产者消费者模式。&lt;/p&gt;

&lt;p&gt;它不是定时任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take()&lt;/code&gt;&lt;/strong&gt;：阻塞地获取队列中的元素。如果队列为空，或者所有元素都尚未到期，调用线程会被阻塞直到有元素可用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DelayQueue&lt;/code&gt; 的核心是基于 &lt;strong&gt;优先级队列&lt;/strong&gt; 来进行元素排序，具体来说，它是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PriorityBlockingQueue&lt;/code&gt; 来实现的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PriorityBlockingQueue&lt;/code&gt; 是一个没有容量限制的阻塞队列，能够根据元素的延迟时间来对元素进行排序。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;阻塞机制&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt; 方法会检查队列头部的元素的延迟时间。如果延迟时间未到，调用线程会被阻塞直到延迟时间到期。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线程阻塞与唤醒&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DelayQueue&lt;/code&gt; 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AQS&lt;/code&gt;（AbstractQueuedSynchronizer）来管理阻塞线程。当队列中的元素到期时，它会唤醒等待的线程，使得这些线程可以继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;aqs原理&quot;&gt;AQS原理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;AQS（AbstractQueuedSynchronizer）的原理。它是 Java 并发框架中用于构建锁和同步器的一个核心框架类，比如 ReentrantLock、Semaphore、CountDownLatch 等同步器，底层都是基于 AQS 实现的。是 Java 并发包 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent.locks&lt;/code&gt; 中用来构建锁和其他同步器（如信号量、读写锁、倒计时器等）的一个&lt;strong&gt;基础框架类&lt;/strong&gt;。它是 J.U.C 并发框架中最核心的底层组件之一。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AQS 通过一个&lt;strong&gt;FIFO 队列&lt;/strong&gt;（先进先出等待队列）来&lt;strong&gt;管理获取锁失败的线程&lt;/strong&gt;，并通过一个&lt;strong&gt;原子变量 state&lt;/strong&gt; 来&lt;strong&gt;表示同步状态&lt;/strong&gt;，从而实现各种自定义同步器。&lt;/p&gt;

&lt;h3 id=&quot;aqs-与-synchronized-有何不同&quot;&gt;AQS 与 synchronized 有何不同？&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;synchronized&lt;/th&gt;
      &lt;th&gt;AQS（如 ReentrantLock）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;可中断&lt;/td&gt;
      &lt;td&gt;❌ 不支持&lt;/td&gt;
      &lt;td&gt;✅ 支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可重入&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;公平性选择&lt;/td&gt;
      &lt;td&gt;❌ 不可选&lt;/td&gt;
      &lt;td&gt;✅ 只有支持公平模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;条件变量支持&lt;/td&gt;
      &lt;td&gt;❌&lt;/td&gt;
      &lt;td&gt;✅ Condition 支持更强大&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;性能控制&lt;/td&gt;
      &lt;td&gt;❌（黑盒）&lt;/td&gt;
      &lt;td&gt;✅ 更可控&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果想要非FIFO，请用synchronized, 比如重入锁非公平模式。&lt;/p&gt;

&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;

&lt;h4 id=&quot;-1-核心思想状态--队列&quot;&gt;🌟 1. 核心思想：状态 + 队列&lt;/h4&gt;

&lt;p&gt;AQS 的核心是两个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;：一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile int state&lt;/code&gt; 表示当前的同步状态，比如 0 表示未加锁，1 表示已加锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;等待队列（CLH 队列）&lt;/strong&gt;：线程获取锁失败后，会被封装为一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 节点，加入到一个 &lt;strong&gt;FIFO 双向队列&lt;/strong&gt; 中，并通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LockSupport.park()&lt;/code&gt; 挂起。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字段名&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile int&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;同步状态（0 代表未占用）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;CLH 队列的头尾指针&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;静态内部类&lt;/td&gt;
      &lt;td&gt;每个等待线程一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waitStatus&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
      &lt;td&gt;节点状态（SIGNAL、CANCELLED 等）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Thread&lt;/td&gt;
      &lt;td&gt;对应线程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prev&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Node&lt;/td&gt;
      &lt;td&gt;指向前后节点，实现双向链表&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;-2-获取锁流程以独占为例&quot;&gt;🔁 2. 获取锁流程（以独占为例）：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire()&lt;/code&gt; 尝试加锁，底层会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquire()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquire()&lt;/code&gt; 失败，就进入等待队列，并阻塞当前线程。&lt;/li&gt;
  &lt;li&gt;前一个线程释放锁时调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release()&lt;/code&gt;，底层调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryRelease()&lt;/code&gt; 成功后唤醒下一个线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-3-aqs-提供模板方法子类负责实现&quot;&gt;🧱 3. AQS 提供模板方法，子类负责实现：&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
protected boolean tryAcquire(int arg);
protected boolean tryRelease(int arg);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;开发者通过继承 AQS 并实现这些方法，可以自定义同步器的行为。&lt;/p&gt;

&lt;h4 id=&quot;-4-支持两种模式&quot;&gt;📌 4. 支持两种模式：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;独占模式（Exclusive）&lt;/strong&gt;：一次只允许一个线程获取资源，如 ReentrantLock。&lt;strong&gt;tryAcquire&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享模式（Shared）&lt;/strong&gt;：多个线程可以共享资源，如 Semaphore、CountDownLatch。&lt;strong&gt;tryAcquireShared&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tryAcquireShared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;↓&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;获取失败&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addWaiter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;enq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;park&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;↓&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;前驱释放锁&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unpark&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;自旋重试&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;获取成功&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-5-实际应用举例&quot;&gt;📚 5. 实际应用举例：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;ReentrantLock：基于 AQS 的独占模式。&lt;/li&gt;
  &lt;li&gt;Semaphore：基于共享模式控制并发数量。&lt;/li&gt;
  &lt;li&gt;CountDownLatch：通过共享计数控制线程等待。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;子类&lt;/th&gt;
      &lt;th&gt;模式&lt;/th&gt;
      &lt;th&gt;实现方法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;独占&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquire&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryRelease&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;共享&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquireShared&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryReleaseShared&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;共享&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquireShared&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryReleaseShared&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantReadWriteLock.WriteLock&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;独占&lt;/td&gt;
      &lt;td&gt;见写锁实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantReadWriteLock.ReadLock&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;共享&lt;/td&gt;
      &lt;td&gt;见读锁实现&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ReentrantReadWriteLock  读共享，写独占&lt;/p&gt;

&lt;h3 id=&quot;qa&quot;&gt;QA&lt;/h3&gt;

&lt;p&gt;为什么要使用 LockSupport.park() 而不是 wait()？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;park/unpark&lt;/code&gt; 更灵活，线程不需要先获取锁。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait/notify&lt;/code&gt; 依赖对象锁，容易产生死锁或复杂同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CLH（Craig, Landin, and Hagersten）队列&lt;/strong&gt; 是核心的数据结构之一。它是一种用于实现 &lt;strong&gt;自旋锁 / 阻塞锁的并发队列&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个线程都对应一个节点（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;）挂到队列尾部。&lt;/li&gt;
  &lt;li&gt;线程通过自旋或挂起等待其前驱节点的状态变化。&lt;/li&gt;
  &lt;li&gt;在 AQS 中称为 &lt;strong&gt;“同步队列”（sync queue）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FIFO 保证公平性&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;非阻塞入队（CAS）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自旋/挂起等待前驱通知&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可扩展性强，适合高并发场景&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程池&quot;&gt;线程池&lt;/h2&gt;

&lt;p&gt;合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newFixedThreadPool(int nThreads)&lt;/code&gt;：创建固定大小的线程池。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newCachedThreadPool()&lt;/code&gt;：创建一个可缓存的线程池，线程池的大小可根据需求动态调整。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newSingleThreadExecutor()&lt;/code&gt;：创建一个单线程的线程池，所有任务按照提交顺序执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newScheduledThreadPool(int corePoolSize)&lt;/code&gt;：创建一个定时任务线程池，支持定时任务执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;c1&quot;&gt;// 创建一个固定大小的线程池，大小为 3&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadPool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 提交 6 个任务&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;threadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Task &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 关闭线程池&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;threadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程池任务创建与提交&quot;&gt;线程池任务创建与提交&lt;/h3&gt;

&lt;p&gt;任务分为两种:一种是有返回值的（ callable ），一种是没有返回值的（ runnable ）. Callable 与 Future 两功能是 Java 在后续版本中为了适应多并法才加入的，Callable 是类似于 Runnable 的接口，实现 Callable 接口的类和实现 Runnable 的类都是可被其他线程执行的任务。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无返回值的任务就是一个实现了 runnable 接口的类.使用 run 方法.&lt;/li&gt;
  &lt;li&gt;有返回值的任务是一个实现了 callable 接口的类.使用 call 方法.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Callable 和 Runnable 的区别如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Callable 定义的方法是 call，而 Runnable 定义的方法是 run。&lt;/li&gt;
  &lt;li&gt;Callable 的 call 方法可以有返回值，而 Runnable 的 run 方法不能有返回值。&lt;/li&gt;
  &lt;li&gt;Callable 的 call 方法可抛出异常，而 Runnable 的 run 方法不能抛出异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;execute 与 submit 区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收的参数不一样&lt;/li&gt;
  &lt;li&gt;submit 有返回值，而 execute 没有&lt;/li&gt;
  &lt;li&gt;submit 方便 Exception 处理&lt;/li&gt;
  &lt;li&gt;execute 是 Executor 接口中唯一定义的方法；submit 是 ExecutorService（该接口继承 Executor）中定义的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;线程池的关闭&quot;&gt;线程池的关闭&lt;/h3&gt;

&lt;p&gt;我们可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 &lt;strong&gt;interrupt&lt;/strong&gt; 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。&lt;/p&gt;

&lt;p&gt;只要调用了这两个关闭方法的其中一个，&lt;strong&gt;isShutdown&lt;/strong&gt; 方法就会返回 true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。&lt;/p&gt;

&lt;h3 id=&quot;线程池的分析&quot;&gt;线程池的分析&lt;/h3&gt;

&lt;p&gt;创建一个线程池需要输入几个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runnableTaskQueue&lt;/strong&gt;（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。&lt;/li&gt;
  &lt;li&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列。&lt;/li&gt;
  &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。&lt;/li&gt;
  &lt;li&gt;PriorityBlockingQueue：一个具有优先级得无限阻塞队列。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。也就是说 corePoolSize 就是线程池大小，maximumPoolSize 在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ThreadFactory&lt;/strong&gt;：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RejectedExecutionHandler&lt;/strong&gt;（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;AbortPolicy：直接抛出异常&lt;/li&gt;
  &lt;li&gt;CallerRunsPolicy：只用调用者所在线程来运行任务。&lt;/li&gt;
  &lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。&lt;/li&gt;
  &lt;li&gt;DiscardPolicy：不处理，丢弃掉。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。&lt;/li&gt;
  &lt;li&gt;TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505041121762.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前线程池中的线程数目小于 corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目&amp;gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目达到 maximumPoolSize，则会采取任务拒绝策略进行处理；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止&lt;/p&gt;

&lt;p&gt;从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;newFixedThreadPool&lt;/strong&gt; 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;newSingleThreadExecutor&lt;/strong&gt; 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;newCachedThreadPool&lt;/strong&gt; 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过 60 秒，就销毁线程。&lt;/p&gt;

&lt;p&gt;实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Java" /><category term="Java" /><summary type="html">Java并发包和线程池</summary></entry></feed>