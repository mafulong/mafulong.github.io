<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://mafulong.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mafulong.github.io/" rel="alternate" type="text/html" /><updated>2025-08-19T12:23:46+08:00</updated><id>https://mafulong.github.io/feed.xml</id><title type="html">Fulongのblog</title><subtitle>Fulongのblog</subtitle><author><name>Fulong Ma</name></author><entry><title type="html">win11游戏主机配置</title><link href="https://mafulong.github.io/2025/08/17/win11%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="win11游戏主机配置" /><published>2025-08-17T00:00:00+08:00</published><updated>2025-08-17T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/17/win11%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="https://mafulong.github.io/2025/08/17/win11%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/">&lt;h2 id=&quot;win11游戏主机配置&quot;&gt;win11游戏主机配置&lt;/h2&gt;

&lt;h2 id=&quot;电脑必装软件&quot;&gt;电脑必装软件&lt;/h2&gt;

&lt;h3 id=&quot;电脑配置&quot;&gt;电脑配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;：AMD R7 9800X3D —— ¥3299&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;主板&lt;/strong&gt;：技嘉 B850 大冰雕 WiFi d5 —— ¥1649&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;：阿斯加特女武神二代 24×2 48G DDR5 6000MHz C28 —— ¥1089&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;固态&lt;/strong&gt;：致钛 TiPlus 7100 4TB —— ¥1799&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显卡&lt;/strong&gt;：影驰 RTX 5080 金属大师白金 OC —— ¥9299&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;电源&lt;/strong&gt;：海韵 FOCUS GX 1000W ATX3.1 白金牌全模组 —— ¥1249&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU散热&lt;/strong&gt;：瓦尔基里 B360GT —— ¥549&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;机箱&lt;/strong&gt;：爱国者 星璨大岚 —— ¥449&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;风扇&lt;/strong&gt;：棱镜 6Pro ×7 —— ¥140&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;驱动&quot;&gt;驱动&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;机箱下面有个屏显，没装&lt;/li&gt;
  &lt;li&gt;散热的屏显: myth.Cool 同时可以展示系统信息&lt;/li&gt;
  &lt;li&gt;NVIDIA app： 显卡驱动&lt;/li&gt;
  &lt;li&gt;GIBGABYTE control center: 技嘉主板软件，同时可以自动下电脑网卡等驱动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;软件&quot;&gt;软件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;clash. 花云上下载&lt;/li&gt;
  &lt;li&gt;ea app&lt;/li&gt;
  &lt;li&gt;steam app&lt;/li&gt;
  &lt;li&gt;uu加速器&lt;/li&gt;
  &lt;li&gt;epic games app&lt;/li&gt;
  &lt;li&gt;xbox app&lt;/li&gt;
  &lt;li&gt;xbox 配件 蓝牙连手柄用，否则只能有线连&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;游戏&quot;&gt;游戏&lt;/h2&gt;

&lt;h3 id=&quot;快捷键&quot;&gt;快捷键&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;cmd + G: 唤醒xbox游戏工具箱&lt;/li&gt;
  &lt;li&gt;option + cmd + b: 切换Hdr开关&lt;/li&gt;
  &lt;li&gt;option + z: 唤醒nvidia 游戏工具箱&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;电脑设置&quot;&gt;电脑设置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;调整游戏录制时长。 设置 -&amp;gt; 游戏 -&amp;gt; 摄像 -&amp;gt; 录制游戏过程 下拉箭头 -&amp;gt; 录制上次内容 时间30s 改成 5分钟&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;视频录制分享&quot;&gt;视频录制分享&lt;/h3&gt;

&lt;p&gt;cmd + G回放下载。 然后剪映 就可以发送到抖音&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">win11游戏主机配置</summary></entry><entry><title type="html">mac mini做nas+小米电视</title><link href="https://mafulong.github.io/2025/08/10/mac-mini%E5%81%9Anas+%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86/" rel="alternate" type="text/html" title="mac mini做nas+小米电视" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/10/mac%20mini%E5%81%9Anas+%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86</id><content type="html" xml:base="https://mafulong.github.io/2025/08/10/mac-mini%E5%81%9Anas+%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86/">&lt;h2 id=&quot;mac-mini做nas小米电视&quot;&gt;mac mini做nas+小米电视&lt;/h2&gt;

&lt;h2 id=&quot;nas&quot;&gt;nas&lt;/h2&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unless&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mafulong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Downloads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NAS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emby_config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8096&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;8096&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;linuxserver/emby&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;自己ip&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ipconfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getifaddr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;en1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;adb&quot;&gt;adb&lt;/h2&gt;

&lt;p&gt;adb可以远程connect&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;31.148&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;安装软件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TVBox_takagen99_20250706&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1456&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arm64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;apk&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;传输文件&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;但小米电视无法读adb的文件&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/Users/mafulong/Downloads/爱、死亡与机器人.Love.Death.and.Robots.S01E01.中英字幕.WEBrip.720P-人人影视.V2.mp4&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sdcard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">mac mini做nas+小米电视</summary></entry><entry><title type="html">Goland的external tool</title><link href="https://mafulong.github.io/2025/08/09/Goland%E7%9A%84external-tool/" rel="alternate" type="text/html" title="Goland的external tool" /><published>2025-08-09T00:00:00+08:00</published><updated>2025-08-09T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/08/09/Goland%E7%9A%84external%20tool</id><content type="html" xml:base="https://mafulong.github.io/2025/08/09/Goland%E7%9A%84external-tool/">&lt;h2 id=&quot;goland的external-tool&quot;&gt;Goland的external tool&lt;/h2&gt;

&lt;p&gt;goland external open in xx 配置&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;```&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;用zsh&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;下面open&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;参数&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;REPO_ROOT=$(git -C \&quot;$ProjectFileDir$\&quot; rev-parse --show-toplevel); PROJECT=$(basename \&quot;$REPO_ROOT\&quot;); BRANCH=$(git -C \&quot;$REPO_ROOT\&quot; rev-parse --abbrev-ref HEAD); FILE=\&quot;$FilePathRelativeToProjectRoot$\&quot;; LINE=$LineNumber$; URL=\&quot;xxxxxx/$PROJECT/-/blob/$BRANCH/$FILE?ref_type=heads#L$LINE\&quot;; open \&quot;$URL\&quot;&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;下面copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;参数&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;REPO_ROOT=$(git -C \&quot;$ProjectFileDir$\&quot; rev-parse --show-toplevel); PROJECT=$(basename \&quot;$REPO_ROOT\&quot;); BRANCH=$(git -C \&quot;$REPO_ROOT\&quot; rev-parse --abbrev-ref HEAD); FILE=\&quot;$FilePathRelativeToProjectRoot$\&quot;; LINE=$LineNumber$; URL=\&quot;xxxx/$PROJECT/-/blob/$BRANCH/$FILE?ref_type=heads#L$LINE\&quot;; echo \&quot;$URL\&quot; | pbcopy&quot;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;```&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">Goland的external tool</summary></entry><entry><title type="html">密码学安全</title><link href="https://mafulong.github.io/2025/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8/" rel="alternate" type="text/html" title="密码学安全" /><published>2025-07-15T00:00:00+08:00</published><updated>2025-07-15T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8</id><content type="html" xml:base="https://mafulong.github.io/2025/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8/">&lt;h2 id=&quot;密码学安全&quot;&gt;密码学安全&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://yeasy.gitbook.io/blockchain_guide/05_crypto&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从数学定理到工程实践，密码学和信息安全所涉及的知识体系十分繁杂。本章将介绍与区块链密切相关的安全知识，&lt;strong&gt;包括 Hash 算法与摘要、加密算法、数字签名和证书、PKI 体系、Merkle 树、布隆过滤器、同态加密等。通过本章，读者可以了解常见安全技术体系&lt;/strong&gt;，以及如何实现信息安全的核心要素：机密性、完整性、可认证性和不可抵赖性，为后续理解区块链的设计奠定基础。&lt;/p&gt;

&lt;h2 id=&quot;hash-算法与数字摘要&quot;&gt;Hash 算法与数字摘要&lt;/h2&gt;

&lt;h3 id=&quot;常见算法&quot;&gt;常见算法&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;常见的 Hash 算法包括 MD5、SHA-1、SHA-2、SHA-3 和国产 SM3，其中 MD5 和 SHA-1 已被成功碰撞，不再适合商用，SHA-2/3 和 SM3 是当前主流安全算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前常见的 Hash 算法包括国际上的 Message Digest（MD）系列和 Secure Hash Algorithm（SHA）系列算法，以及国内的 SM3 算法。&lt;/p&gt;

&lt;p&gt;MD 算法主要包括 MD4 和 MD5 两个算法。MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，其输出为 128 位。MD4 已证明不够安全。MD5（RFC 1321）是 Rivest 于 1991 年对 MD4 的改进版本。它对输入仍以 512 位进行分组，其输出是 128 位。MD5 比 MD4 更加安全，但过程更加复杂，计算速度要慢一点。MD5 已于 2004 年被成功碰撞，其安全性已不足应用于商业场景。&lt;/p&gt;

&lt;p&gt;SHA 算法由美国国家标准与技术院（National Institute of Standards and Technology，NIST）征集制定。首个实现 SHA-0 算法于 1993 年问世，1998 年即遭破解。随后的修订版本 SHA-1 算法在 1995 年面世，它的输出为长度 160 位的 Hash 值，安全性更好。SHA-1 设计采用了 MD4 算法类似原理。SHA-1 已于 2005 年被成功碰撞，意味着无法满足商用需求。&lt;/p&gt;

&lt;p&gt;为了提高安全性，NIST 后来制定出更安全的 SHA-224、SHA-256、SHA-384 和 SHA-512 算法（统称为 SHA-2 算法）。新一代的 SHA-3 相关算法也正在研究中。&lt;/p&gt;

&lt;p&gt;此外，中国密码管理局于 2010 年 12 月 17 日发布了 GM/T 0004-2012 《SM3 密码杂凑算法》，建立了国内商用密码体系中的公开 Hash 算法标准，已经被广泛应用在数字签名和认证等场景中。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：MD5 和 SHA-1 算法的破解工作都是由清华大学教授、中国科学院院士王小云主导完成。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;数字摘要&quot;&gt;数字摘要&lt;/h3&gt;

&lt;p&gt;数字摘要是 Hash 算法重要用途之一。顾名思义，数字摘要是对原始的数字内容进行 Hash 运算，获取唯一的摘要值。&lt;/p&gt;

&lt;p&gt;利用 Hash 函数抗碰撞性特点，数字摘要可以检测内容是否被篡改过。&lt;/p&gt;

&lt;p&gt;细心的读者可能会注意到，有些网站在提供文件下载时，会同时提供相应的数字摘要值。用户下载原始文件后可以在本地自行计算摘要值，并与所提供摘要值进行比对，以确保文件内容没有被篡改过。&lt;/p&gt;

&lt;h3 id=&quot;hash-攻击与防护&quot;&gt;Hash 攻击与防护&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;hash 碰撞攻击，可以用加盐（Salt）的方法，Hash 结果和“盐”分别存放在不同的地方。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有时用户设置口令的安全强度不够，采用了一些常见的字符串，如 password、123456 等。有人专门搜集了这些常见口令，计算对应的 Hash 值，制作成字典。这样通过 Hash 值可以快速反查到原始口令。这一类型以空间换时间的攻击方法包括字典攻击和彩虹表攻击（只保存一条 Hash 链的首尾值，相对字典攻击可以节省存储空间）等。&lt;/p&gt;

&lt;p&gt;为了防范这一类攻击，可以采用加盐（Salt）的方法。保存的不是原文的直接 Hash 值，而是原文再加上一段随机字符串（即“盐”）之后的 Hash 值。Hash 结果和“盐”分别存放在不同的地方，这样只要不是两者同时泄露，攻击者就很难进行破解。&lt;/p&gt;

&lt;h2 id=&quot;加解密算法&quot;&gt;加解密算法&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;算法类型&lt;/th&gt;
      &lt;th&gt;特点&lt;/th&gt;
      &lt;th&gt;优势&lt;/th&gt;
      &lt;th&gt;缺陷&lt;/th&gt;
      &lt;th&gt;代表算法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;对称加密&lt;/td&gt;
      &lt;td&gt;加解密的密钥相同&lt;/td&gt;
      &lt;td&gt;计算效率高，加密强度高&lt;/td&gt;
      &lt;td&gt;需提前共享密钥，易泄露&lt;/td&gt;
      &lt;td&gt;DES、3DES、AES、IDEA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;非对称加密&lt;/td&gt;
      &lt;td&gt;加解密的密钥不相同&lt;/td&gt;
      &lt;td&gt;无需提前共享密钥&lt;/td&gt;
      &lt;td&gt;计算效率低，存在中间人攻击可能&lt;/td&gt;
      &lt;td&gt;RSA、ElGamal、椭圆曲线算法&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;对称加密&quot;&gt;对称加密&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;对称密码&lt;/strong&gt;从实现原理上可以分为两种：分组加密和序列加密。前者将明文切分为定长数据块作为基本加密单位，应用最为广泛。后者则每次只对一个字节或字符进行加密处理，且密码不断变化，只用在一些特定领域（如数字媒介的加密）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分组加密&lt;/strong&gt;的代表算法包括 DES、3DES、AES、IDEA 等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DES（Data Encryption Standard）：经典的分组加密算法，最早是美国联邦信息处理标准（FIPS）在 1977 年采用（FIPS-46-3），将 64 位明文加密为 64 位的密文，其密钥长度为 64 位（包括 8 位校验码），现在已经很容易被暴力破解；&lt;/li&gt;
  &lt;li&gt;3DES：三重 DES 操作：加密 –&amp;gt; 解密 –&amp;gt; 加密，处理过程和加密强度优于 DES，但现在也被认为不够安全；&lt;/li&gt;
  &lt;li&gt;AES（Advanced Encryption Standard）：由美国国家标准研究所（NIST）采用，取代 DES 成为对称加密实现的标准，1997~2000 年 NIST 从 15 个候选算法中评选 Rijndael 算法（由比利时密码学家 Joan Daemon 和 Vincent Rijmen 发明）作为 AES，标准为 FIPS-197。AES 也是分组算法，分组长度为 128、192、256 位三种。AES 的优势在于处理速度快，整个过程可以数学化描述，目前尚未有有效的破解手段；&lt;/li&gt;
  &lt;li&gt;IDEA（International Data Encryption Algorithm）：1991 年由密码学家 James Massey 与来学嘉共同提出，设计类似于 3DES，密钥长度增加到 128 位，具有更好的加密强度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;序列加密&lt;/strong&gt;又称流加密。1949 年，Claude Elwood Shannon（信息论创始人）首次证明，要实现绝对安全的完善保密性（Perfect Secrecy），可以通过“一次性密码本”的对称加密处理。即通信双方每次使用跟明文等长的随机密钥串对明文进行加密处理。序列密码采用了类似的思想，每次通过伪随机数生成器来生成伪随机密钥串。代表算法包括 RC4 等。&lt;/p&gt;

&lt;p&gt;总结一下，对称加密算法适用于大量数据的加解密过程，不能用于签名场景，并且需要提前安全地分发密钥。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：分组加密每次只能处理固定长度的明文，因此对于过长的内容需要采用一定模式进行分割&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h3&gt;

&lt;p&gt;非对称加密是现代密码学的伟大发明，它有效解决了对称加密需要安全分发密钥的问题。&lt;/p&gt;

&lt;p&gt;非对称加密算法优点是公私钥分开，无需安全通道来分发密钥。缺点是处理速度（特别是生成密钥和解密过程）往往比较慢，一般比对称加解密算法慢 2~3 个数量级；同时加密强度也往往不如对称加密。&lt;/p&gt;

&lt;p&gt;非对称加密算法的安全性往往基于数学问题，包括大数质因子分解、离散对数、椭圆曲线等经典数学难题。&lt;/p&gt;

&lt;p&gt;代表算法包括：RSA、ElGamal、椭圆曲线、SM2 等系列算法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RSA：经典的公钥算法，1978 年由 Ron Rivest、Adi Shamir、Leonard Adleman 共同提出，三人于 2002 年因此获得图灵奖。算法利用了对大数进行质因子分解困难的特性，但目前还没有数学证明两者难度等价，或许存在未知算法可以绕过大数分解而进行解密。
    &lt;ul&gt;
      &lt;li&gt;原理：&lt;strong&gt;大数分解&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ElGamal：由 Taher ElGamal 设计，利用了模运算下求离散对数困难的特性，比 RSA 产生密钥更快。被应用在 PGP 等安全工具中。&lt;/li&gt;
  &lt;li&gt;椭圆曲线算法（Elliptic Curve Cryptography，ECC）：应用最广也是强度最高的系列算法，基于对椭圆曲线上特定点进行特殊乘法逆运算（求离散对数）难以计算的特性。最早在 1985 年由 Neal Koblitz 和 Victor Miller 分别独立提出。ECC 系列算法具有多种国际标准（包括 ANSI X9.63、NIST FIPS 186-2、IEEE 1363-2000、ISO/IEC 14888-3 等），一般被认为具备较高的安全性，但加解密过程比较费时。其中，密码学家 Daniel J.Bernstein 于 2006 年提出的 Curve25519/Ed25519/X25519 等算法（分别解决加密、签名和密钥交换），由于其设计完全公开、性能突出等特点，近些年引起了广泛关注和应用。&lt;/li&gt;
  &lt;li&gt;SM2（ShangMi 2）：中国国家商用密码系列算法标准，由中国密码管理局于 2010 年 12 月 17 日发布，同样基于椭圆曲线算法，一般认为其安全强度优于 RSA 系列算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非对称加密算法适用于签名场景或密钥协商过程，但不适于大量数据的加解密。除了 SM2 之外，大部分算法的签名速度要比验签速度慢（1~2个数量级）。&lt;/p&gt;

&lt;p&gt;RSA 类算法被认为已经很难抵御现代计算设备的破解，一般推荐商用场景下密钥至少为 2048 位。如果采用安全强度更高的椭圆曲线算法，256 位密钥即可满足绝大部分安全需求。&lt;/p&gt;

&lt;h3 id=&quot;混合加密机制&quot;&gt;混合加密机制&lt;/h3&gt;

&lt;p&gt;混合加密机制同时结合了对称加密和非对称加密的优点。&lt;/p&gt;

&lt;p&gt;该机制的主要过程为：先用非对称加密（计算复杂度较高）协商出一个临时的对称加密密钥（或称会话密钥），然后双方再通过对称加密算法（计算复杂度较低）对所传递的大量数据进行快速的加密处理。&lt;/p&gt;

&lt;p&gt;典型的应用案例是网站中使用越来越普遍的通信协议 – 安全超文本传输协议（Hyper Text Transfer Protocol Secure，HTTPS）。&lt;/p&gt;

&lt;p&gt;加密算法套件包括一组算法，包括交换、认证、加密、校验等：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;密钥交换算法：负责协商对称密钥，常见类型包括 RSA、DH、ECDH、ECDHE 等；&lt;/li&gt;
  &lt;li&gt;证书签名算法：负责验证身份，常见类型包括 RSA、DSA、ECDSA 等；&lt;/li&gt;
  &lt;li&gt;加密数据算法：对建立连接的通信内容进行对称加密，常见类型包括 AES 等;&lt;/li&gt;
  &lt;li&gt;消息认证信息码（MAC）算法：创建报文摘要，验证消息的完整性，常见类型包括 SHA 等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个典型的 TLS 密码算法套件可能为 “TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384”，意味着：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协商过程算法是 ECDHE（Elliptic Curve Diffie–Hellman Ephemeral），基于椭圆曲线的短期 EH 交换，每次交换都用新的密钥，保障前向安全性；&lt;/li&gt;
  &lt;li&gt;证书签名算法是 ECDSA（Elliptic Curve Digital Signature Algorithm），基于椭圆曲线的签名；&lt;/li&gt;
  &lt;li&gt;加密数据算法是 AES，密钥的长度和初始向量的长度都是 256，模式是 CBC；&lt;/li&gt;
  &lt;li&gt;消息认证信息码算法是 SHA，结果是 384 位。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前，推荐选用如下的加密算法套件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
  &lt;li&gt;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
  &lt;li&gt;TLS_RSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
  &lt;li&gt;TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
  &lt;li&gt;TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
  &lt;li&gt;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;消息认证码与数字签名&quot;&gt;消息认证码与数字签名&lt;/h2&gt;

&lt;h3 id=&quot;消息认证码&quot;&gt;消息认证码&lt;/h3&gt;

&lt;p&gt;消息认证码（Hash-based Message Authentication Code，HMAC），利用对称加密，对消息完整性（Integrity）进行保护。&lt;/p&gt;

&lt;p&gt;基本过程为对某个消息，利用提前共享的对称密钥和 Hash 算法进行处理，得到 HMAC 值。该 HMAC 值持有方可以向对方证明自己拥有某个对称密钥，并且确保所传输消息内容未被篡改。&lt;/p&gt;

&lt;p&gt;典型的 HMAC 生成算法包括 K，H，M 三个参数。K 为提前共享的对称密钥，H 为提前商定的 Hash 算法（如 SHA-256），M 为要传输的消息内容。三个参数缺失了任何一个，都无法得到正确的 HMAC 值。&lt;/p&gt;

&lt;p&gt;消息认证码可以用于简单证明身份的场景。如 Alice、Bob 提前共享了 K 和 H。Alice 需要知晓对方是否为 Bob，可发送一段消息 M 给 Bob。Bob 收到 M 后计算其 HMAC 值并返回给 Alice，Alice 检验收到 HMAC 值的正确性可以验证对方是否真是 Bob。&lt;/p&gt;

&lt;h3 id=&quot;数字签名&quot;&gt;数字签名&lt;/h3&gt;

&lt;p&gt;类似在纸质合同上进行签名以确认合同内容和证明身份，数字签名既可以证实某数字内容的完整性，又可以确认其来源（即不可抵赖，Non-Repudiation）。&lt;/p&gt;

&lt;p&gt;一个典型的场景是，Alice 通过信道发给 Bob 一个文件（一份信息），Bob 如何获知所收到的文件即为 Alice 发出的原始版本？Alice 可以先对文件内容进行摘要，然后用自己的私钥对摘要进行加密（签名），之后同时将文件和签名都发给 Bob。Bob 收到文件和签名后，用 Alice 的公钥来解密签名，得到数字摘要，与对文件进行摘要后的结果进行比对。如果一致，说明该文件确实是 Alice 发过来的（因为别人无法拥有 Alice 的私钥），并且文件内容没有被修改过（摘要结果一致）。&lt;/p&gt;

&lt;p&gt;理论上所有的非对称加密算法都可以用来实现数字签名，实践中常用算法包括 1991 年 8 月 NIST 提出的 DSA（Digital Signature Algorithm，基于 ElGamal 算法）和安全强度更高的 ECDSA（Elliptic Curve Digital Signature Algorithm，基于椭圆曲线算法）等。&lt;/p&gt;

&lt;p&gt;除普通的数字签名应用场景外，针对一些特定的安全需求，产生了一些特殊数字签名技术，包括盲签名、多重签名、群签名、环签名等。&lt;/p&gt;

&lt;h4 id=&quot;签名算法&quot;&gt;签名算法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;RSA签名&lt;/strong&gt;：基于加密/解密，通过私钥加密哈希值，公钥解密验证哈希一致性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECDSA/DSA&lt;/strong&gt;：基于椭圆曲线/离散对数，通过数学计算验证签名。
    &lt;ul&gt;
      &lt;li&gt;ECDSA 签名具有一定的延展性（同一交易的签名可以有多种合法表示）&lt;/li&gt;
      &lt;li&gt;比特币的签名使用的是 &lt;strong&gt;椭圆曲线数字签名算法（ECDSA）&lt;/strong&gt;，具体基于 &lt;strong&gt;secp256k1&lt;/strong&gt; 曲线。签名可以用来验证一个交易确实是由对应私钥持有者发起的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EdDSA&lt;/strong&gt;：基于椭圆曲线，具有更高的安全性和效率，主要用于现代加密系统。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HMAC&lt;/strong&gt;：基于哈希的认证，不涉及公钥基础设施，依赖共享密钥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;验证过程&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;用户私钥&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;交易摘要&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ECDSA签名&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;---&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;o&quot;&gt;↓&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;比特币网络节点使用交易公钥验证&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;o&quot;&gt;↓&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;如果验证成功&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;接收该交易&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;盲签名&quot;&gt;盲签名&lt;/h4&gt;

&lt;p&gt;盲签名（Blind Signature），1982 年由 David Chaum 在论文《Blind Signatures for Untraceable Payment》中&lt;a href=&quot;http://www.hit.bme.hu/~buttyan/courses/BMEVIHIM219/2009/Chaum.BlindSigForPayment.1982.PDF&quot;&gt;提出&lt;/a&gt;。签名者需要在无法看到原始内容的前提下对信息进行签名。&lt;/p&gt;

&lt;p&gt;盲签名可以实现对所签名内容的保护，防止签名者看到原始内容；另一方面，盲签名还可以实现防止追踪（Unlinkability），签名者无法将签名内容和签名结果进行对应。典型的实现包括 RSA 盲签名算法等。&lt;/p&gt;

&lt;h4 id=&quot;多重签名&quot;&gt;多重签名&lt;/h4&gt;

&lt;p&gt;多重签名（Multiple Signature），即 n 个签名者中，收集到至少 m 个（n &amp;gt;= m &amp;gt;= 1）的签名，即认为合法。&lt;/p&gt;

&lt;p&gt;其中，n 是提供的公钥个数，m 是需要匹配公钥的最少的签名个数。&lt;/p&gt;

&lt;p&gt;多重签名可以有效地应用在多人投票共同决策的场景中。例如双方进行协商，第三方作为审核方。三方中任何两方达成一致即可完成协商。&lt;/p&gt;

&lt;p&gt;比特币交易中就支持多重签名，可以实现多个人共同管理某个账户的比特币交易。&lt;/p&gt;

&lt;h4 id=&quot;群签名&quot;&gt;群签名&lt;/h4&gt;

&lt;p&gt;群签名（Group Signature），即某个群组内一个成员可以代表群组进行匿名签名。签名可以验证来自于该群组，却无法准确追踪到签名的是哪个成员。&lt;/p&gt;

&lt;p&gt;群签名需要一个群管理员来添加新的群成员，因此存在群管理员可能追踪到签名成员身份的风险。&lt;/p&gt;

&lt;p&gt;群签名最早在 1991 年由 David Chaum 和 Eugene van Heyst 提出。&lt;/p&gt;

&lt;h4 id=&quot;环签名&quot;&gt;环签名&lt;/h4&gt;

&lt;p&gt;环签名（Ring Signature），由 Rivest，Shamir 和 Tauman 三位密码学家在 2001 年首次提出。环签名属于一种简化的群签名。&lt;/p&gt;

&lt;p&gt;签名者首先选定一个临时的签名者集合，集合中包括签名者自身。然后签名者利用自己的私钥和签名集合中其他人的公钥就可以独立地产生签名，而无需他人的帮助。签名者集合中的其他成员可能并不知道自己被包含在最终的签名中。&lt;/p&gt;

&lt;p&gt;环签名在保护匿名性方面也具有很多用途。&lt;/p&gt;

&lt;h2 id=&quot;数字证书&quot;&gt;数字证书&lt;/h2&gt;

&lt;p&gt;数字证书机制正是为了解决这个问题，它就像日常生活中的证书一样，可以确保所记录信息的合法性。比如证明某个公钥是某个实体（个人或组织）拥有，并且确保任何篡改都能被检测出来，从而实现对用户公钥的安全分发。&lt;/p&gt;

&lt;p&gt;根据所保护公钥的用途，数字证书可以分为加密数字证书（Encryption Certificate）和签名验证数字证书（Signature Certificate）。前者往往用于保护用于加密用途的公钥；后者则保护用于签名用途的公钥。两种类型的公钥也可以同时放在同一证书中。&lt;/p&gt;

&lt;p&gt;一般情况下，证书需要由证书认证机构（Certification Authority，CA）来进行签发和背书。权威的商业证书认证机构包括 DigiCert、GlobalSign、VeriSign 等。用户也可以自行搭建本地 CA 系统，在私有网络中进行使用。&lt;/p&gt;

&lt;p&gt;一般的，一个数字证书内容可能包括证书域（证书的版本、序列号、签名算法类型、签发者信息、有效期、被签发主体、&lt;strong&gt;签发的公开密钥&lt;/strong&gt;）、CA 对证书的签名算法和签名值等。&lt;/p&gt;

&lt;p&gt;X.509 规范中一般推荐使用 PEM（Privacy Enhanced Mail）格式来存储证书相关的文件。证书文件的文件名后缀一般为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.crt&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cer&lt;/code&gt;，对应私钥文件的文件名后缀一般为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.key&lt;/code&gt;，证书请求文件的文件名后缀为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.csr&lt;/code&gt;。有时候也统一用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pem&lt;/code&gt; 作为文件名后缀。&lt;/p&gt;

&lt;p&gt;PEM 格式采用文本方式进行存储，一般包括首尾标记和内容块，内容块采用 base64 编码。&lt;/p&gt;

&lt;p&gt;证书中记录了大量信息，其中最重要的包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;签发的公开密钥&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA 数字签名&lt;/code&gt; 两个信息。因此，只要使用 CA 的公钥再次对这个证书进行签名比对，就能证明所记录的公钥是否合法。&lt;strong&gt;比对过程就是：用 CA 的公钥去“解密”证书的签名部分，看看解密出来的摘要是否和用证书内容自己算出来的摘要一致。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;读者可能会想到，怎么证明用来验证对实体证书进行签名的 CA 公钥自身是否合法呢？毕竟在获取 CA 公钥的过程中，它也可能被篡改掉。&lt;/p&gt;

&lt;p&gt;实际上，CA 的公钥是否合法，一方面可以通过更上层的 CA 颁发的证书来进行认证；另一方面某些根 CA（Root CA）可以通过预先分发证书来实现信任基础。例如，主流操作系统和浏览器里面，往往会提前预置一些权威 CA 的证书（通过自身的私钥签名，系统承认这些是合法的证书）。之后所有基于这些 CA 认证过的中间层 CA（Intermediate CA）和后继 CA 都会被验证合法。这样就从预先信任的根证书，经过中间层证书，到最底下的实体证书，构成一条完整的证书信任链。&lt;/p&gt;

&lt;p&gt;某些时候用户在使用浏览器访问某些网站时，可能会被提示是否信任对方的证书。这说明该网站证书无法被当前系统中的证书信任链进行验证，需要进行额外检查。另外，当信任链上任一证书不可靠时，则依赖它的所有后继证书都将失去保障。&lt;/p&gt;

&lt;p&gt;可见，证书作为公钥信任的基础，对其生命周期进行安全管理十分关键。后面章节将介绍的 PKI 体系提供了一套完整的证书管理的框架，包括生成、颁发、撤销过程等。&lt;/p&gt;

&lt;h2 id=&quot;merkle-树结构&quot;&gt;Merkle 树结构&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;默克尔树&lt;/a&gt;（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。默克尔树最早由 Merkle Ralf 在 1980 年提出，曾广泛用于文件系统和 P2P 系统中。&lt;/p&gt;

&lt;p&gt;其主要特点为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最下面的叶节点包含存储数据或其哈希值；&lt;/li&gt;
  &lt;li&gt;非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。&lt;/p&gt;

&lt;p&gt;默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。&lt;/p&gt;

&lt;p&gt;目前，默克尔树的典型应用场景包括如下几种。&lt;/p&gt;

&lt;h3 id=&quot;证明某个集合中存在或不存在某个元素&quot;&gt;证明某个集合中存在或不存在某个元素&lt;/h3&gt;

&lt;p&gt;通过构建集合的默克尔树，并提供该元素各级兄弟节点中的 Hash 值，可以不暴露集合完整内容而证明某元素存在。&lt;/p&gt;

&lt;p&gt;另外，对于可以进行排序的集合，可以将不存在元素的位置用空值代替，以此构建稀疏默克尔树（Sparse Merkle Tree）。该结构可以证明某个集合中不包括指定元素。&lt;/p&gt;

&lt;h3 id=&quot;快速比较大量数据&quot;&gt;快速比较大量数据&lt;/h3&gt;

&lt;p&gt;对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。&lt;/p&gt;

&lt;p&gt;由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。&lt;/p&gt;

&lt;h3 id=&quot;快速定位修改&quot;&gt;快速定位修改&lt;/h3&gt;

&lt;p&gt;基于数据 D0……D3 构造默克尔树，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。&lt;/p&gt;

&lt;p&gt;因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root –&amp;gt; N4 –&amp;gt; N1，最多通过 O(lgN) 时间即可快速定位到实际发生改变的数据块 D1。&lt;/p&gt;

&lt;h3 id=&quot;零知识证明&quot;&gt;零知识证明&lt;/h3&gt;

&lt;p&gt;仍以上图为例，如何向他人证明拥有某个数据 D0 而不暴露其它信息。挑战者提供随机数据 D1，D2 和 D3，或由证明人生成（需要加入特定信息避免被人复用证明过程）。&lt;/p&gt;

&lt;p&gt;证明人构造如图所示的默克尔树，公布 N1，N5，Root。验证者自行计算 Root 值，验证是否跟提供值一致，即可很容易检测 D0 存在。整个过程中验证者无法获知与 D0 相关的额外信息。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">密码学安全</summary></entry><entry><title type="html">以太坊技术</title><link href="https://mafulong.github.io/2025/07/13/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8A%80%E6%9C%AF/" rel="alternate" type="text/html" title="以太坊技术" /><published>2025-07-13T00:00:00+08:00</published><updated>2025-07-13T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/07/13/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8A%80%E6%9C%AF</id><content type="html" xml:base="https://mafulong.github.io/2025/07/13/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8A%80%E6%9C%AF/">&lt;h2 id=&quot;以太坊技术&quot;&gt;以太坊技术&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://liaoxuefeng.com/books/blockchain/ethereum/index.html&quot;&gt;廖雪峰笔记参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;以太坊&quot;&gt;以太坊&lt;/h2&gt;

&lt;p&gt;以太坊（Ethereum）是一个支持智能合约的区块链平台，它与比特币最大的不同是，以太坊通过一个虚拟机（EVM）可以运行智能合约。&lt;/p&gt;

&lt;p&gt;以太坊是&lt;a href=&quot;https://vitalik.ca/&quot;&gt;Vitalik Buterin&lt;/a&gt;（维塔利克·布特林，人称V神）在2013年提出的概念，Vitalik最早参与了比特币社区的开发，并希望比特币把功能受限的脚本扩展成图灵完全的编程环境，但没有得到比特币开发社区的认同，于是他决定另起炉灶，打造一个新的区块链平台，目标是运行去中心化的程序。&lt;/p&gt;

&lt;p&gt;以太坊从2015年正式启动并运行，期间经历过DAO攻击造成的硬分叉。和比特币类似，以太坊也通过PoW进行挖矿，后改为PoS挖矿，其挖出的平台币叫以太币（Ether），目前每个区块奖励是2 Ether，约13~15秒左右出一个块。&lt;/p&gt;

&lt;p&gt;和比特币相比，以太坊在以下几点上有所不同：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;账户模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比特币使用的&lt;a href=&quot;https://liaoxuefeng.com/books/blockchain/bitcoin/utxo/index.html&quot;&gt;UTXO模型&lt;/a&gt;是一种对开发友好、易于实现清结算的模型，但对用户不友好，因为普通用户所认知的账户是一个账号、对应余额变动的模型。以太坊的账户模型和比特币不同，它就是余额模型，即交易引发账户余额的变动，这与传统金融账户一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;智能合约&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从比特币的&lt;a href=&quot;https://liaoxuefeng.com/books/blockchain/bitcoin/pay/index.html&quot;&gt;可编程支付原理&lt;/a&gt;可知，任何支付实际上都是在执行比特币脚本，只有脚本成功执行，支付才能成功。&lt;/p&gt;

&lt;p&gt;以太坊的交易与之类似，并且更进一步，它实现了一个图灵完备的脚本语言，运行在EVM（Ethereum Virtual Machine，以太坊虚拟机）中，任何人都可以编写合法的脚本来执行任意逻辑（有很多限制），例如，定义一种新的代币，抵押贷款等。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;账户&quot;&gt;账户&lt;/h2&gt;

&lt;p&gt;以太坊账户负责存储用户的以太坊余额。对大多数普通用户来说，以太坊账户和银行账户非常类似，通常只需要一个账户即可。&lt;/p&gt;

&lt;p&gt;确切地说，以太坊账户分为外部账户和合约账户两类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;外部账户：即普通用户用私钥控制的账户；&lt;/li&gt;
  &lt;li&gt;合约账户：一种拥有合约代码的账户，它不属于任何人，也没有私钥与之对应。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本节我们仅讨论普通用户使用的外部账户。&lt;/p&gt;

&lt;p&gt;和比特币类似，一个以太坊账户就是一个公钥哈希后得到的地址，它是由一个私钥推导出对应的公钥，然后再计算出地址。其中，私钥与公钥算法与比特币完全相同，均为secp256k1椭圆曲线，但和比特币不同的是，以太坊采用非压缩公钥，然后直接对公钥做keccak256哈希，得到32字节的哈希值，取后20字节加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x&lt;/code&gt;前缀即为地址&lt;/p&gt;

&lt;p&gt;因为以太坊和比特币的非对称加密算法是完全相同的，不同的仅仅是公钥和地址的表示格式，因此，比特币的HD钱包体系也完全适用于以太坊。用户通过一套助记词，既可以管理比特币钱包，也可以管理以太坊钱包。&lt;/p&gt;

&lt;p&gt;以太坊钱包的派生路径是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;/60&apos;/0&apos;/0/0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为以太坊采用账户余额模型，通常情况下一个以太坊地址已够用。如果要生成多个地址，可继续派生&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;/60&apos;/0&apos;/0/1&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;/60&apos;/0&apos;/0/2&lt;/code&gt;等。&lt;/p&gt;

&lt;h2 id=&quot;区块结构&quot;&gt;区块结构&lt;/h2&gt;

&lt;p&gt;比特币的区块链是由PoW保证每个区块都指向前一个区块，而在每一个区块内部，由一个独立的Merkle Tree来保证所有交易的不可篡改。用户的比特币是以UTXO的方式存储的，因此，比特币的交易就是不断地消耗现有的UTXO，并产生新的UTXO。&lt;/p&gt;

&lt;p&gt;而以太坊采用的是账户模型，如果小明的账户在某个区块的资产是1 ETH，当小明给小红转账0.2 ETH后，刨除手续费，他的账户还剩下约0.8 ETH。由于小明的账户地址不变，所以，以太坊的区块结构必须能在每个区块持续地跟踪并记录小明的账户余额变动。因此，和比特币相比，以太坊的区块数据结构更加复杂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以太坊的核心数据结构是以Merkle Patricia Tree记录的世界状态，每个区块通过打包新的交易，从而导致世界状态的变化。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;merkle-patricia-tree&quot;&gt;Merkle Patricia Tree&lt;/h3&gt;

&lt;p&gt;以太坊存储账户数据的数据结构是MPT：Merkle Patricia Tree，它是一种改进的Merkle Tree。当MPT的每个叶子结点的值确定后，计算出的Root Hash就是完全确定的。例如，在第一个区块中，4个账户的余额确定后，即可确定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Root1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Root1
│          ┌───┐          │
           │   │
│          └───┘          │
             │
│      ┌─────┴─────┐      │
       │           │
│    ┌───┐       ┌───┐    │
     │   │       │   │
│    └───┘       └───┘    │
       │           │
│   ┌──┴──┐     ┌──┴──┐   │
    │     │     │     │
│ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │
  │5.5│ │0.2│ │1.7│ │9.0│
│ └───┘ └───┘ └───┘ └───┘ │
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在第二个区块中，如果发生了转账，将计算出一个新的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Root2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;每一个区块通过Root Hash将完全确定所有账户的状态，所以，从全局看，以太坊就是一个状态机，每个区块通过记录一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateRoot&lt;/code&gt;来表示一个新状态。如果给定某个区块的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateRoot&lt;/code&gt;，我们肯定能完全确定所有账户的所有余额等信息。因此，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateRoot&lt;/code&gt;就被称为当前的世界状态。&lt;/p&gt;

&lt;p&gt;有的同学可能会思考，如果第一个区块只有几个账户，随着账户的增加，如果有数百万个账户，到后面岂不是区块存储的数据量会越来越大？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实际上，每个区块的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateRoot&lt;/code&gt;表示的是一个完全状态的逻辑树，但每个区块记录的数据只包括修改的部分，如果我们观察第二个区块的树，它实际上只记录修改的两个账户，以及两个账户因修改后导致的上层路径的Hash发生的变化&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;账户数据&quot;&gt;账户数据&lt;/h3&gt;

&lt;p&gt;一个以太坊账户由4部分数据构成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nonce&lt;/li&gt;
  &lt;li&gt;balance&lt;/li&gt;
  &lt;li&gt;storageRoot&lt;/li&gt;
  &lt;li&gt;codeHash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;是一个递增的整数，每发送一次交易，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;递增&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;，因此，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;记录的就是交易次数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;balance&lt;/code&gt;记录的就是账户余额，以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wei&lt;/code&gt;为单位，1 Ether等于1018wei。&lt;/p&gt;

&lt;p&gt;如果一个账户是合约账户，则&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;storageRoot&lt;/code&gt;存储合约相关的状态数据，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;codeHash&lt;/code&gt;存储合约代码的Hash。对于外部账户，这两部分数据都是空。&lt;/p&gt;

&lt;h3 id=&quot;交易&quot;&gt;交易&lt;/h3&gt;

&lt;p&gt;以太坊的交易需要消耗Gas，而Gas价格和实际消耗的数量决定了一个交易实际消耗的Ether，即交易成本。&lt;/p&gt;

&lt;p&gt;合约交易无法精确地确定Gas数量，只能预估并给出Gas Limit。&lt;/p&gt;

&lt;h4 id=&quot;基本流程&quot;&gt;基本流程&lt;/h4&gt;

&lt;p&gt;在比特币中，交易就是消耗已有UTXO，并通过执行脚本产生新的UTXO，其中隐含的新旧差额即为矿工手续费。&lt;/p&gt;

&lt;p&gt;在以太坊中，交易也需要手续费，手续费被称为Gas（汽油），它的计算比比特币要复杂得多。&lt;/p&gt;

&lt;p&gt;以太坊除了最基本的转账：即从一个账户支付Ether到另一个账户，还支持执行合约代码。合约代码是图灵完备的编程语言，通过EVM（以太坊虚拟机）执行。如果某个合约编写了一个无限循环，那么所有节点执行该合约代码，岂不是永远无法结束？&lt;/p&gt;

&lt;p&gt;为了保证合约代码的可靠执行，以太坊给每一个虚拟机指令都标记了一个Gas基本费用，称为gasUsed。例如，加减计算的费用是3，计算SHA3的费用是30，输出日志的费用是375，写入存储的费用高达20000。总的来说，消耗CPU比消耗存储便宜，简单计算比复杂计算便宜，读取比写入便宜。&lt;/p&gt;

&lt;p&gt;除了gasUsed外，用户还需要提供一个gasPrice，以Gwei（1Gwei=109Wei）为单位。通过竞价得到一个矿工愿意接受的gasPrice。如果一个交易消耗了120000的gasUsed，而gasPrice是50 Gwei，则交易费用是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;120000 x 50 Gwei = 6000000 Gwei = 0.006 Ether
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在执行代码的时候，存在条件判断、循环等语句，同一段代码，执行的结果也可能不同，因此，事前预计一个合约执行要花费多少Gas，不现实。&lt;/p&gt;

&lt;p&gt;所以以太坊规定，一笔交易，先给出gasPrice和gasLimit，如果执行完成后有剩余，剩余的退还，如果执行过程中消耗殆尽，那么交易执行失败，但已执行的Gas不会退。&lt;/p&gt;

&lt;p&gt;太复杂了是不是？我们还是举个例子。&lt;/p&gt;

&lt;p&gt;假定某个账户想执行一笔交易，他给出gasPrice为50 Gwei，预估gasUsed约120000，设定gasLimit为150000，则预支付的Ether为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;150000 x 50 Gwei = 7500000 Gwei = 0.0075 Ether
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果账户的Ether余额不足0.0075，则该交易根本无法发送。如果账户余额等于或超过0.0075，例如余额为0.008，则矿工可以将该交易打包。假设实际执行消耗的gasUsed为120000，则交易费用0.006，账户剩余0.002。&lt;/p&gt;

&lt;p&gt;很少有交易能准确预估gasUsed，只有标准转账交易是21000，因此，标准的转账交易gasLimit可以设置为21000（即恰好消耗完毕无剩余）。&lt;/p&gt;

&lt;p&gt;Gas Price是全网用户竞价产生的，它时刻在波动。如果交易少，Gas Price将下降，如果交易多，网络拥堵，则Gas Price将上升。以太坊的Gas价格可以在&lt;a href=&quot;https://etherscan.io/gastracker&quot;&gt;Etherscan&lt;/a&gt;跟踪。&lt;/p&gt;

&lt;h4 id=&quot;交易回执&quot;&gt;交易回执&lt;/h4&gt;

&lt;p&gt;以太坊区块为每一笔交易都会产生一笔回执（Recipt），表示交易的最终状态。一个回执信息主要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;status：执行结果，1表示成功，0表示失败；&lt;/li&gt;
  &lt;li&gt;gasUsed：已消耗的Gas数量；&lt;/li&gt;
  &lt;li&gt;txHash：交易Hash；&lt;/li&gt;
  &lt;li&gt;logs：交易产生的日志；&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;转账交易&quot;&gt;转账交易&lt;/h4&gt;

&lt;p&gt;转账交易是指两个外部账号转移Ether，我们以交易&lt;a href=&quot;https://etherscan.io/tx/0xb94087cdaa291e595ba02e846864cb9f5b681ca10efe2a91eb626d11101c4ad7&quot;&gt;0xb940…4ad7&lt;/a&gt;为例，可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Transaction Hash: 0xb940…4ad7，这是交易Hash，即交易的唯一标识；&lt;/li&gt;
  &lt;li&gt;Status: Success，表示交易成功；&lt;/li&gt;
  &lt;li&gt;From: 0x0FFf…bBc4，交易的发送方；&lt;/li&gt;
  &lt;li&gt;To: 0x5b2a…5a46，交易的接收方；&lt;/li&gt;
  &lt;li&gt;Value: 1.6912 Ether，交易发送的Ether；&lt;/li&gt;
  &lt;li&gt;Gas Price: 82 Gwei，Gas的价格；&lt;/li&gt;
  &lt;li&gt;Gas Limit: 21,000，转账交易恰好消耗21000Gas，因此总是21000；&lt;/li&gt;
  &lt;li&gt;Usage by Txn: 21,000 (100%)，消耗的Gas占比，这里恰好全部消耗完；&lt;/li&gt;
  &lt;li&gt;Nonce：0，发送方的nonce，0表示第1笔交易；&lt;/li&gt;
  &lt;li&gt;Input Data: 0x，因为是转账交易，没有输入数据，因此为空。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;合约交易&quot;&gt;合约交易&lt;/h4&gt;

&lt;p&gt;合约交易就是指一个外部账号调用某个合约的某个public函数。我们以交易&lt;a href=&quot;https://etherscan.io/tx/0x8affd7588219529b5b4652abd4bd9a2ad5b7aec1490d62ca359ae56a6c3c8cd0&quot;&gt;0x8aff…8cd0&lt;/a&gt;为例，可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;From: 0x2329…BA3a，交易的发起方，该地址一定是外部账户；&lt;/li&gt;
  &lt;li&gt;To: 0x7a25…488D，交易的接收方，这里地址是一个合约地址；&lt;/li&gt;
  &lt;li&gt;Value: 4.5 Ether，即向合约发送4.5 Ether；&lt;/li&gt;
  &lt;li&gt;Gas Limit: 152,533，这是交易发起前设定的最大Gas；&lt;/li&gt;
  &lt;li&gt;Usage by Txn: 125,290 (82.14%)，这是交易实际消耗的Gas；&lt;/li&gt;
  &lt;li&gt;Input Data: 0x7ff36ab5…，这是交易的输入数据，其中包含了调用哪个函数，以及传递的参数，解码后可知调用函数是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swapExactETHForTokens&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，转账交易的Gas费用是固定的，而合约交易只能预估，具体费用以实际执行后消耗的为准。&lt;/p&gt;

&lt;h4 id=&quot;什么是-nonce&quot;&gt;什么是 nonce？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在以太坊中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt; 是一个账户已经发送的交易数量，或说该账户的交易“计数器”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它是每个账户（包括普通账户和合约账户）都维护的一个数字：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通地址：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce = 该地址已经发出的交易数量&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;合约地址部署时：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce = 部署者地址已发出的交易数量&lt;/code&gt;，用于生成合约地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;nonce 的两个关键用途：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;📦 防止交易重放攻击（Replay Attack）&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;每笔交易都必须带一个唯一的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果你重复广播一模一样的交易（同一个 nonce），网络会拒绝&lt;/li&gt;
  &lt;li&gt;确保每笔交易唯一且有序，不能被复制伪造&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;🏗️ 确定新部署的合约地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当你部署一个新智能合约时，&lt;strong&gt;合约地址不是随机的&lt;/strong&gt;，而是由下面这个公式确定：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;合约地址 = keccak256(rlp_encode([部署者地址, 部署者的 nonce])) 的最后 20 字节
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，不同 nonce 部署出来的合约地址也不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;智能合约&quot;&gt;智能合约&lt;/h3&gt;

&lt;h4 id=&quot;智能合约-1&quot;&gt;智能合约&lt;/h4&gt;

&lt;p&gt;以太坊相比比特币的一个重大创新就是它支持智能合约（Smart Contract）。&lt;/p&gt;

&lt;p&gt;所谓智能合约，就是一种运行在区块链上的程序。和普通程序不同的是，智能合约要保证在区块链网络的每一个节点中运行的结果完全相同，这样才能使任何一个节点都可以验证挖矿产出节点生成的区块里，智能合约执行的结果对不对。&lt;/p&gt;

&lt;p&gt;因此，以太坊提供了一个EVM（Ethereum Virtual Machine）虚拟机来执行智能合约的字节码，并且，和普通程序相比，为了消除程序运行的不确定性，智能合约有很多限制，例如，不支持浮点运算（因为浮点数有不同的表示方法，不同架构的CPU运行的浮点计算精度都不同），不支持随机数，不支持从外部读取输入等等。&lt;/p&gt;

&lt;p&gt;类似于Java源码被编译为JVM可执行的字节码，我们也需要一种高级语言来编写智能合约，然后编译成EVM的字节码。最常用的开发智能合约的语言是以太坊专门为其定制的&lt;a href=&quot;https://docs.soliditylang.org/&quot;&gt;Solidity&lt;/a&gt;语言，后续我们会详细介绍Solidity的用法。&lt;/p&gt;

&lt;p&gt;一个智能合约被编译后就是一段EVM字节码，将它部署在以太坊的区块链时，会根据部署者的地址和该地址的nonce分配一个合约地址，合约地址和账户地址的格式是没有区别的，但合约地址没有私钥，也就没有人能直接操作该地址的合约数据。要调用合约，唯一的方法是调用合约的公共函数。&lt;/p&gt;

&lt;p&gt;这也是合约的一个限制：合约不能主动执行，它只能被外部账户发起调用。如果一个合约要定期执行，那只能由线下服务器定期发起合约调用。&lt;/p&gt;

&lt;p&gt;此外，合约作为地址，可以接收Ether，也可以发送Ether。合约内部也可以存储数据。合约的数据存储在合约地址关联的存储上，这就使得合约具有了状态，可以实现比较复杂的逻辑，包括存款、取款等。&lt;/p&gt;

&lt;p&gt;合约在执行的过程中，可以调用其他已部署的合约，前提是知道其他合约的地址和函数签名，这就大大扩展了合约的功能。例如，一个合约可以调用另一个借贷合约的借款方法，再调用交易合约，最后再调用还款方法，实现所谓的“闪电贷”（即在一个合约调用中实现借款-交易-还款）功能。多个合约的嵌套调用也使得因为代码编写的漏洞导致黑客攻击的可能性大大增加。为了避免漏洞，编写合约时需要更加小心。&lt;/p&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;p&gt;以太坊通过EVM虚拟机执行智能合约代码；&lt;/p&gt;

&lt;p&gt;合约被部署后将自动获得一个地址，并可像外部账户一样存取Ether，还可以存储状态数据；&lt;/p&gt;

&lt;p&gt;合约只能被动地被外部账户调用，但在执行时可以调用其他合约的公共函数。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">以太坊技术</summary></entry><entry><title type="html">比特币技术</title><link href="https://mafulong.github.io/2025/07/13/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8A%80%E6%9C%AF/" rel="alternate" type="text/html" title="比特币技术" /><published>2025-07-13T00:00:00+08:00</published><updated>2025-07-13T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/07/13/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8A%80%E6%9C%AF</id><content type="html" xml:base="https://mafulong.github.io/2025/07/13/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8A%80%E6%9C%AF/">&lt;h2 id=&quot;区块链入门-比特币技术&quot;&gt;区块链入门 比特币技术&lt;/h2&gt;

&lt;p&gt;廖雪峰的区块链笔记。 &lt;a href=&quot;https://liaoxuefeng.com/books/blockchain/bitcoin/basic/index.html&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;数字货币-vs-电子货币&quot;&gt;数字货币 vs. 电子货币&lt;/h3&gt;

&lt;p&gt;电子货币本质上仍然是法币，它仍然是由央行发行，只是以计算机技术把货币以实体纸币形式的流通变成了银行计算机系统的存款。和纸币相比，电子货币具有更高的流动性。我们每天使用的网上银行、支付宝、微信支付等，都是这种方式。&lt;/p&gt;

&lt;p&gt;而比特币作为一种数字货币，它和电子货币不同的是，比特币不需要一个类似银行的中央信任机构，就可以通过全球P2P网络进行发行和流通，这一点听上去有点不可思议，但比特币正是一种通过密码学理论建立的不可伪造的货币系统。&lt;/p&gt;

&lt;h3 id=&quot;比特币解决的问题&quot;&gt;比特币解决的问题&lt;/h3&gt;

&lt;p&gt;比特币则是通过区块链技术，把整个账本全部公开，人手一份，全网相同，因此，修改账本不会被其他人承认。比特币的区块链就是一种存储了全部账本的链式数据库，通过一系列密码学理论进行防篡改，防双花。&lt;/p&gt;

&lt;p&gt;比特币解决的是现金电子化后无需中央信任机构的交易问题，即M0如何通过网络进行价值传输。我们已经习惯了通过互联网对数字化的新闻、音乐、视频进行信息传输，因为信息传输的本质是复制，但现实世界的现金可不能复制。想象一下我们如何把100元现金通过网络发送给另一个人，同时确保交易前后两个人的现金总额保持不变。所以，中本聪的白皮书把比特币定义为“点对点的电子现金系统”。&lt;/p&gt;

&lt;p&gt;区块链是由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：&lt;/p&gt;

&lt;p&gt;比特币网络中是&lt;strong&gt;每次生成一个新区块&lt;/strong&gt;，新区块中会打包&lt;strong&gt;多笔交易信息&lt;/strong&gt;，&lt;/p&gt;

&lt;h2 id=&quot;区块链原理&quot;&gt;区块链原理&lt;/h2&gt;

&lt;h4 id=&quot;-交易信息的来源内存池mempool&quot;&gt;✅ 交易信息的来源：&lt;strong&gt;内存池（Mempool）&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;什么是内存池？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当用户（或钱包、交易所）发起一笔交易，例如从一个地址发送 BTC 到另一个地址，这笔交易会首先被广播到比特币网络，然后：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;网络中的节点会接收到这笔交易&lt;/li&gt;
  &lt;li&gt;节点会先对其进行验证（签名是否有效、余额是否够等）&lt;/li&gt;
  &lt;li&gt;验证无误后，这笔交易就被加入到&lt;strong&gt;内存池（Mempool）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;-挖矿时如何生成区块&quot;&gt;✅ 挖矿时如何生成区块？&lt;/h4&gt;

&lt;p&gt;矿工创建新区块时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;从内存池中选择交易&lt;/strong&gt;（优先选择手续费高的）&lt;/li&gt;
  &lt;li&gt;将这些交易打包成一个候选区块（称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block template&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;进行工作量证明（Proof of Work，解题）&lt;/li&gt;
  &lt;li&gt;谁先解出哈希，谁就&lt;strong&gt;生成新区块&lt;/strong&gt;，广播给全网&lt;/li&gt;
  &lt;li&gt;其他节点验证区块，没问题就接受该区块，并加入区块链中&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;-每个区块至少包含两笔交易&quot;&gt;✅ 每个区块至少包含两笔交易：&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Coinbase 交易&lt;/strong&gt;：矿工的奖励交易（包括区块奖励和所有交易的手续费）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户交易&lt;/strong&gt;：从 Mempool 中打包进来的普通交易&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;情况两个矿工同时挖出区块产生短暂分叉&quot;&gt;情况：两个矿工同时挖出区块，产生「短暂分叉」&lt;/h5&gt;

&lt;p&gt;假设当前链到高度 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;，现在两个矿工分别几乎同时挖出下一个新区块。 因为网络传播延迟，不是所有节点都立刻看到同一个区块&lt;/p&gt;

&lt;h5 id=&quot;️-解决机制最长链原则longest-chain-rule&quot;&gt;⚙️ 解决机制：&lt;strong&gt;最长链原则（Longest Chain Rule）&lt;/strong&gt;&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;比特币规定：&lt;strong&gt;所有节点只承认「工作量最多（最长）」的链为主链。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;分叉如何被解决&quot;&gt;分叉如何被解决？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;两条链并存时，网络中部分节点支持 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N+1a&lt;/code&gt;，另一部分支持 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N+1b&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下一轮，假设某个矿工在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N+1a&lt;/code&gt; 的链上挖出了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N+2a&lt;/code&gt;，并成功广播给大多数节点：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mathematica
   
   
CopyEdit
     区块 N
      /  \
区块 N+1a 区块 N+1b
     |
 区块 N+2a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有节点看到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N+2a&lt;/code&gt; 后发现这条链「更长」，就&lt;strong&gt;切换到这个分支&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N+1b&lt;/code&gt; 就成为&lt;strong&gt;孤块（orphan block）&lt;/strong&gt;，被丢弃&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;-孤块orphan-block&quot;&gt;💡 孤块（Orphan Block）&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;是被网络短暂接受但最终被抛弃的区块&lt;/li&gt;
  &lt;li&gt;其中的交易 &lt;strong&gt;不会丢失&lt;/strong&gt;，而是重新回到 Mempool&lt;/li&gt;
  &lt;li&gt;这些交易可能会被重新打包进后续区块中&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;-举个例子&quot;&gt;🧠 举个例子：&lt;/h5&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A矿工和B矿工分别在北京和纽约，几乎同时挖出区块高度为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;850,000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A的区块传播到亚洲快一些，B的传播到美洲快&lt;/li&gt;
  &lt;li&gt;某矿工在接收到 A 的区块后成功挖出了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;850,001&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;这样整个网络最终选择了以 A 为主的链，B的链被回滚&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-初步广播并打包--最终确认&quot;&gt;✅ 初步广播并打包 ≠ 最终确认&lt;/h4&gt;

&lt;p&gt;在比特币中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你的交易被打包进某个区块 ✅，&lt;strong&gt;并不代表最终交易成功&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;如果这个区块后来被抛弃（因为发生分叉），那么这个交易就&lt;strong&gt;等于没发生过&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;这时交易会回到内存池（Mempool）中等待重新打包&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;在区块链分叉发生时，交易是否成功，要看它是否最终出现在主链中。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;-分叉中交易可能经历&quot;&gt;🔁 分叉中交易可能经历：&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;被某个区块打包&lt;/td&gt;
      &lt;td&gt;暂时进入链中，但可能被分叉掉&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;区块被孤立（orphaned）&lt;/td&gt;
      &lt;td&gt;所有交易视为未确认，回到 Mempool&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;被新主链重新打包&lt;/td&gt;
      &lt;td&gt;再次等待确认，才算最终成功&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;-所以为什么我们说交易要有确认数&quot;&gt;📊 所以为什么我们说交易要有「确认数」？&lt;/h4&gt;

&lt;p&gt;比特币交易通常说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“建议等 &lt;strong&gt;6 个确认&lt;/strong&gt;，再认为交易是最终不可逆的”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;确认数是指：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;某交易所在区块之后又被多少个区块所确认&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;确认数&lt;/th&gt;
      &lt;th&gt;安全性说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;仅在 Mempool，还没被打包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;刚被打包，可能会被分叉&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2~3&lt;/td&gt;
      &lt;td&gt;安全性逐渐提高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6+&lt;/td&gt;
      &lt;td&gt;基本不可逆（99.999% 安全）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;-为什么越多确认越安全&quot;&gt;💡 为什么越多确认越安全？&lt;/h5&gt;

&lt;p&gt;因为要「回滚」你的交易，攻击者必须：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;回滚区块 N 所在的整条链&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;并从区块 N 开始挖出一个&lt;strong&gt;比现在主链还长的新链&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;这需要消耗大量算力（PoW）&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;-攻击成本随着确认数指数级上升&quot;&gt;📈 攻击成本随着确认数指数级上升&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;确认数 = 1&lt;/strong&gt;：攻击者只需要超过网络 50% 算力一点点，就有较高成功率&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确认数 = 6&lt;/strong&gt;：攻击者需要极高算力和运气，在短时间内挖出 6 个新区块赶上主链&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确认数 &amp;gt; 6&lt;/strong&gt;：攻击成本已经接近不可能，除非攻击者掌握接近全球一半的比特币算力&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;-如果真的持续分叉会怎样&quot;&gt;🔁 如果真的持续分叉，会怎样？&lt;/h5&gt;

&lt;p&gt;这种情况通常只在以下条件下出现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;恶意攻击（如拥有超过 50% 算力的攻击者）&lt;/li&gt;
  &lt;li&gt;网络严重分区（partitioning）&lt;/li&gt;
  &lt;li&gt;共识机制被篡改（如协议漏洞）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但一旦这样发生，整个比特币生态就会：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;出现链重组（reorg）&lt;/li&gt;
  &lt;li&gt;引发重大共识危机&lt;/li&gt;
  &lt;li&gt;开发者/社区可能会通过硬分叉修复&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-解释一下什么是区块高度block-height&quot;&gt;📚 解释一下什么是“区块高度”（Block Height）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;区块高度是用来表示某个区块在整个区块链中的&lt;strong&gt;位置编号&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;创世区块（第一个区块，Genesis Block）的高度是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;每新挖出一个区块，高度就 +1&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;区块高度 851,768&lt;/td&gt;
      &lt;td&gt;是比特币链上的第 851,768 个区块&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;作用&lt;/td&gt;
      &lt;td&gt;用于定位、检索、追踪、验证交易历史等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;如何查看&lt;/td&gt;
      &lt;td&gt;区块浏览器（如 mempool.space）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;常用哈希算法&quot;&gt;常用哈希算法&lt;/h3&gt;

&lt;p&gt;常用的哈希算法以及它们的输出长度如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;哈希算法&lt;/th&gt;
      &lt;th&gt;输出长度(bit)&lt;/th&gt;
      &lt;th&gt;输出长度(字节)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MD5&lt;/td&gt;
      &lt;td&gt;128 bit&lt;/td&gt;
      &lt;td&gt;16 bytes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RipeMD160&lt;/td&gt;
      &lt;td&gt;160 bits&lt;/td&gt;
      &lt;td&gt;20 bytes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-1&lt;/td&gt;
      &lt;td&gt;160 bits&lt;/td&gt;
      &lt;td&gt;20 bytes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-256&lt;/td&gt;
      &lt;td&gt;256 bits&lt;/td&gt;
      &lt;td&gt;32 bytes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-512&lt;/td&gt;
      &lt;td&gt;512 bits&lt;/td&gt;
      &lt;td&gt;64 bytes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;比特币使用的哈希算法有两种：SHA-256和RipeMD160&lt;/p&gt;

&lt;p&gt;SHA-256的理论碰撞概率是：尝试2的130次方的随机输入，有99.8%的概率碰撞。注意2130是一个非常大的数字，大约是1361万亿亿亿亿。以现有的计算机的计算能力，是不可能在短期内破解的。&lt;/p&gt;

&lt;p&gt;比特币使用两种哈希算法，一种是对数据进行两次SHA-256计算，这种算法在比特币协议中通常被称为hash256或者dhash。&lt;/p&gt;

&lt;p&gt;另一种算法是先计算SHA-256，再计算RipeMD160，这种算法在比特币协议中通常被称为hash160。&lt;/p&gt;

&lt;h3 id=&quot;区块链不可篡改特性&quot;&gt;区块链不可篡改特性&lt;/h3&gt;

&lt;h3 id=&quot;merkle-hash&quot;&gt;Merkle Hash&lt;/h3&gt;

&lt;p&gt;在区块的头部，有一个Merkle Hash字段，它记录了本区块所有交易的Merkle Hash：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202507131010621.jpg&quot; alt=&quot;Merkle Hash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Merkle Hash是把一系列数据的哈希根据一个简单算法变成一个汇总的哈希。&lt;/p&gt;

&lt;p&gt;假设一个区块有4个交易，我们对每个交易数据做dhash，得到4个哈希值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a1&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a2&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a3&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a4&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1 = dhash(tx1)
a2 = dhash(tx2)
a3 = dhash(tx3)
a4 = dhash(tx4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意到哈希值也可以看做数据，所以可以把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a2&lt;/code&gt;拼起来，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a3&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a4&lt;/code&gt;拼起来，再计算出两个哈希值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b2&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       ┌───────────────┐               ┌───────────────┐
       │b1=dhash(a1+a2)│               │b2=dhash(a3+a4)│
       └───────────────┘               └───────────────┘
               ▲                               ▲
       ┌───────┴───────┐               ┌───────┴───────┐
       │               │               │               │
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│a1=dhash(tx1)│ │a2=dhash(tx2)│ │a3=dhash(tx3)│ │a4=dhash(tx4)│
└─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b2&lt;/code&gt;这两个哈希值拼起来，计算出最终的哈希值，这个哈希就是Merkle Hash：&lt;/p&gt;

&lt;p&gt;如果交易的数量不恰好是4个怎么办？例如，只有3个交易时，第一个和第二个交易的哈希&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a2&lt;/code&gt;可以拼起来算出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b1&lt;/code&gt;，第三个交易只能算出一个哈希&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a3&lt;/code&gt;，这个时候，就把a3直接复制一份，算出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b2&lt;/code&gt;，这样，我们也能最终计算出Merkle Hash：&lt;/p&gt;

&lt;p&gt;如果有5个交易，我们可以看到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a5&lt;/code&gt;被复制了一份，以便计算出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b3&lt;/code&gt;，随后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b3&lt;/code&gt;也被复制了一份，以便计算出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt;。总之，在每一层计算中，如果有单数，就把最后一份数据复制，最后一定能计算出Merkle Hash：&lt;/p&gt;

&lt;p&gt;从Merkle Hash的计算方法可以得出结论：修改任意一个交易哪怕一个字节，或者交换两个交易的顺序，都会导致Merkle Hash验证失败，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用就是保证交易记录永远无法修改。&lt;/p&gt;

&lt;h3 id=&quot;block-hash&quot;&gt;Block Hash&lt;/h3&gt;

&lt;p&gt;区块本身用Block Hash——也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202507131010632.jpg&quot; alt=&quot;Block Hash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。&lt;/p&gt;

&lt;p&gt;由于下一个区块的Prev Hash又会指向当前区块，这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。&lt;/p&gt;

&lt;p&gt;区块链的第一个区块（又称创世区块）并没有上一个区块，因此，它的Prev Hash被设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;00000000...000&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果一个恶意的攻击者修改了一个区块中的某个交易，那么Merkle Hash验证就不会通过。所以，他只能重新计算Merkle Hash，然后把区块头的Merkle Hash也修改了。这时，我们就会发现，这个区块本身的Block Hash就变了，所以，下一个区块指向它的链接就断掉了。&lt;/p&gt;

&lt;p&gt;由于比特币区块的哈希必须满足一个难度值，因此，攻击者必须先重新计算这个区块的Block Hash，然后，再把后续所有区块全部重新计算并且伪造出来，才能够修改整个区块链。&lt;/p&gt;

&lt;p&gt;在后面的挖矿中，我们会看到，修改一个区块的成本就已经非常非常高了，要修改后续所有区块，这个攻击者必须掌握全网51%以上的算力才行，所以，修改区块链的难度是非常非常大的，并且，由于正常的区块链在不断增长，同样一个区块，修改它的难度会随着时间的推移而不断增加。&lt;/p&gt;

&lt;h2 id=&quot;p2p交易原理&quot;&gt;P2P交易原理&lt;/h2&gt;

&lt;h3 id=&quot;数字签名算法&quot;&gt;数字签名算法&lt;/h3&gt;

&lt;p&gt;常用的数字签名算法有：RSA算法，DSA算法和ECDSA算法。比特币采用的签名算法是椭圆曲线签名算法：ECDSA，使用的椭圆曲线是一个已经定义好的标准曲线secp256k1：&lt;/p&gt;

&lt;p&gt;比特币采用的ECDSA签名算法需要一个私钥和公钥组成的秘钥对：私钥本质上就是一个1～2256的随机数，公钥是由私钥根据ECDSA算法推算出来的，通过私钥可以很容易推算出公钥，所以不必保存公钥，但是，通过公钥无法反推私钥，只能暴力破解。&lt;/p&gt;

&lt;p&gt;比特币的私钥是一个随机的非常大的256位整数。它的上限，确切地说，比2256要稍微小一点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而比特币的公钥是根据私钥推算出的两个256位整数。&lt;/p&gt;

&lt;p&gt;如果用银行卡作比较的话，比特币的公钥相当于银行卡卡号，它是两个256位整数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv10/img/202508170751390.png&quot; alt=&quot;bitcoin-card&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比特币的私钥相当于银行卡密码，它是一个256位整数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比特币钱包实际上就是帮助用户管理私钥的软件。因为比特币的钱包是给普通用户使用的，它有几种分类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本地钱包：是把私钥保存在本地计算机硬盘上的钱包软件，如&lt;a href=&quot;https://electrum.org/&quot;&gt;Electrum&lt;/a&gt;；&lt;/li&gt;
  &lt;li&gt;手机钱包：和本地钱包类似，但可以直接在手机上运行，如&lt;a href=&quot;https://bitpay.com/&quot;&gt;Bitpay&lt;/a&gt;；&lt;/li&gt;
  &lt;li&gt;在线钱包：是把私钥委托给第三方在线服务商保存；&lt;/li&gt;
  &lt;li&gt;纸钱包：是指把私钥打印出来保存在纸上；&lt;/li&gt;
  &lt;li&gt;脑钱包：是指把私钥记在自己脑袋里。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对大多数普通用户来说，想要记住私钥非常困难，所以&lt;em&gt;强烈不建议使用脑钱包&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;交易&quot;&gt;交易&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://liaoxuefeng.com/books/blockchain/bitcoin/p2p/index.html#:~:text=%E5%85%AC%E9%92%A5%E5%AF%B9%E3%80%82-,%E4%BA%A4%E6%98%93,-%E6%88%91%E4%BB%AC%E5%86%8D%E6%9D%A5%E7%9C%8B&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;记录在区块链上的交易。每个区块都记录了至少一笔交易，一笔交易就是把一定金额的比特币从一个输入转移到一个输出&lt;/p&gt;

&lt;p&gt;在实际的交易中，输入比输出要稍微大一点点，这个差额就是隐含的交易费用，交易费用会算入当前区块的矿工收入中作为矿工奖励的一部分：&lt;/p&gt;

&lt;p&gt;比特币实际的交易记录是由一系列交易构成，每一个交易都包含一个或多个输入，以及一个或多个输出。未花费的输出被称为UTXO：Unspent Transaction Output。&lt;/p&gt;

&lt;p&gt;当我们要简单验证某个交易的时候，例如，对于交易&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f36abd&lt;/code&gt;，它记录的输入是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3f96ab&lt;/code&gt;，索引号是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;（索引号从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;开始，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;表示第一个输出，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;表示第二个输出，以此类推），我们就根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3f96ab&lt;/code&gt;找到前面已发生的交易，再根据索引号找到对应的输出是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.5&lt;/code&gt;个比特币，所以，这笔交易的输入总计是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.5&lt;/code&gt;个比特币，输出分别是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.4&lt;/code&gt;个比特币和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.09&lt;/code&gt;个比特币，隐含的交易费用是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.01&lt;/code&gt;个比特币：&lt;/p&gt;

&lt;h3 id=&quot;地址&quot;&gt;地址&lt;/h3&gt;

&lt;p&gt;要特别注意，比特币的地址并不是公钥，而是公钥的哈希，即从公钥能推导出地址，但从地址不能反推公钥，因为哈希函数是单向函数。&lt;/p&gt;

&lt;p&gt;比特币的公钥是根据私钥由ECDSA算法推算出来的，公钥有压缩和非压缩两种表示方法，可互相转换。&lt;/p&gt;

&lt;p&gt;比特币的地址是公钥哈希的编码，并不是公钥本身，通过公钥可推导出地址。&lt;/p&gt;

&lt;h2 id=&quot;挖矿原理&quot;&gt;挖矿原理&lt;/h2&gt;

&lt;p&gt;在比特币的P2P网络中，有一类节点，它们时刻不停地进行计算，试图把新的交易打包成新的区块并附加到区块链上，这类节点就是矿工。因为每打包一个新的区块，打包该区块的矿工就可以获得一笔比特币作为奖励。所以，打包新区块就被称为挖矿。&lt;/p&gt;

&lt;p&gt;比特币的挖矿原理就是一种工作量证明机制。工作量证明POW是英文Proof of Work的缩写。&lt;/p&gt;

&lt;h3 id=&quot;pow&quot;&gt;PoW&lt;/h3&gt;

&lt;p&gt;要让计算机实现工作量证明，必须找到一种工作量算法，让计算机无法在短时间内算出来。这种算法就是哈希算法。&lt;/p&gt;

&lt;p&gt;通过改变区块头部的一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;字段的值，计算机可以计算出不同的区块哈希值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202507131205860.jpg&quot; alt=&quot;计算区块哈希&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直到计算出某个特定的哈希值的时候，计算结束。这个哈希和其他的哈希相比，它的特点是前面有好几个0：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;hash256(block data, nonce=0) = 291656f37cdcf493c4bb7b926e46fee5c14f9b76aff28f9d00f5cca0e54f376f
hash256(block data, nonce=1) = f7b2c15c4de7f482edee9e8db7287a6c5def1c99354108ef33947f34d891ea8d
hash256(block data, nonce=2) = b6eebc5faa4c44d9f5232631f39ddf4211443d819208da110229b644d2a99e12
hash256(block data, nonce=3) = 00aeaaf01166a93a2217fe01021395b066dd3a81daffcd16626c308c644c5246
hash256(block data, nonce=4) = 26d33671119c9180594a91a2f1f0eb08bdd0b595e3724050acb68703dc99f9b5
hash256(block data, nonce=5) = 4e8a3dcab619a7ce5c68e8f4abdc49f98de1a71e58f0ce9a0d95e024cce7c81a
hash256(block data, nonce=6) = 185f634d50b17eba93b260a911ba6dbe9427b72f74f8248774930c0d8588c193
hash256(block data, nonce=7) = 09b19f3d32e3e5771bddc5f0e1ee3c1bac1ba4a85e7b2cc30833a120e41272ed
...
hash256(block data, nonce=124709132) = 00000000fba7277ef31c8ecd1f3fef071cf993485fe5eab08e4f7647f47be95c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比特币挖矿的工作量证明原理就是，不断尝试计算区块的哈希，直到计算出一个特定的哈希值，它比难度值要小。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于比特币挖矿来说，就是先给定一个难度值，然后不断变换&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;，计算Block Hash，直到找到一个比给定难度值低的Block Hash，就算成功挖矿。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意，难度值的&lt;em&gt;数值&lt;/em&gt;越小，说明哈希值前面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;越多，计算的难度越大。&lt;/p&gt;

&lt;p&gt;比特币网络的难度是不断变化的，它的难度保证大约每10分钟产生一个区块，而难度值在每2015个区块调整一次：如果区块平均生成时间小于10分钟，说明全网算力增加，难度也会增加，如果区块平均生成时间大于10分钟，说明全网算力减少，难度也会减少。因此，难度随着全网算力的增减会动态调整。&lt;/p&gt;

&lt;p&gt;根据比特币每个区块的难度值和产出时间，就可以推算出整个比特币网络的全网算力。所以比特币的工作量证明被通俗地称之为挖矿。在同一时间，所有矿工都在努力计算下一个区块的哈希。而挖矿难度取决于全网总算力的百分比。举个例子，假设小明拥有全网总算力的百分之一，那么他挖到下一个区块的可能性就是1%，或者说，每挖出100个区块，大约有1个就是小明挖的。&lt;/p&gt;

&lt;p&gt;为什么区块可以安全广播？因为Merkle Hash锁定了该区块的所有交易，而该区块的第一个coinbase交易输出地址是该矿工地址。每个矿工在挖矿时产生的区块数据都是不同的，所以无法窃取别人的工作量。&lt;/p&gt;

&lt;p&gt;比特币总量被限制为约2100万个比特币，初始挖矿奖励为每个区块50个比特币，以后每4年减半。&lt;/p&gt;

&lt;h3 id=&quot;分叉&quot;&gt;分叉&lt;/h3&gt;

&lt;p&gt;如果两个矿工在同一时间各自找到了有效区块，注意，这两个区块是不同的，因为coinbase交易不同，所以Merkle Hash不同，区块哈希也不同。但它们只要符合难度值，就都是有效的。这个时候，网络上的其他矿工应该接收哪个区块并添加到区块链的末尾呢？答案是，都有可能。&lt;/p&gt;

&lt;p&gt;但是最终，总有一个分叉首先挖到后续区块，这个时候，由于比特币网络采用最长分叉的共识算法，绿色分叉胜出，蓝色分叉被废弃，整个网络上的所有矿工又会继续在最长的链上继续挖矿。&lt;/p&gt;

&lt;p&gt;由于区块链虽然最终会保持数据一致，但是，一个交易可能被打包到一个后续被孤立的区块中。所以，要确认一个交易被永久记录到区块链中，需要对交易进行确认。如果后续的区块被追加到区块链上，实际上就会对原有的交易进行确认，因为链越长，修改的难度越大。一般来说，经过6个区块确认的交易几乎是不可能被修改的。&lt;/p&gt;

&lt;h2 id=&quot;可编程支付原理&quot;&gt;可编程支付原理&lt;/h2&gt;

&lt;h3 id=&quot;锁定脚本和解锁脚本&quot;&gt;锁定脚本和解锁脚本&lt;/h3&gt;

&lt;p&gt;比特币采用脚本的方式进行可编程支付：通过执行解锁脚本确认某个UTXO的资产可以被私钥持有人转移给其他人。&lt;/p&gt;

&lt;p&gt;比特币的支付实际上并不是直接支付到对方的地址，而是一个脚本，这个脚本的意思是：谁能够提供另外一个脚本，让这两个脚本能顺利执行通过，谁就能花掉这笔钱：&lt;/p&gt;

&lt;p&gt;所以，比特币交易的输出是一个锁定脚本，而下一个交易的输入是一个解锁脚本。必须提供一个解锁脚本，让锁定脚本正确运行，那么该输入有效，就可以花费该输出。&lt;/p&gt;

&lt;p&gt;当小明给小红支付一笔比特币时，实际上小明创建了一个锁定脚本，该锁定脚本中引入了小红的地址。要想通过解锁脚本花费该输出，只有持有对应私钥的小红才能创建正确的解锁脚本（因为解锁脚本包含的签名只有小红的私钥才能创建），因此，小红事实上拥有了花费该输出的权利。&lt;/p&gt;

&lt;p&gt;使用钱包软件创建的交易都是标准的支付脚本，但是，比特币的交易本质是成功执行解锁脚本和锁定脚本，所以，可以编写各种符合条件的脚本。比如，有人创建了一个交易，它的锁定脚本像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;OP_HASH256
      DATA 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000
  OP_EQUAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这有点像一个数学谜题。它的意思是说，谁能够提供一个数据，它的hash256等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6fe28c0a...&lt;/code&gt;，谁就可以花费这笔输出。所以，解锁脚本实际上只需要提供一个正确的数据，就可以花费这笔输出。点&lt;a href=&quot;https://btc.com/a4bfa8ab6435ae5f25dae9d89e4eb67dfa94283ca751f393c1ddc5a837bbc31b&quot;&gt;这里&lt;/a&gt;查看谁花费了该输出。&lt;/p&gt;

&lt;p&gt;比特币的脚本通过不同的指令还可以实现更灵活的功能。例如，多重签名可以让一笔交易只有在多数人同意的情况下才能够进行。最常见的多重签名脚本可以提供3个签名，只要任意两个签名被验证成功，这笔交易就可以成功。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;FROM: UTXO Hash#index
AMOUNT: 10.5 btc
TO: P2SH: OP_2 pk1 pk2 pk3 OP_3 OP_CHECKMULTISIG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，3个人中，只要任意两个人同意用他们的私钥提供签名，就可以完成交易。这种方式也可以一定程度上防止丢失私钥的风险。3个人中如果只有一个人丢失了私钥，仍然可以保证这笔输出是可以被花费的。&lt;/p&gt;

&lt;p&gt;比特币的脚本不含条件判断、循环等复杂结构。上述脚本就是对输入的两个数据视作签名和公钥，然后先验证公钥哈希是否与地址相同，再根据公钥验证签名，这种标准脚本称之为P2PKH（Pay to Public Key Hash）脚本。&lt;/p&gt;

&lt;h3 id=&quot;多重签名&quot;&gt;多重签名&lt;/h3&gt;

&lt;p&gt;由比特币的签名机制可知，如果丢失了私钥，没有任何办法可以花费对应地址的资金。&lt;/p&gt;

&lt;p&gt;这样就使得因为丢失私钥导致资金丢失的风险会很高。为了避免一个私钥的丢失导致地址的资金丢失，比特币引入了多重签名机制，可以实现分散风险的功能。&lt;/p&gt;

&lt;p&gt;具体来说，就是假设N个人分别持有N个私钥，只要其中M个人同意签名就可以动用某个“联合地址”的资金。&lt;/p&gt;

&lt;p&gt;发送给多重签名地址的交易创建的是P2SH脚本，而花费多重签名地址的资金需要的脚本就是M个签名+Redeem Script。&lt;/p&gt;

&lt;p&gt;注意：从多重签名的地址本身并无法得知该多重签名使用的公钥，以及M-N的具体数值。必须将Redeem Script公示给每个私钥持有人，才能够验证多重签名地址是否正确（即包含了所有人的公钥，以及正确的M-N数值）。要花费多重签名地址的资金，除了M个私钥签名外，必须要有Redeem Script（可由所有人的公钥构造）。只有签名，没有Redeem Script是不能构造出解锁脚本来花费资金的。因此，保存多重签名地址的钱包必须同时保存Redeem Script。&lt;/p&gt;

&lt;p&gt;利用多重签名，可以实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1-2，两人只要有一人同意即可使用资金；&lt;/li&gt;
  &lt;li&gt;2-2，两人必须都同意才可使用资金；&lt;/li&gt;
  &lt;li&gt;2-3，3人必须至少两人同意才可使用资金；&lt;/li&gt;
  &lt;li&gt;4-7，7人中多数人同意才可使用资金。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最常见的多重签名是2-3类型。例如，一个提供在线钱包的服务，为了防止服务商盗取用户的资金，可以使用2-3类型的多重签名地址，服务商持有1个私钥，用户持有两个私钥，一个作为常规使用，一个作为应急使用。这样，正常情况下，用户只需使用常规私钥即可配合服务商完成正常交易，服务商因为只持有1个私钥，因此无法盗取用户资金。如果服务商倒闭或者被黑客攻击，用户可使用自己掌握的两个私钥转移资金。&lt;/p&gt;

&lt;p&gt;大型机构的比特币通常都使用多重签名地址以保证安全。&lt;/p&gt;

&lt;p&gt;利用多重签名，可以使得私钥丢失的风险被分散到N个人手中，并且，避免了少数人窃取资金的问题。&lt;/p&gt;

&lt;p&gt;比特币的多重签名最多允许15个私钥参与签名，即可实现1-2至15-15的任意组合（1⩽M⩽N⩽15）。&lt;/p&gt;

&lt;p&gt;多重签名可以实现N个人持有私钥，其中M个人同意即可花费资金的功能。&lt;/p&gt;

&lt;p&gt;多重签名降低了单个私钥丢失的风险。&lt;/p&gt;

&lt;p&gt;支付比特币到一个多重签名地址实际上是创建一个P2SH输出。&lt;/p&gt;

&lt;h2 id=&quot;utxo模型&quot;&gt;UTXO模型&lt;/h2&gt;

&lt;p&gt;比特币的区块链由一个个区块串联构成，而每个区块又包含一个或多个交易。&lt;/p&gt;

&lt;p&gt;如果我们观察任何一个交易，它总是由若干个输入（Input）和若干个输出（Output）构成，一个Input指向的是前面区块的某个Output，只有Coinbase交易（矿工奖励的铸币交易）没有输入，只有凭空输出。所以，任何交易，总是可以由Input溯源到Coinbase交易。&lt;/p&gt;

&lt;p&gt;这些交易的Input和Output总是可以串联起来：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│Block #1     │     │Block #2     │     │Block #3     │     │Block #4     │
│┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│
││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT││
│└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│
│             │  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│
│             │  │  ││  │8.70│OUT├┼──┼──▶│IN│    │   ││  └──▶│IN│25.0│OUT││
│             │  └──▶│IN├────┼───┤│  │  │├──┤58.7│OUT││     │├──┼────┼───┤│
│             │     ││  │41.3│OUT├┼─┐└──▶│IN│    │   ││  ┌──▶│IN│66.3│OUT││
│             │     │└──┴────┴───┘│ │   │└──┴────┴───┘│  │  │└──┴────┴───┘│
└─────────────┘     └─────────────┘ │   └─────────────┘  │  └─────────────┘
                                    └────────────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还没有被下一个交易花费的Output被称为UTXO：Unspent TX Output，即未花费交易输出。给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和。&lt;/p&gt;

&lt;p&gt;因此，比特币的交易模型和我们平时使用的银行账号有所不同，它并没有账户这个说法，只有UTXO。想要确定某个人拥有的比特币，并无法通过某个账户查到，必须知道此人控制的所有UTXO金额之和。&lt;/p&gt;

&lt;p&gt;在钱包程序中，钱包管理的是一组私钥，对应的是一组公钥和地址。钱包程序必须从创世区块开始扫描每一笔交易，如果：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；&lt;/li&gt;
  &lt;li&gt;遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;钱包的当前余额总是钱包地址关联的所有UTXO金额之和。&lt;/p&gt;

&lt;p&gt;如果刚装了一个新钱包，导入了一组私钥，在钱包扫描完整个比特币区块之前，是无法得知当前管理的地址余额的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;比特币区块链本质上是不可修改的“修改日志”（类似 MySQL 的 binlog），记录的是交易变更而非账户状态。&lt;/li&gt;
  &lt;li&gt;要高效查询余额，需先重放所有区块交易，构建本地“地址-余额”状态数据库，钱包多使用 LevelDB 存储该状态。  重建整个地址-余额数据库需要扫描整个区块链，并按每个交易依次更新记录，即可得到当前状态。&lt;/li&gt;
  &lt;li&gt;实时余额查询并不读取区块链原始数据，而是查本地已构建的状态表或由服务器返回查询结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hd钱包&quot;&gt;HD钱包&lt;/h2&gt;

&lt;h3 id=&quot;派生私钥&quot;&gt;派生私钥&lt;/h3&gt;

&lt;p&gt;在比特币的链上，实际上并没有账户的概念，某个用户持有的比特币，实际上是其控制的一组UTXO，而这些UTXO可能是相同的地址（对应相同的私钥），也可能是不同的地址（对应不同的私钥）。&lt;/p&gt;

&lt;p&gt;出于保护隐私的目的，同一用户如果控制的UTXO其地址都是不同的，那么很难从地址获知某个用户的比特币持币总额。但是，管理一组成千上万的地址，意味着管理成千上万的私钥，管理起来非常麻烦。&lt;/p&gt;

&lt;p&gt;能不能只用一个私钥管理成千上万个地址？实际上是可以的。虽然椭圆曲线算法决定了一个私钥只能对应一个公钥，但是，可以通过某种确定性算法，先确定一个私钥k1，然后计算出k2、k3、k4……等其他私钥，就相当于只需要管理一个私钥，剩下的私钥可以按需计算出来。&lt;/p&gt;

&lt;p&gt;这种根据某种确定性算法，只需要管理一个根私钥，即可实时计算所有“子私钥”的管理方式，称为HD钱包。&lt;/p&gt;

&lt;p&gt;HD是Hierarchical Deterministic的缩写，意思是分层确定性。先确定根私钥root，然后根据索引计算每一层的子私钥：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root
│
├─────────────┬─────────────┐
│             │             │
▼             ▼             ▼
k0            k1            k2 ...
│             │             │
├──┬──┐       ├──┬──┐       ├──┬──┐
│  │  │       │  │  │       │  │  │
▼  ▼  ▼       ▼  ▼  ▼       ▼  ▼  ▼
k0 k1 k2 ...  k0 k1 k2 ...  k0 k1 k2 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于任意一个私钥k，总是可以根据索引计算它的下一层私钥kn&lt;/p&gt;

&lt;p&gt;HD钱包采用的计算子私钥的算法并不是一个简单的SHA-256，私钥也不是普通的256位ECDSA私钥，而是一个扩展的512位私钥，记作xprv，它通过SHA-512算法配合ECC计算出子扩展私钥，仍然是512位。通过扩展私钥可计算出用于签名的私钥以及公钥。&lt;/p&gt;

&lt;p&gt;简单来说，只要给定一个根扩展私钥（随机512位整数），即可计算其任意索引的子扩展私钥。扩展私钥总是能计算出扩展公钥，记作xpub&lt;/p&gt;

&lt;p&gt;从xprv及其对应的xpub可计算出真正用于签名的私钥和公钥。之所以要设计这种算法，是因为扩展公钥xpub也有一个特点，那就是可以直接计算其子层级的扩展公钥&lt;/p&gt;

&lt;p&gt;因为xpub只包含公钥，不包含私钥，因此，可以安全地把xpub交给第三方（例如，一个观察钱包），它可以根据xpub计算子层级的所有地址，然后在比特币的链上监控这些地址的余额，但因为没有私钥，所以只能看，不能花。&lt;/p&gt;

&lt;p&gt;因此，HD钱包通过分层确定性算法，实现了以下功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只要确定了扩展私钥xprv，即可根据索引计算下一层的任何扩展私钥；&lt;/li&gt;
  &lt;li&gt;只要确定了扩展公钥xpub，即可根据索引计算下一层的任何扩展公钥；&lt;/li&gt;
  &lt;li&gt;用户只需保存顶层的一个扩展私钥，即可计算出任意一层的任意索引的扩展私钥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从理论上说，扩展私钥的层数是没有限制的，每一层的数量被限制在0～232，原因是扩展私钥中只有4字节作为索引，因此索引范围是0～232。&lt;/p&gt;

&lt;p&gt;通常把根扩展私钥记作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;，子扩展私钥按层级记作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/x/y/z&lt;/code&gt;等：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m
│
├──────────────────────┐
│                      │
▼                      ▼
m/0                    m/1 ...
│                      │
├─────┬─────┐          ├─────┬─────┐
│     │     │          │     │     │
▼     ▼     ▼          ▼     ▼     ▼
m/0/0 m/0/1 m/0/2 ...  m/1/0 m/1/1 m/1/2 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/0/2&lt;/code&gt;表示从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;扩展到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/0&lt;/code&gt;（索引为0）再扩展到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/0/2&lt;/code&gt;（索引为2）。&lt;/p&gt;

&lt;p&gt;但是HD钱包的扩展私钥算法有个潜在的安全性问题，就是如果某个层级的xprv泄露了，可反向推导出上层的xprv，继而推导出整个HD扩展私钥体系。为了避免某个子扩展私钥的泄漏导致上层扩展私钥被反向推导，HD钱包还有一种硬化的衍生计算方式（Hardened Derivation），它通过算法“切断”了母扩展私钥和子扩展私钥的反向推导。HD规范把索引0～231作为普通衍生索引，而索引231～232作为硬化衍生索引，硬化衍生索引通常记作0’、1’、2’……，即索引0’=231，1’=231+1，2’=231+2，以此类推。&lt;/p&gt;

&lt;p&gt;因此，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;/0&lt;/code&gt;表示的子扩展私钥，它的第一层衍生索引&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;44&apos;&lt;/code&gt;是硬化衍生，实际索引是231+44=2147483692。从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;&lt;/code&gt;无法反向推导出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在只有扩展公钥的情况下，只能计算出普通衍生的子公钥，无法计算出硬化衍生的子扩展公钥，即可计算出的子扩展公钥索引被限制在0～231。因此，观察钱包能使用的索引是0～231。&lt;/p&gt;

&lt;h3 id=&quot;硬化派生-vs-普通派生bip-32&quot;&gt;硬化派生 vs 普通派生（BIP-32）&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;普通派生（Normal）&lt;/th&gt;
      &lt;th&gt;硬化派生（Hardened）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;索引范围&lt;/td&gt;
      &lt;td&gt;0 ～ 2³¹ - 1&lt;/td&gt;
      &lt;td&gt;2³¹ ～ 2³² - 1（如 44’ 实为 2147483692）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;输入&lt;/td&gt;
      &lt;td&gt;父 &lt;strong&gt;公钥&lt;/strong&gt; + 子索引.&lt;br /&gt;m/0      ← 子索引 0&lt;br /&gt;m/1      ← 子索引 1&lt;br /&gt;m/2      ← 子索引 2&lt;/td&gt;
      &lt;td&gt;父 &lt;strong&gt;私钥&lt;/strong&gt; + 子索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;是否可逆&lt;/td&gt;
      &lt;td&gt;❌ 子私钥可推出父公钥，可能有风险&lt;/td&gt;
      &lt;td&gt;✅ 子私钥无法推出父密钥或公钥&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;适用场景&lt;/td&gt;
      &lt;td&gt;创建公钥链（如观察钱包）&lt;/td&gt;
      &lt;td&gt;增强安全性，防止私钥泄露推导父密钥&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;安全性&lt;/td&gt;
      &lt;td&gt;较低（若子私钥泄露 + 父公钥 → 推导父私钥）&lt;/td&gt;
      &lt;td&gt;高（子私钥无父密钥信息）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;常用路径&lt;/td&gt;
      &lt;td&gt;如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/0/1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;/0&apos;/0&apos;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;普通派生&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ChildPubKey&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ParentPubKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;可生成&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;观察钱包&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;硬化派生&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ChildPrivKey&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ParentPrivKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;³¹&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;只靠私钥能派生&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;防止反向推导&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;派生标准&quot;&gt;&lt;strong&gt;派生标准&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;比特币的&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki&quot;&gt;BIP-44&lt;/a&gt;规范定义了一种如何派生私钥的标准，它本身非常简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;m / purpose&apos; / coin_type&apos; / account&apos; / change / address_index
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purpose&lt;/code&gt;总是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;44&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coin_type&lt;/code&gt;在&lt;a href=&quot;https://github.com/satoshilabs/slips/blob/master/slip-0044.md&quot;&gt;SLIP-44&lt;/a&gt;中定义，例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0=BTC&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2=LTC&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;60=ETH&lt;/code&gt;等。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account&lt;/code&gt;表示用户的某个“账户”，由用户自定义索引，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change=0&lt;/code&gt;表示外部交易，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change=1&lt;/code&gt;表示内部交易，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address_index&lt;/code&gt;则是真正派生的索引为0～231的地址。&lt;/p&gt;

&lt;p&gt;例如，某个比特币钱包给用户创建的一组HD地址实际上是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;m/44’/0’/0’/0/0&lt;/li&gt;
  &lt;li&gt;m/44’/0’/0’/0/1&lt;/li&gt;
  &lt;li&gt;m/44’/0’/0’/0/2&lt;/li&gt;
  &lt;li&gt;m/44’/0’/0’/0/3&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果是莱特币钱包，则用户的HD地址是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;m/44’/2’/0’/0/0&lt;/li&gt;
  &lt;li&gt;m/44’/2’/0’/0/1&lt;/li&gt;
  &lt;li&gt;m/44’/2’/0’/0/2&lt;/li&gt;
  &lt;li&gt;m/44’/2’/0’/0/3&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;助记词&quot;&gt;助记词&lt;/h3&gt;

&lt;p&gt;BIP-39规范通过使用助记词+口令来生成HD钱包的种子，用户只需记忆助记词和口令即可随时恢复HD钱包。&lt;/p&gt;

&lt;p&gt;丢失助记词或者丢失口令均会导致HD钱包丢失。&lt;/p&gt;

&lt;p&gt;助记词是一组人类可读的单词，用于表示一个随机数种子，能&lt;strong&gt;恢复整个 HD 钱包的所有私钥、公钥和地址&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;legal&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;winner&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;thank&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;wave&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;sausage&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;worth&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;useful&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;legal&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;winner&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;thank&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;yellow&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;常见长度有：12 / 15 / 18 / 21 / 24 个单词&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;种子和助记词的关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 BIP-39 标准中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;助记词（mnemonic words）&lt;/strong&gt; 是 12/15/18/24 个词的人类可读表示&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;助记词 → 通过 PBKDF2 → 派生出 512 位的种子&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;种子 → 用于生成 HD 钱包的根密钥（m）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
助记词词组（24词） 
→ PBKDF2 加盐派生 
→ 生成种子（512位） 
→ BIP-32 生成根私钥 m 
→ 派生整个 HD 钱包树
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;地址监控&quot;&gt;地址监控&lt;/h3&gt;

&lt;p&gt;一个HD钱包管理的是一组自动计算的地址。以比特币为例，在确定了根扩展私钥&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;后，得到一组地址为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m/44&apos;/0&apos;/0&apos;/0/x&lt;/code&gt;，其中x=0~231。&lt;/p&gt;

&lt;p&gt;HD钱包需要在链上监控每个TX的输入和输出，看看上述管理的一组地址是否存在与输入和输出中。如果作为输入，则钱包余额减少，如果作为输出，则钱包余额增加。&lt;/p&gt;

&lt;p&gt;现在问题来了：如何根据TX的输入和输出地址快速判断这些地址中是否存在HD钱包管理的地址？&lt;/p&gt;

&lt;p&gt;首先，可用的地址高达231个，这个数太大了，用户不可能用完，因此，HD钱包只会预生成前1000个地址（即索引号为0～999）并保存在本地数据库中，如果不够了，再继续扩展1000个，这样，HD钱包管理的地址数量不会太大。&lt;/p&gt;

&lt;p&gt;要做到高效的查询和低空间占用率，可以使用布隆过滤器（Bloom Filter），它是由Burton Howard Bloom在1970年提出的，其原理是将每个元素通过若干个哈希函数映射成一个位数组的若干个点，将其置1。检索的时候，先计算给定元素对应位是否全1，如果是全1，则给定元素很可能存在，否则，元素必定不存在。&lt;/p&gt;

&lt;p&gt;因此，Bloom Filter有个重要特点，就是判断元素时，如果不存在，那么肯定不存在，如果存在，实际上是以一定概率存在（例如，99%），还需要再次从数据库查询以确定元素真的存在。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">区块链入门 比特币技术</summary></entry><entry><title type="html">远程</title><link href="https://mafulong.github.io/2025/07/09/%E8%BF%9C%E7%A8%8B/" rel="alternate" type="text/html" title="远程" /><published>2025-07-09T00:00:00+08:00</published><updated>2025-07-09T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/07/09/%E8%BF%9C%E7%A8%8B</id><content type="html" xml:base="https://mafulong.github.io/2025/07/09/%E8%BF%9C%E7%A8%8B/">&lt;h2 id=&quot;远程&quot;&gt;远程&lt;/h2&gt;

&lt;p&gt;Web3 远程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;猎头&lt;/li&gt;
  &lt;li&gt;电鸭社区&lt;/li&gt;
  &lt;li&gt;Brix&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">远程</summary></entry><entry><title type="html">浦东公租房</title><link href="https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF/" rel="alternate" type="text/html" title="浦东公租房" /><published>2025-05-15T00:00:00+08:00</published><updated>2025-05-15T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF</id><content type="html" xml:base="https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF/">&lt;h2 id=&quot;公租房&quot;&gt;公租房&lt;/h2&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/720027504&lt;/p&gt;

&lt;h2 id=&quot;浦东地图&quot;&gt;浦东地图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505152350009.png&quot; alt=&quot;image-20250515235026893&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;房源&quot;&gt;房源&lt;/h2&gt;

&lt;h3 id=&quot;公租房-1&quot;&gt;公租房&lt;/h3&gt;

&lt;h4 id=&quot;仁文公寓&quot;&gt;仁文公寓&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=9765&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3700&lt;/strong&gt;元/月 53平。&lt;/p&gt;

&lt;p&gt;一室一厅，停车300一月。&lt;/p&gt;

&lt;p&gt;靠近二甲 上海明珠医院。&lt;/p&gt;

&lt;p&gt;48分钟，41km， 26分钟。&lt;/p&gt;

&lt;h4 id=&quot;浦三路930弄-艾东苑&quot;&gt;浦三路930弄 艾东苑&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=8613486F-AA0F-4AD6-9BD1-B6D62BCFA29B&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;49.87&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4128&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;48分钟，44km，17分钟，12km.&lt;/p&gt;

&lt;h4 id=&quot;川和路399弄张江兴科苑&quot;&gt;川和路399弄（张江兴科苑）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;4081&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;47.72&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 205&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-03-16&lt;/li&gt;
  &lt;li&gt;地址： 川和路399弄（张江兴科苑）/11-12号/02楼/205&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没有车位。&lt;/p&gt;

&lt;p&gt;52分钟，48km， 14分钟，4.5km。&lt;/p&gt;

&lt;h3 id=&quot;公租房三林&quot;&gt;公租房三林&lt;/h3&gt;

&lt;h4 id=&quot;三舒路-城林美苑&quot;&gt;三舒路 城林美苑&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=706833db-607b-4f3c-846b-96f144c516d7&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2850&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;67.55&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 08楼&lt;/p&gt;

&lt;p&gt;房号： 806&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 三舒路33弄（城林美苑）/04号/08楼/806&lt;/li&gt;
  &lt;li&gt;室内配套：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;52 分 ，18km, 32 分钟。&lt;/p&gt;

&lt;h4 id=&quot;永泰路136弄&quot;&gt;永泰路136弄&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=B3EC3477-2161-4A31-8441-ACD494761328&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2963&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：2准入资格证202517140007390 （2025-05-19）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;51.61&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 203&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 永泰路136弄/33号/2楼/203&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;56mins, 27mins.&lt;/p&gt;

&lt;h4 id=&quot;三旋路506弄绿波家园&quot;&gt;三旋路506弄（绿波家园&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=34BE3519-D644-4915-AC8F-DE4864AF83FB&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2793&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：9准入资格证202317140008848 （2023-06-07）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;64.99&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 21楼&lt;/p&gt;

&lt;p&gt;房号： 2104&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 三旋路506弄（绿波家园）/19号/21楼/2104&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;52mins, 31mins。&lt;/p&gt;

&lt;h4 id=&quot;杨南路&quot;&gt;杨南路&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=8633&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3365&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：2准入资格证202317140018617 （2023-11-30）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;56.80&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 202&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 杨南路694弄/81号/2楼/202&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;55mins, 25mins&lt;/p&gt;

&lt;h4 id=&quot;和炯路77弄盛世南苑&quot;&gt;和炯路77弄（盛世南苑）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;2633&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：6准入资格证202317140009994 （2023-06-25）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;65.26&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 01楼&lt;/p&gt;

&lt;p&gt;房号： 101&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-09&lt;/li&gt;
  &lt;li&gt;地址： 和炯路77弄（盛世南苑）/13号/1楼/101&lt;/li&gt;
  &lt;li&gt;室内配套：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;55mins, 32mins&lt;/p&gt;

&lt;h3 id=&quot;非公租房&quot;&gt;非公租房&lt;/h3&gt;

&lt;h4 id=&quot;高科苑&quot;&gt;高科苑&lt;/h4&gt;

&lt;p&gt;高科苑，就在复旦大学和曙光医院旁边，距离中科路不远，这个小区环境不错，可以租一室一厅&lt;/p&gt;

&lt;p&gt;小区没有二房东，是张江高科集团建的对外出租，不存在二房东改造问题&lt;/p&gt;

&lt;p&gt;地下车库地上车库都有，停车费也不贵&lt;/p&gt;

&lt;p&gt;52分钟，50km, 距离公司 3km&lt;/p&gt;

&lt;h4 id=&quot;张江万科翡翠公园&quot;&gt;张江万科翡翠公园&lt;/h4&gt;

&lt;p&gt;53分钟，50km, 14分钟，4.5km。&lt;/p&gt;

&lt;h3 id=&quot;保租房&quot;&gt;保租房&lt;/h3&gt;

&lt;h4 id=&quot;纳仕&quot;&gt;纳仕&lt;/h4&gt;

&lt;p&gt;纳什国际，新的&lt;/p&gt;

&lt;p&gt;贵的不行&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="DailyLife" /><category term="DailyLife" /><summary type="html">公租房</summary></entry><entry><title type="html">Spring AOP</title><link href="https://mafulong.github.io/2025/05/06/Spring-AOP/" rel="alternate" type="text/html" title="Spring AOP" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20AOP</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-AOP/">&lt;h2 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h2&gt;

&lt;h2 id=&quot;谈谈自己对于-aop-的了解&quot;&gt;谈谈自己对于 AOP 的了解&lt;/h2&gt;

&lt;p&gt;AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。&lt;/p&gt;

&lt;p&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;

&lt;p&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;strong&gt;JDK Proxy&lt;/strong&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;strong&gt;Cglib&lt;/strong&gt; 生成一个被代理对象的子类来作为代理&lt;/p&gt;

&lt;p&gt;当然你也可以使用 &lt;strong&gt;AspectJ&lt;/strong&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;

&lt;p&gt;AOP 切面编程涉及到的一些专业术语：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;术语&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;目标(Target)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被通知的对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代理(Proxy)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;连接点(JoinPoint)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切入点(Pointcut)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通知(Advice)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切面(Aspect)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Weaving(织入)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Spring&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AOP&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AspectJ&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;注解&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;如&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;来声明切面&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;它是单独的aop框架&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;可以在非spring里使用&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;和spring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aop是两套&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;它是编译时织入&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使用代理方式实现&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AOP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JDK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;动态代理&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;接口型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CGLIB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;动态代理&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;类型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;aop-常见的通知类型有哪些&quot;&gt;AOP 常见的通知类型有哪些？&lt;/h2&gt;

&lt;p&gt;AOP 一般有 &lt;strong&gt;5 种&lt;/strong&gt;环绕方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前置通知 (@Before)&lt;/li&gt;
  &lt;li&gt;返回通知 (@AfterReturning)&lt;/li&gt;
  &lt;li&gt;异常通知 (@AfterThrowing)&lt;/li&gt;
  &lt;li&gt;后置通知 (@After)&lt;/li&gt;
  &lt;li&gt;环绕通知 (@Around)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062358585.png&quot; alt=&quot;三分恶面渣逆袭：环绕方式&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;aspectj-是什么&quot;&gt;AspectJ 是什么？&lt;/h2&gt;

&lt;h3 id=&quot;aspectj&quot;&gt;AspectJ&lt;/h3&gt;

&lt;p&gt;AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 表示这是一个切面类&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Spring 管理该类的 Bean&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 定义一个切入点，匹配 HelloService 中的所有方法&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Pointcut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;execution(* com.example.demo.HelloService.*(..))&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;helloServiceMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 方法执行之前的通知（Before Advice）&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloServiceMethods()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logBefore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Method is about to execute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 方法执行之后的通知（After Advice）&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@After&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloServiceMethods()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logAfter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Method has executed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;spring-aop-和-aspectj-aop-有什么区别&quot;&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;Spring AOP&lt;/th&gt;
      &lt;th&gt;AspectJ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;增强方式&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时增强（基于动态代理）&lt;/td&gt;
      &lt;td&gt;编译时增强、类加载时增强（直接操作字节码）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;切入点支持&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;方法级（Spring Bean 范围内，不支持 final 和 staic 方法）&lt;/td&gt;
      &lt;td&gt;方法级、字段、构造器、静态方法等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时依赖代理，有一定开销，切面多时性能较低&lt;/td&gt;
      &lt;td&gt;运行时无代理开销，性能更高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;简单，易用，适合大多数场景&lt;/td&gt;
      &lt;td&gt;功能强大，但相对复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Spring 应用下比较简单的 AOP 需求&lt;/td&gt;
      &lt;td&gt;高性能、高复杂度的 AOP 需求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;如何选择？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能考量&lt;/strong&gt;：AspectJ 支持更复杂的 AOP 场景，Spring AOP 更简单易用。如果你需要增强 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 方法、静态方法、字段访问、构造器调用等，或者需要在非 Spring 管理的对象上应用增强逻辑，AspectJ 是唯一的选择。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能考量&lt;/strong&gt;：切面数量较少时两者性能差异不大，但切面较多时 AspectJ 性能更优。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一句话总结&lt;/strong&gt;：简单场景优先使用 Spring AOP；复杂场景或高性能需求时，选择 AspectJ。&lt;/p&gt;

&lt;p&gt;Spring AOP 属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;运行时增强&lt;/code&gt;，主要具有如下特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现&lt;/li&gt;
  &lt;li&gt;Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现&lt;/li&gt;
  &lt;li&gt;在性能上，由于 Spring AOP 是基于&lt;strong&gt;动态代理&lt;/strong&gt;来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。&lt;/li&gt;
  &lt;li&gt;Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AspectJ 是一个易用的功能强大的 AOP 框架，属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;编译时增强&lt;/code&gt;， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。&lt;/p&gt;

&lt;p&gt;AspectJ 属于&lt;strong&gt;静态织入&lt;/strong&gt;，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。&lt;/li&gt;
  &lt;li&gt;编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。&lt;/li&gt;
  &lt;li&gt;类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sprint-aop&quot;&gt;Sprint AOP&lt;/h2&gt;

&lt;h3 id=&quot;spring-aop-发生在什么时候&quot;&gt;Spring AOP 发生在什么时候？&lt;/h3&gt;

&lt;p&gt;Spring AOP 基于运行时代理机制，这意味着 Spring AOP 是在运行时通过动态代理生成的，而不是在编译时或类加载时生成的。&lt;/p&gt;

&lt;p&gt;在 Spring 容器初始化 Bean 的过程中，Spring AOP 会检查 Bean 是否需要应用切面。如果需要，Spring 会为该 Bean 创建一个代理对象，并在代理对象中织入切面逻辑。这一过程发生在 Spring 容器的后处理器（BeanPostProcessor）阶段。&lt;/p&gt;

&lt;h3 id=&quot;说说-jdk-动态代理和-cglib-代理&quot;&gt;说说 JDK 动态代理和 CGLIB 代理？&lt;/h3&gt;

&lt;p&gt;AOP 是通过&lt;a href=&quot;https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg&quot;&gt;动态代理&lt;/a&gt;实现的，代理方式有两种：JDK 动态代理和 CGLIB 代理。&lt;/p&gt;

&lt;p&gt;①、JDK 动态代理是基于接口的代理，只能代理实现了接口的类。&lt;/p&gt;

&lt;p&gt;使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：只需依赖 JDK 自带的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类，不需要额外的库；缺点：只能代理接口，不能代理类本身。&lt;/p&gt;

&lt;p&gt;②、CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。&lt;/p&gt;

&lt;p&gt;使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：可以代理没有实现接口的类，灵活性更高；缺点：需要依赖 CGLIB 库，创建代理对象的开销相对较大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;只能代理实现了接口的类。它的实现基于 Java 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InvocationHandler&lt;/code&gt; 接口，&lt;strong&gt;运行时在内存中动态生成代理类的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 文件并加载执行&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;JDK Proxy 是通过在内存中动态创建一个实现了同样接口的代理类来“代理”目标对象的方法调用。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;比较维度&lt;/th&gt;
      &lt;th&gt;JDK 动态代理&lt;/th&gt;
      &lt;th&gt;CGLIB 动态代理&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;代理对象&lt;/td&gt;
      &lt;td&gt;必须实现接口&lt;/td&gt;
      &lt;td&gt;不需要接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;实现方式&lt;/td&gt;
      &lt;td&gt;JDK Proxy + 反射&lt;/td&gt;
      &lt;td&gt;继承 + 字节码增强&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;性能（早期）&lt;/td&gt;
      &lt;td&gt;较低&lt;/td&gt;
      &lt;td&gt;较高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;限制&lt;/td&gt;
      &lt;td&gt;不能代理类本身&lt;/td&gt;
      &lt;td&gt;不能代理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 类/方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Spring 默认策略&lt;/td&gt;
      &lt;td&gt;有接口：JDK 动态代理无接口：CGLIB&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;选择-cglib-还是-jdk-动态代理&quot;&gt;选择 CGLIB 还是 JDK 动态代理？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果目标对象没有实现任何接口，则只能使用 CGLIB 代理。如果目标对象实现了接口，通常首选 JDK 动态代理。&lt;/li&gt;
  &lt;li&gt;虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能。对于性能敏感且代理对象创建频率不高的场景，可以考虑使用 CGLIB。&lt;/li&gt;
  &lt;li&gt;JDK 动态代理是 Java 原生支持的，不需要额外引入库。而 CGLIB 需要将 CGLIB 库作为依赖加入项目中。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring AOP</summary></entry><entry><title type="html">Spring IoC</title><link href="https://mafulong.github.io/2025/05/06/Spring-IoC/" rel="alternate" type="text/html" title="Spring IoC" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20IoC</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-IoC/">&lt;h2 id=&quot;sprint-ioc&quot;&gt;Sprint IoC&lt;/h2&gt;

&lt;h3 id=&quot;谈谈自己对于-spring-ioc-的了解&quot;&gt;谈谈自己对于 Spring IoC 的了解&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IoC（Inversion of Control:控制反转）&lt;/strong&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么叫控制反转？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;控制&lt;/strong&gt;：指的是对象创建（实例化、管理）的权力&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;反转&lt;/strong&gt;：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;

&lt;p&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;

&lt;p&gt;IOC 是一种思想，&lt;strong&gt;DI&lt;/strong&gt; 是实现 IOC 的具体方式，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。&lt;/p&gt;

&lt;h3 id=&quot;将一个类声明为-bean-的注解有哪些&quot;&gt;将一个类声明为 Bean 的注解有哪些?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;：通用的注解，可标注任意类为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 组件。如果一个 Bean 不知道属于哪个层，可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解标注。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Repository&lt;/code&gt; : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service&lt;/code&gt; : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt; : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 层返回数据给前端页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;component-和-bean-的区别是什么&quot;&gt;@Component 和 @Bean 的区别是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注入-bean-的注解有哪些&quot;&gt;注入 Bean 的注解有哪些？&lt;/h3&gt;

&lt;p&gt;Spring 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 以及 JDK 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Annotation&lt;/th&gt;
      &lt;th&gt;Package&lt;/th&gt;
      &lt;th&gt;Source&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;org.springframework.bean.factory&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Spring 2.5+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.annotation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-250&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-330&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;使用的比较多一些。&lt;/p&gt;

&lt;p&gt;推荐构造函数注入。&lt;/p&gt;

&lt;h3 id=&quot;autowired-和-resource-的区别是什么&quot;&gt;@Autowired 和 @Resource 的区别是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;
  &lt;li&gt;当一个接口存在多个实现类的情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;都需要通过名称才能正确匹配到对应的 Bean。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Qualifier&lt;/code&gt; 注解来显式指定名称，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 属性来显式指定名称。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 支持在构造函数、方法、字段和参数上使用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注入-bean-的方式有哪些&quot;&gt;注入 Bean 的方式有哪些？&lt;/h3&gt;

&lt;p&gt;依赖注入 (Dependency Injection, DI) 的常见方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造函数注入：通过类的构造函数来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Setter 注入：通过类的 Setter 方法来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Field（字段） 注入：直接在类的字段上使用注解（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;）来注入依赖项。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Spring 官方推荐构造函数注入&lt;/strong&gt;，这种注入方式的优势如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。&lt;/li&gt;
  &lt;li&gt;不可变性：有助于创建不可变对象，提高了线程安全性。&lt;/li&gt;
  &lt;li&gt;初始化保证：组件在使用前已完全初始化，减少了潜在的错误。&lt;/li&gt;
  &lt;li&gt;测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;构造函数注入适合处理&lt;strong&gt;必需的依赖项&lt;/strong&gt;，而 &lt;strong&gt;Setter 注入&lt;/strong&gt; 则更适合&lt;strong&gt;可选的依赖项&lt;/strong&gt;，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。&lt;/p&gt;

&lt;p&gt;在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是&lt;strong&gt;唯一的选择&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;bean-的作用域有哪些&quot;&gt;Bean 的作用域有哪些?&lt;/h3&gt;

&lt;p&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;singleton&lt;/strong&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean()&lt;/code&gt; 两次，得到的是不同的 Bean 实例。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;request&lt;/strong&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;session&lt;/strong&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;application/global-session&lt;/strong&gt; （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;websocket&lt;/strong&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bean-的生命周期了解么&quot;&gt;Bean 的生命周期了解么?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;创建 Bean 的实例&lt;/strong&gt;：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bean 属性赋值/填充&lt;/strong&gt;：为 Bean 设置相关属性和依赖，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 等注解注入的对象、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Value&lt;/code&gt; 注入的值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法或构造函数注入依赖和值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;注入的各种资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bean 初始化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。
     - 如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;与上面的类似，如果实现了其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterPropertiesSet()&lt;/code&gt;方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 属性，执行指定的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessAfterInitialization()&lt;/code&gt; 方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;销毁 Bean&lt;/p&gt;

    &lt;p&gt;：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 接口，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy()&lt;/code&gt; 方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy-method&lt;/code&gt; 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PreDestroy&lt;/code&gt; 注解标记 Bean 销毁之前执行的方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bean 的生命周期大致分为五个阶段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062341884.png&quot; alt=&quot;三分恶面渣逆袭：Bean生命周期五个阶段&quot; /&gt;三分恶面渣逆袭：Bean生命周期五个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;实例化&lt;/strong&gt;：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;属性赋值&lt;/strong&gt;：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为依赖注入，确保 Bean 所需的所有依赖都被注入。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用中&lt;/strong&gt;：Bean 准备好可以使用了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;销毁&lt;/strong&gt;：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何记忆呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整体上可以简单分为四步：实例化 —&amp;gt; 属性赋值 —&amp;gt; 初始化 —&amp;gt; 销毁。&lt;/li&gt;
  &lt;li&gt;初始化这一步涉及到的步骤比较多，包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aware&lt;/code&gt; 接口的依赖注入、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 在初始化前后的处理以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 的初始化操作。&lt;/li&gt;
  &lt;li&gt;销毁这一步会注册相关销毁回调接口，最后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destory-method&lt;/code&gt; 进行销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再分享一张清晰的图解（图源：&lt;a href=&quot;https://chaycao.github.io/2020/02/15/如何记忆Spring-Bean的生命周期.html&quot;&gt;如何记忆 Spring Bean 的生命周期&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062339187.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-中的单例-bean-会存在线程安全问题吗&quot;&gt;Spring 中的单例 Bean 会存在线程安全问题吗？&lt;/h3&gt;

&lt;p&gt;Spring Bean 的默认作用域是单例（Singleton），这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会被多个线程共享。&lt;/p&gt;

&lt;p&gt;如果单例 Bean 是无状态的，也就是没有成员变量，那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，基本上都是无状态的。&lt;/p&gt;

&lt;p&gt;但如果 Bean 的内部状态是可变的，且没有进行适当的同步处理，就可能出现线程安全问题。&lt;/p&gt;

&lt;p&gt;对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;避免可变成员变量&lt;/strong&gt;: 尽量设计 Bean 为无状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;&lt;/strong&gt;: 将可变成员变量保存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 中，确保线程独立。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用同步机制&lt;/strong&gt;: 利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 来进行同步控制，确保线程安全。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Sprint IoC</summary></entry></feed>