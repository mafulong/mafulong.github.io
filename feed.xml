<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://mafulong.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mafulong.github.io/" rel="alternate" type="text/html" /><updated>2025-05-07T15:10:45+08:00</updated><id>https://mafulong.github.io/feed.xml</id><title type="html">Fulongのblog</title><subtitle>Fulongのblog</subtitle><author><name>Fulong Ma</name></author><entry><title type="html">Spring AOP</title><link href="https://mafulong.github.io/2025/05/06/Spring-AOP/" rel="alternate" type="text/html" title="Spring AOP" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20AOP</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-AOP/">&lt;h2 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h2&gt;

&lt;h2 id=&quot;谈谈自己对于-aop-的了解&quot;&gt;谈谈自己对于 AOP 的了解&lt;/h2&gt;

&lt;p&gt;AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。&lt;/p&gt;

&lt;p&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;

&lt;p&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;strong&gt;JDK Proxy&lt;/strong&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;strong&gt;Cglib&lt;/strong&gt; 生成一个被代理对象的子类来作为代理&lt;/p&gt;

&lt;p&gt;当然你也可以使用 &lt;strong&gt;AspectJ&lt;/strong&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;

&lt;p&gt;AOP 切面编程涉及到的一些专业术语：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;术语&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;目标(Target)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被通知的对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代理(Proxy)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;连接点(JoinPoint)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切入点(Pointcut)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通知(Advice)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切面(Aspect)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Weaving(织入)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;aop-常见的通知类型有哪些&quot;&gt;AOP 常见的通知类型有哪些？&lt;/h2&gt;

&lt;p&gt;AOP 一般有 &lt;strong&gt;5 种&lt;/strong&gt;环绕方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前置通知 (@Before)&lt;/li&gt;
  &lt;li&gt;返回通知 (@AfterReturning)&lt;/li&gt;
  &lt;li&gt;异常通知 (@AfterThrowing)&lt;/li&gt;
  &lt;li&gt;后置通知 (@After)&lt;/li&gt;
  &lt;li&gt;环绕通知 (@Around)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062358585.png&quot; alt=&quot;三分恶面渣逆袭：环绕方式&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;aspectj-是什么&quot;&gt;AspectJ 是什么？&lt;/h2&gt;

&lt;h3 id=&quot;aepectj&quot;&gt;AepectJ&lt;/h3&gt;

&lt;p&gt;AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 定义一个切面&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 定义一个切点，匹配 com.example 包下的所有方法&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Pointcut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;execution(* com.example..*(..))&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 定义一个前置通知，在匹配的方法执行之前执行&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectAll()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;beforeAdvice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A method is about to be executed.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;spring-aop-和-aspectj-aop-有什么区别&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop-和-aspectj-aop-有什么区别&quot;&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/a&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;Spring AOP&lt;/th&gt;
      &lt;th&gt;AspectJ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;增强方式&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时增强（基于动态代理）&lt;/td&gt;
      &lt;td&gt;编译时增强、类加载时增强（直接操作字节码）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;切入点支持&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;方法级（Spring Bean 范围内，不支持 final 和 staic 方法）&lt;/td&gt;
      &lt;td&gt;方法级、字段、构造器、静态方法等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时依赖代理，有一定开销，切面多时性能较低&lt;/td&gt;
      &lt;td&gt;运行时无代理开销，性能更高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;简单，易用，适合大多数场景&lt;/td&gt;
      &lt;td&gt;功能强大，但相对复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Spring 应用下比较简单的 AOP 需求&lt;/td&gt;
      &lt;td&gt;高性能、高复杂度的 AOP 需求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;如何选择？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能考量&lt;/strong&gt;：AspectJ 支持更复杂的 AOP 场景，Spring AOP 更简单易用。如果你需要增强 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 方法、静态方法、字段访问、构造器调用等，或者需要在非 Spring 管理的对象上应用增强逻辑，AspectJ 是唯一的选择。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能考量&lt;/strong&gt;：切面数量较少时两者性能差异不大，但切面较多时 AspectJ 性能更优。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一句话总结&lt;/strong&gt;：简单场景优先使用 Spring AOP；复杂场景或高性能需求时，选择 AspectJ。&lt;/p&gt;

&lt;p&gt;Spring AOP 属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;运行时增强&lt;/code&gt;，主要具有如下特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现&lt;/li&gt;
  &lt;li&gt;Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现&lt;/li&gt;
  &lt;li&gt;在性能上，由于 Spring AOP 是基于&lt;strong&gt;动态代理&lt;/strong&gt;来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。&lt;/li&gt;
  &lt;li&gt;Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AspectJ 是一个易用的功能强大的 AOP 框架，属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;编译时增强&lt;/code&gt;， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。&lt;/p&gt;

&lt;p&gt;AspectJ 属于&lt;strong&gt;静态织入&lt;/strong&gt;，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。&lt;/li&gt;
  &lt;li&gt;编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。&lt;/li&gt;
  &lt;li&gt;类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sprint-aop&quot;&gt;Sprint AOP&lt;/h2&gt;

&lt;h3 id=&quot;spring-aop-发生在什么时候&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#spring-aop-发生在什么时候&quot;&gt;Spring AOP 发生在什么时候？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Spring AOP 基于运行时代理机制，这意味着 Spring AOP 是在运行时通过动态代理生成的，而不是在编译时或类加载时生成的。&lt;/p&gt;

&lt;p&gt;在 Spring 容器初始化 Bean 的过程中，Spring AOP 会检查 Bean 是否需要应用切面。如果需要，Spring 会为该 Bean 创建一个代理对象，并在代理对象中织入切面逻辑。这一过程发生在 Spring 容器的后处理器（BeanPostProcessor）阶段。&lt;/p&gt;

&lt;h3 id=&quot;说说-jdk-动态代理和-cglib-代理&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#_21-说说-jdk-动态代理和-cglib-代理&quot;&gt;说说 JDK 动态代理和 CGLIB 代理？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;AOP 是通过&lt;a href=&quot;https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg&quot;&gt;动态代理&lt;/a&gt;实现的，代理方式有两种：JDK 动态代理和 CGLIB 代理。&lt;/p&gt;

&lt;p&gt;①、JDK 动态代理是基于接口的代理，只能代理实现了接口的类。&lt;/p&gt;

&lt;p&gt;使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：只需依赖 JDK 自带的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类，不需要额外的库；缺点：只能代理接口，不能代理类本身。&lt;/p&gt;

&lt;p&gt;②、CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。&lt;/p&gt;

&lt;p&gt;使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：可以代理没有实现接口的类，灵活性更高；缺点：需要依赖 CGLIB 库，创建代理对象的开销相对较大。&lt;/p&gt;

&lt;h3 id=&quot;选择-cglib-还是-jdk-动态代理&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#选择-cglib-还是-jdk-动态代理&quot;&gt;选择 CGLIB 还是 JDK 动态代理？&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果目标对象没有实现任何接口，则只能使用 CGLIB 代理。如果目标对象实现了接口，通常首选 JDK 动态代理。&lt;/li&gt;
  &lt;li&gt;虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能。对于性能敏感且代理对象创建频率不高的场景，可以考虑使用 CGLIB。&lt;/li&gt;
  &lt;li&gt;JDK 动态代理是 Java 原生支持的，不需要额外引入库。而 CGLIB 需要将 CGLIB 库作为依赖加入项目中。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring AOP</summary></entry><entry><title type="html">Spring IoC</title><link href="https://mafulong.github.io/2025/05/06/Spring-IoC/" rel="alternate" type="text/html" title="Spring IoC" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20IoC</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-IoC/">&lt;h2 id=&quot;sprint-ioc&quot;&gt;Sprint IoC&lt;/h2&gt;

&lt;h3 id=&quot;谈谈自己对于-spring-ioc-的了解&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#谈谈自己对于-spring-ioc-的了解&quot;&gt;谈谈自己对于 Spring IoC 的了解&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IoC（Inversion of Control:控制反转）&lt;/strong&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么叫控制反转？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;控制&lt;/strong&gt;：指的是对象创建（实例化、管理）的权力&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;反转&lt;/strong&gt;：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;

&lt;p&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;

&lt;p&gt;IOC 是一种思想，&lt;strong&gt;DI&lt;/strong&gt; 是实现 IOC 的具体方式，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。&lt;/p&gt;

&lt;h3 id=&quot;将一个类声明为-bean-的注解有哪些&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#将一个类声明为-bean-的注解有哪些&quot;&gt;将一个类声明为 Bean 的注解有哪些?&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;：通用的注解，可标注任意类为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 组件。如果一个 Bean 不知道属于哪个层，可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解标注。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Repository&lt;/code&gt; : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service&lt;/code&gt; : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt; : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 层返回数据给前端页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;component-和-bean-的区别是什么&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#component-和-bean-的区别是什么&quot;&gt;@Component 和 @Bean 的区别是什么？&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注入-bean-的注解有哪些&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#注入-bean-的注解有哪些&quot;&gt;注入 Bean 的注解有哪些？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Spring 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 以及 JDK 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Annotation&lt;/th&gt;
      &lt;th&gt;Package&lt;/th&gt;
      &lt;th&gt;Source&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;org.springframework.bean.factory&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Spring 2.5+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.annotation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-250&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-330&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;使用的比较多一些。&lt;/p&gt;

&lt;p&gt;推荐构造函数注入。&lt;/p&gt;

&lt;h3 id=&quot;autowired-和-resource-的区别是什么&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#autowired-和-resource-的区别是什么&quot;&gt;@Autowired 和 @Resource 的区别是什么？&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;
  &lt;li&gt;当一个接口存在多个实现类的情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;都需要通过名称才能正确匹配到对应的 Bean。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Qualifier&lt;/code&gt; 注解来显式指定名称，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 属性来显式指定名称。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 支持在构造函数、方法、字段和参数上使用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注入-bean-的方式有哪些&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#注入-bean-的方式有哪些&quot;&gt;注入 Bean 的方式有哪些？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;依赖注入 (Dependency Injection, DI) 的常见方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造函数注入：通过类的构造函数来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Setter 注入：通过类的 Setter 方法来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Field（字段） 注入：直接在类的字段上使用注解（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;）来注入依赖项。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Spring 官方推荐构造函数注入&lt;/strong&gt;，这种注入方式的优势如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。&lt;/li&gt;
  &lt;li&gt;不可变性：有助于创建不可变对象，提高了线程安全性。&lt;/li&gt;
  &lt;li&gt;初始化保证：组件在使用前已完全初始化，减少了潜在的错误。&lt;/li&gt;
  &lt;li&gt;测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;构造函数注入适合处理&lt;strong&gt;必需的依赖项&lt;/strong&gt;，而 &lt;strong&gt;Setter 注入&lt;/strong&gt; 则更适合&lt;strong&gt;可选的依赖项&lt;/strong&gt;，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。&lt;/p&gt;

&lt;p&gt;在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是&lt;strong&gt;唯一的选择&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;bean-的作用域有哪些&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-的作用域有哪些&quot;&gt;Bean 的作用域有哪些?&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;singleton&lt;/strong&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean()&lt;/code&gt; 两次，得到的是不同的 Bean 实例。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;request&lt;/strong&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;session&lt;/strong&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;application/global-session&lt;/strong&gt; （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;websocket&lt;/strong&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bean-的生命周期了解么&quot;&gt;&lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-的生命周期了解么&quot;&gt;Bean 的生命周期了解么?&lt;/a&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;创建 Bean 的实例&lt;/strong&gt;：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bean 属性赋值/填充&lt;/strong&gt;：为 Bean 设置相关属性和依赖，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 等注解注入的对象、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Value&lt;/code&gt; 注入的值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法或构造函数注入依赖和值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;注入的各种资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bean 初始化&lt;/p&gt;

    &lt;p&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;与上面的类似，如果实现了其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterPropertiesSet()&lt;/code&gt;方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 属性，执行指定的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessAfterInitialization()&lt;/code&gt; 方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;销毁 Bean&lt;/p&gt;

    &lt;p&gt;：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 接口，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy()&lt;/code&gt; 方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy-method&lt;/code&gt; 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PreDestroy&lt;/code&gt; 注解标记 Bean 销毁之前执行的方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bean 的生命周期大致分为五个阶段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062341884.png&quot; alt=&quot;三分恶面渣逆袭：Bean生命周期五个阶段&quot; /&gt;三分恶面渣逆袭：Bean生命周期五个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;实例化&lt;/strong&gt;：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;属性赋值&lt;/strong&gt;：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为依赖注入，确保 Bean 所需的所有依赖都被注入。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用中&lt;/strong&gt;：Bean 准备好可以使用了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;销毁&lt;/strong&gt;：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何记忆呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整体上可以简单分为四步：实例化 —&amp;gt; 属性赋值 —&amp;gt; 初始化 —&amp;gt; 销毁。&lt;/li&gt;
  &lt;li&gt;初始化这一步涉及到的步骤比较多，包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aware&lt;/code&gt; 接口的依赖注入、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 在初始化前后的处理以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 的初始化操作。&lt;/li&gt;
  &lt;li&gt;销毁这一步会注册相关销毁回调接口，最后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destory-method&lt;/code&gt; 进行销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再分享一张清晰的图解（图源：&lt;a href=&quot;https://chaycao.github.io/2020/02/15/如何记忆Spring-Bean的生命周期.html&quot;&gt;如何记忆 Spring Bean 的生命周期&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062339187.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-中的单例-bean-会存在线程安全问题吗&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#_14-spring-中的单例-bean-会存在线程安全问题吗&quot;&gt;Spring 中的单例 Bean 会存在线程安全问题吗？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Spring Bean 的默认作用域是单例（Singleton），这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会被多个线程共享。&lt;/p&gt;

&lt;p&gt;如果单例 Bean 是无状态的，也就是没有成员变量，那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，基本上都是无状态的。&lt;/p&gt;

&lt;p&gt;但如果 Bean 的内部状态是可变的，且没有进行适当的同步处理，就可能出现线程安全问题。&lt;/p&gt;

&lt;p&gt;对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;避免可变成员变量&lt;/strong&gt;: 尽量设计 Bean 为无状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;&lt;/strong&gt;: 将可变成员变量保存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 中，确保线程独立。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用同步机制&lt;/strong&gt;: 利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 来进行同步控制，确保线程安全。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Sprint IoC</summary></entry><entry><title type="html">Spring 循环依赖</title><link href="https://mafulong.github.io/2025/05/06/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="alternate" type="text/html" title="Spring 循环依赖" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">&lt;h2 id=&quot;spring-循环依赖&quot;&gt;Spring 循环依赖&lt;/h2&gt;

&lt;h2 id=&quot;循环依赖&quot;&gt;循环依赖&lt;/h2&gt;

&lt;p&gt;多个bean。A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃。。。。&lt;/p&gt;

&lt;p&gt;循环依赖只发生在 Singleton 作用域的 Bean 之间，因为如果是 Prototype 作用域的 Bean，Spring 会直接抛出异常。&lt;/p&gt;

&lt;h2 id=&quot;spring-可以解决哪些情况的循环依赖&quot;&gt;Spring 可以解决哪些情况的循环依赖？&lt;/h2&gt;

&lt;p&gt;看看这几种情形（AB 循环依赖）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062344583.png&quot; alt=&quot;三分恶面渣逆袭：循环依赖的几种情形&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AB 均采用构造器注入，不支持&lt;/li&gt;
  &lt;li&gt;AB 均采用 setter 注入，支持&lt;/li&gt;
  &lt;li&gt;AB 均采用属性自动注入，支持&lt;/li&gt;
  &lt;li&gt;A 中注入的 B 为 setter 注入，B 中注入的 A 为构造器注入，支持&lt;/li&gt;
  &lt;li&gt;B 中注入的 A 为 setter 注入，A 中注入的 B 为构造器注入，不支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第四种可以，第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。&lt;/p&gt;

&lt;p&gt;简单总结下，当循环依赖的实例都采用 setter 方法注入时，Spring 支持，都采用构造器注入的时候，不支持；构造器注入和 setter 注入同时存在的时候，看天&lt;/p&gt;

&lt;h2 id=&quot;spring-怎么解决循环依赖呢&quot;&gt;Spring 怎么解决循环依赖呢？&lt;/h2&gt;

&lt;p&gt;Spring 通过三级缓存机制来解决循环依赖：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一级缓存：存放完全初始化好的单例 Bean。&lt;/li&gt;
  &lt;li&gt;二级缓存：存放正在创建但未完全初始化的 Bean 实例。&lt;/li&gt;
  &lt;li&gt;三级缓存：存放 Bean 工厂对象，用于提前暴露 Bean。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062345571.png&quot; alt=&quot;三分恶面渣逆袭：三级缓存&quot; /&gt;三分恶面渣逆袭：三级缓存&lt;/p&gt;

&lt;h3 id=&quot;三级缓存解决循环依赖的过程是什么样的&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#三级缓存解决循环依赖的过程是什么样的&quot;&gt;三级缓存解决循环依赖的过程是什么样的？&lt;/a&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;实例化 Bean 时，将其早期引用放入三级缓存。&lt;/li&gt;
  &lt;li&gt;其他依赖该 Bean 的对象，可以从缓存中获取其引用。&lt;/li&gt;
  &lt;li&gt;初始化完成后，将 Bean 移入一级缓存。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实就是三级缓存存了代理对象/原始对象的堆地址，初始化动作后移。 细节参考&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#_16-spring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%91%A2&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;为什么要三级缓存级不吗&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#_17-为什么要三级缓存-二级不行吗&quot;&gt;为什么要三级缓存？⼆级不⾏吗？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;不行，主要是为了 &lt;strong&gt;⽣成代理对象&lt;/strong&gt;。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。&lt;/p&gt;

&lt;p&gt;因为三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。&lt;/p&gt;

&lt;p&gt;当涉及到 AOP 时，三级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。&lt;/p&gt;

&lt;p&gt;假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。&lt;/p&gt;

&lt;h4 id=&quot;如果缺少第二级缓存会有什么问题&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#如果缺少第二级缓存会有什么问题&quot;&gt;如果缺少第二级缓存会有什么问题？&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;如果没有二级缓存，Spring 无法在未完成初始化的情况下暴露 Bean。会导致代理 Bean 的循环依赖问题，因为某些代理逻辑无法在三级缓存中提前暴露。最终可能抛出 BeanCurrentlyInCreationException。&lt;/p&gt;

&lt;h2 id=&quot;lazy-能解决循环依赖吗&quot;&gt;@Lazy 能解决循环依赖吗？&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 用来标识类是否需要懒加载/延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。&lt;/p&gt;

&lt;p&gt;Spring Boot 2.2 新增了&lt;strong&gt;全局懒加载属性&lt;/strong&gt;，开启后全局 bean 被设置为懒加载，需要时再去创建。&lt;/p&gt;

&lt;p&gt;如非必要，尽量不要用全局懒加载。全局懒加载会让 Bean 第一次使用的时候加载会变慢，并且它会延迟应用程序问题的发现（当 Bean 被初始化时，问题才会出现）。&lt;/p&gt;

&lt;p&gt;如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lazy&lt;/code&gt; 解决循环依赖的关键点在于代理对象的使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;没有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 的情况下&lt;/strong&gt;：在 Spring 容器初始化 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 时会立即尝试创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;，而在创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的过程中又会尝试创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;，最终导致循环依赖（即无限递归，最终抛出异常）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 的情况下&lt;/strong&gt;：Spring 不会立即创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;，而是会注入一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的代理对象。由于此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 仍未被真正初始化，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 的初始化可以顺利完成。等到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 实例实际调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的方法时，代理对象才会触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的真正初始化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 能够在一定程度上打破循环依赖链，允许 Spring 容器顺利地完成 Bean 的创建和注入。但这并不是一个根本性的解决方案，尤其是在构造函数注入、复杂的多级依赖等场景中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Lazy&lt;/code&gt; 无法有效地解决问题。因此，最佳实践仍然是尽量避免设计上的循环依赖。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring 循环依赖</summary></entry><entry><title type="html">Spring基础</title><link href="https://mafulong.github.io/2025/05/06/Spring%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html" title="Spring基础" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring%E5%9F%BA%E7%A1%80/">&lt;h2 id=&quot;spring基础&quot;&gt;Spring基础&lt;/h2&gt;

&lt;p&gt;一句话概括：&lt;strong&gt;Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062328358.png&quot; alt=&quot;三分恶面渣逆袭：Spring特性&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;IoC&lt;/strong&gt; 和 &lt;strong&gt;DI&lt;/strong&gt; 的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现&lt;strong&gt;高内聚低耦合&lt;/strong&gt;的设计理念。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AOP 编程的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 提供了&lt;strong&gt;面向切面编程&lt;/strong&gt;，可以方便的实现对程序进行权限拦截、运行监控等切面功能。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;声明式事务的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;快捷测试的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 对 Junit 提供支持，可以通过&lt;strong&gt;注解&lt;/strong&gt;快捷地测试 Spring 程序。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;快速集成功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复杂 API 模板封装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。&lt;/p&gt;

&lt;h2 id=&quot;1-简单说一下什么是aop-和-ioc&quot;&gt;1. &lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#简单说一下什么是aop-和-ioc&quot;&gt;简单说一下什么是AOP 和 IoC？&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;AOP&lt;/strong&gt;：面向切面编程，是一种编程范式，它的主要作用是将那些与核心业务逻辑无关，但是对多个对象产生影响的公共行为封装起来，如日志记录、性能统计、事务等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC&lt;/strong&gt;：控制反转，是一种设计思想，它的主要作用是将对象的创建和对象之间的调用过程交给 Spring 容器来管理。&lt;/p&gt;

&lt;h2 id=&quot;2spring-有哪些模块呢&quot;&gt;2.Spring 有哪些模块呢？&lt;/h2&gt;

&lt;p&gt;Spring 框架是分模块存在，除了最核心的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring Core Container&lt;/code&gt;是必要模块之外，其他模块都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可选&lt;/code&gt;，大约有 20 多个模块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062329603.png&quot; alt=&quot;Spring模块划分&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最主要的七大模块：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Spring Core&lt;/strong&gt;：Spring 核心，它是框架最基础的部分，提供 IoC 和依赖注入 DI 特性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Context&lt;/strong&gt;：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Web&lt;/strong&gt;：它提供 Web 应用开发的支持。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt;：它针对 Web 应用中 MVC 思想的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring DAO&lt;/strong&gt;：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3spring-有哪些常用注解呢&quot;&gt;3.Spring 有哪些常用注解呢？&lt;/h2&gt;

&lt;p&gt;Spring 提供了大量的注解来简化 Java 应用的开发和配置，主要用于 Web 开发、往容器注入 Bean、AOP、事务控制等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062329372.png&quot; alt=&quot;三分恶面渣逆袭：Spring常用注解&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;web-开发方面有哪些注解呢&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#web-开发方面有哪些注解呢&quot;&gt;Web 开发方面有哪些注解呢？&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;①、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt;：用于标注控制层组件。&lt;/p&gt;

&lt;p&gt;②、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RestController&lt;/code&gt;：是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ResponseBody&lt;/code&gt; 的结合体，返回 JSON 数据时使用。&lt;/p&gt;

&lt;p&gt;③、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestMapping&lt;/code&gt;：用于映射请求 URL 到具体的方法上，还可以细分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GetMapping&lt;/code&gt;：只能用于处理 GET 请求&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PostMapping&lt;/code&gt;：只能用于处理 POST 请求&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DeleteMapping&lt;/code&gt;：只能用于处理 DELETE 请求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;④、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ResponseBody&lt;/code&gt;：直接将返回的数据放入 HTTP 响应正文中，一般用于返回 JSON 数据。&lt;/p&gt;

&lt;p&gt;⑤、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestBody&lt;/code&gt;：表示一个方法参数应该绑定到 Web 请求体。&lt;/p&gt;

&lt;p&gt;⑥、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PathVariable&lt;/code&gt;：用于接收路径参数，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestMapping(“/hello/{name}”)&lt;/code&gt;，这里的 name 就是路径参数。&lt;/p&gt;

&lt;p&gt;⑦、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam&lt;/code&gt;：用于接收请求参数。比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam(name = &quot;key&quot;) String key&lt;/code&gt;，这里的 key 就是请求参数。&lt;/p&gt;

&lt;h4 id=&quot;容器类注解有哪些呢&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#容器类注解有哪些呢&quot;&gt;容器类注解有哪些呢？&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;：标识一个类为 Spring 组件，使其能够被 Spring 容器自动扫描和管理。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service&lt;/code&gt;：标识一个业务逻辑组件（服务层）。比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service(&quot;userService&quot;)&lt;/code&gt;，这里的 userService 就是 Bean 的名称。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Repository&lt;/code&gt;：标识一个数据访问组件（持久层）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;：按类型自动注入依赖。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;：用于定义配置类，可替换 XML 配置文件。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Value&lt;/code&gt;：用于将 Spring Boot 中 application.properties 配置的属性值赋值给变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;aop-方面有哪些注解呢&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#aop-方面有哪些注解呢&quot;&gt;AOP 方面有哪些注解呢？&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Aspect&lt;/code&gt; 用于声明一个切面，可以配合其他注解一起使用，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@After&lt;/code&gt;：在方法执行之后执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Before&lt;/code&gt;：在方法执行之前执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Around&lt;/code&gt;：方法前后均执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PointCut&lt;/code&gt;：定义切点，指定需要拦截的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;事务注解有哪些&quot;&gt;&lt;a href=&quot;https://javabetter.cn/sidebar/sanfene/spring.html#事务注解有哪些&quot;&gt;事务注解有哪些？&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;主要就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt;，用于声明一个方法需要事务支持。&lt;/p&gt;

&lt;h2 id=&quot;springspring-mvcspring-boot-之间什么关系&quot;&gt;Spring,Spring MVC,Spring Boot 之间什么关系?&lt;/h2&gt;

&lt;p&gt;很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。&lt;/p&gt;

&lt;p&gt;Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。&lt;/p&gt;

&lt;p&gt;Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;

&lt;p&gt;使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！&lt;/p&gt;

&lt;p&gt;Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。&lt;/p&gt;

&lt;p&gt;Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！&lt;/p&gt;

&lt;h2 id=&quot;spring-框架中用到了哪些设计模式&quot;&gt;Spring 框架中用到了哪些设计模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于下面这些设计模式的详细介绍，可以看我写的 &lt;a href=&quot;https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html&quot;&gt;Spring 中的设计模式详解&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;工厂设计模式&lt;/strong&gt; : Spring 使用工厂模式通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;代理设计模式&lt;/strong&gt; : Spring AOP 功能的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;单例设计模式&lt;/strong&gt; : Spring 中的 Bean 默认都是单例的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt; : Spring 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jdbcTemplate&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hibernateTemplate&lt;/code&gt; 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;包装器设计模式&lt;/strong&gt; : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;观察者模式:&lt;/strong&gt; Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring基础</summary></entry><entry><title type="html">Java并发包和线程池</title><link href="https://mafulong.github.io/2025/05/04/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="alternate" type="text/html" title="Java并发包和线程池" /><published>2025-05-04T00:00:00+08:00</published><updated>2025-05-04T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/04/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0</id><content type="html" xml:base="https://mafulong.github.io/2025/05/04/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/">&lt;h2 id=&quot;java并发包和线程池&quot;&gt;Java并发包和线程池&lt;/h2&gt;

&lt;h2 id=&quot;jdk-并发包&quot;&gt;JDK 并发包&lt;/h2&gt;

&lt;h3 id=&quot;重入锁&quot;&gt;重入锁&lt;/h3&gt;

&lt;p&gt;几个重要方法
re-entrance-lock&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获得锁，如占用，则等待&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lockInteruptibly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获得锁，但优先响应中断，就是可以中断的&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//失败返回false,不等待&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//在给定时间内尝试获得锁&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//释放锁&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;重入锁的好搭档condition-条件&quot;&gt;重入锁的好搭档：Condition 条件&lt;/h3&gt;

&lt;p&gt;condition.await()和 wait()类似&lt;/p&gt;

&lt;p&gt;condition.signal()和 notify()类似&lt;/p&gt;

&lt;p&gt;要在 lock 块内&lt;/p&gt;

&lt;h3 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h3&gt;

&lt;p&gt;信号量机制&lt;/p&gt;

&lt;p&gt;允许多个线程同时访问&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;permits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//permits是个许可证&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SemaphoreExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clientCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalRequestCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clientCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalRequestCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()-&amp;gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;availablePermits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resutl:
2 1 2 2 2 2 2 1 2 2&lt;/p&gt;

&lt;h3 id=&quot;readwritelock&quot;&gt;ReadWriteLock&lt;/h3&gt;

&lt;p&gt;读写分离锁，可以减少锁竞争，提升性能&lt;/p&gt;

&lt;h3 id=&quot;countdownlatch&quot;&gt;CountdownLatch&lt;/h3&gt;

&lt;p&gt;就是倒计数的锁存期，可以让线程等待直到倒计时结束，再开始执行&lt;/p&gt;

&lt;p&gt;用来控制一个线程等待多个线程。&lt;/p&gt;

&lt;p&gt;维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountdownLatchExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countDownLatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;run..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;countDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;countDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;countDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;end&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;result:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;run..run..run..run..run..run..run..run..run..run..end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cyclicbarrier&quot;&gt;CyclicBarrier&lt;/h3&gt;

&lt;p&gt;允许一组线程互相等待，直到都到达某个公共屏障点&lt;/p&gt;

&lt;p&gt;用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p&gt;

&lt;p&gt;和 CountdownLatch 相似，都是通过维护计数器来实现的。但是它的计数器是递增的，每次执行 await() 方法之后，计数器会加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。和 CountdownLatch 的另一个区别是，CyclicBarrier 的计数器可以循环使用，所以它才叫做循环屏障。&lt;/p&gt;

&lt;p&gt;这个是规定多少个线程，这一定数量的线程都到达 await()时才开始都唤醒，继续执行&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CyclicBarrierExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;CyclicBarrier&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cyclicBarrier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CyclicBarrier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;before..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;cyclicBarrier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BrokenBarrierException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;after..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;result:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;exchanger&quot;&gt;Exchanger&lt;/h3&gt;

&lt;p&gt;用于两个线程之间数据的同步交换，都准备好才交换&lt;/p&gt;

&lt;h2 id=&quot;线程池&quot;&gt;线程池&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/edd7cb4eafa0&quot;&gt;线程池的粗浅使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ifeve.com/java-threadpool/&quot;&gt;线程池的分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/absfree/p/5357118.html&quot;&gt;线程池分析更好些&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。&lt;/p&gt;

&lt;h3 id=&quot;创建线程池&quot;&gt;创建线程池&lt;/h3&gt;

&lt;p&gt;一般通过工具类 Executors 的静态方法来获取线程池或静态方法。介绍四种常用创建方法&lt;/p&gt;

&lt;p&gt;单例线程，表示在任意的时间段内，线程池中只有一个线程在工作&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;缓存线程池，先查看线程池中是否有当前执行线程的缓存，如果有就 resue(复用),如果没有,那么需要创建一个线程来完成当前的调用.并且这类线程池只能完成一些生存期很短的一些任务.并且这类线程池内部规定能 resue(复用)的线程，空闲的时间不能超过 60s,一旦超过了 60s,就会被移出线程池&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCacheThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;固定型线程池，和 newCacheThreadPool()差不多，也能够实现 resue(复用),但是这个池子规定了线程的最大数量，也就是说当池子有空闲时，那么新的任务将会在空闲线程中被执行，一旦线程池内的线程都在进行工作，那么新的任务就必须等待线程池有空闲的时候才能够进入线程池,其他的任务继续排队等待.这类池子没有规定其空闲的时间到底有多长.这一类的池子更适用于服务器.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调度型线程池,调度型线程池会根据 Scheduled(任务列表)进行延迟执行，或者是进行周期性的执行.适用于一些周期性的工作.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello world !&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; ===&amp;gt; main Thread execute here ! &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newScheduledThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程池任务创建与提交&quot;&gt;线程池任务创建与提交&lt;/h3&gt;

&lt;p&gt;任务分为两种:一种是有返回值的（ callable ），一种是没有返回值的（ runnable ）. Callable 与 Future 两功能是 Java 在后续版本中为了适应多并法才加入的，Callable 是类似于 Runnable 的接口，实现 Callable 接口的类和实现 Runnable 的类都是可被其他线程执行的任务。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无返回值的任务就是一个实现了 runnable 接口的类.使用 run 方法.&lt;/li&gt;
  &lt;li&gt;有返回值的任务是一个实现了 callable 接口的类.使用 call 方法.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Callable 和 Runnable 的区别如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Callable 定义的方法是 call，而 Runnable 定义的方法是 run。&lt;/li&gt;
  &lt;li&gt;Callable 的 call 方法可以有返回值，而 Runnable 的 run 方法不能有返回值。&lt;/li&gt;
  &lt;li&gt;Callable 的 call 方法可抛出异常，而 Runnable 的 run 方法不能抛出异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;execute 与 submit 区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收的参数不一样&lt;/li&gt;
  &lt;li&gt;submit 有返回值，而 execute 没有&lt;/li&gt;
  &lt;li&gt;submit 方便 Exception 处理&lt;/li&gt;
  &lt;li&gt;execute 是 Executor 接口中唯一定义的方法；submit 是 ExecutorService（该接口继承 Executor）中定义的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;线程池的关闭&quot;&gt;线程池的关闭&lt;/h3&gt;

&lt;p&gt;我们可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。&lt;/p&gt;

&lt;p&gt;只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。&lt;/p&gt;

&lt;h3 id=&quot;线程池的分析&quot;&gt;线程池的分析&lt;/h3&gt;

&lt;h4 id=&quot;线程池创建分析&quot;&gt;线程池创建分析&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runnableTaskQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建一个线程池需要输入几个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；&lt;/li&gt;
  &lt;li&gt;runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。&lt;/li&gt;
  &lt;li&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列。&lt;/li&gt;
  &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。&lt;/li&gt;
  &lt;li&gt;PriorityBlockingQueue：一个具有优先级得无限阻塞队列。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。也就是说 corePoolSize 就是线程池大小，maximumPoolSize 在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。&lt;/li&gt;
  &lt;li&gt;ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。&lt;/li&gt;
  &lt;li&gt;RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;AbortPolicy：直接抛出异常&lt;/li&gt;
  &lt;li&gt;CallerRunsPolicy：只用调用者所在线程来运行任务。&lt;/li&gt;
  &lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。&lt;/li&gt;
  &lt;li&gt;DiscardPolicy：不处理，丢弃掉。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。&lt;/li&gt;
  &lt;li&gt;TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505041121762.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前线程池中的线程数目小于 corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目&amp;gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目达到 maximumPoolSize，则会采取任务拒绝策略进行处理；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止&lt;/p&gt;

&lt;p&gt;从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。&lt;/p&gt;

&lt;p&gt;newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;newSingleThreadExecutor 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;newCachedThreadPool 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过 60 秒，就销毁线程。&lt;/p&gt;

&lt;p&gt;实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。&lt;/p&gt;

&lt;h2 id=&quot;aqs原理&quot;&gt;AQS原理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;AQS（AbstractQueuedSynchronizer）的原理。它是 Java 并发框架中用于构建锁和同步器的一个核心框架类，比如 ReentrantLock、Semaphore、CountDownLatch 等同步器，底层都是基于 AQS 实现的。是 Java 并发包 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent.locks&lt;/code&gt; 中用来构建锁和其他同步器（如信号量、读写锁、倒计时器等）的一个&lt;strong&gt;基础框架类&lt;/strong&gt;。它是 J.U.C 并发框架中最核心的底层组件之一。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AQS 通过一个&lt;strong&gt;FIFO 队列&lt;/strong&gt;（先进先出等待队列）来&lt;strong&gt;管理获取锁失败的线程&lt;/strong&gt;，并通过一个&lt;strong&gt;原子变量 state&lt;/strong&gt; 来&lt;strong&gt;表示同步状态&lt;/strong&gt;，从而实现各种自定义同步器。&lt;/p&gt;

&lt;h4 id=&quot;-1-核心思想状态--队列&quot;&gt;🌟 1. 核心思想：状态 + 队列&lt;/h4&gt;

&lt;p&gt;AQS 的核心是两个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;：一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile int state&lt;/code&gt; 表示当前的同步状态，比如 0 表示未加锁，1 表示已加锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;等待队列（CLH 队列）&lt;/strong&gt;：线程获取锁失败后，会被封装为一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 节点，加入到一个 &lt;strong&gt;FIFO 双向队列&lt;/strong&gt; 中，并通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LockSupport.park()&lt;/code&gt; 挂起。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-2-获取锁流程以独占为例&quot;&gt;🔁 2. 获取锁流程（以独占为例）：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire()&lt;/code&gt; 尝试加锁，底层会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquire()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryAcquire()&lt;/code&gt; 失败，就进入等待队列，并阻塞当前线程。&lt;/li&gt;
  &lt;li&gt;前一个线程释放锁时调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release()&lt;/code&gt;，底层调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tryRelease()&lt;/code&gt; 成功后唤醒下一个线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-3-aqs-提供模板方法子类负责实现&quot;&gt;🧱 3. AQS 提供模板方法，子类负责实现：&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
protected boolean tryAcquire(int arg);
protected boolean tryRelease(int arg);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;开发者通过继承 AQS 并实现这些方法，可以自定义同步器的行为。&lt;/p&gt;

&lt;h4 id=&quot;-4-支持两种模式&quot;&gt;📌 4. 支持两种模式：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;独占模式（Exclusive）&lt;/strong&gt;：一次只允许一个线程获取资源，如 ReentrantLock。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享模式（Shared）&lt;/strong&gt;：多个线程可以共享资源，如 Semaphore、CountDownLatch。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-5-实际应用举例&quot;&gt;📚 5. 实际应用举例：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;ReentrantLock：基于 AQS 的独占模式。&lt;/li&gt;
  &lt;li&gt;Semaphore：基于共享模式控制并发数量。&lt;/li&gt;
  &lt;li&gt;CountDownLatch：通过共享计数控制线程等待。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java 中很多同步器都是基于 AQS 实现的：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;同步器&lt;/th&gt;
      &lt;th&gt;使用 AQS 模式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ReentrantLock&lt;/td&gt;
      &lt;td&gt;独占&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Semaphore&lt;/td&gt;
      &lt;td&gt;共享&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CountDownLatch&lt;/td&gt;
      &lt;td&gt;共享&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ReentrantReadWriteLock&lt;/td&gt;
      &lt;td&gt;读共享，写独占&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AbstractQueuedSynchronizer&lt;/td&gt;
      &lt;td&gt;自定义扩展&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Fulong Ma</name></author><category term="Java" /><category term="Java" /><summary type="html">Java并发包和线程池</summary></entry><entry><title type="html">java虚拟机对象探秘</title><link href="https://mafulong.github.io/2025/05/04/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" rel="alternate" type="text/html" title="java虚拟机对象探秘" /><published>2025-05-04T00:00:00+08:00</published><updated>2025-05-04T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/04/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98</id><content type="html" xml:base="https://mafulong.github.io/2025/05/04/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/">&lt;h2 id=&quot;java虚拟机对象探秘&quot;&gt;java虚拟机对象探秘&lt;/h2&gt;

&lt;h2 id=&quot;hotspot-虚拟机对象探秘&quot;&gt;HotSpot 虚拟机对象探秘&lt;/h2&gt;

&lt;p&gt;通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。&lt;/p&gt;

&lt;h3 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#对象的创建&quot;&gt;对象的创建&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。&lt;/p&gt;

&lt;h4 id=&quot;step1类加载检查&quot;&gt;Step1:类加载检查&lt;/h4&gt;

&lt;p&gt;虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。&lt;/p&gt;

&lt;h4 id=&quot;step2分配内存&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#step2-分配内存&quot;&gt;Step2:分配内存&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;在&lt;strong&gt;类加载检查&lt;/strong&gt;通过后，接下来虚拟机将为新生对象&lt;strong&gt;分配内存&lt;/strong&gt;。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。&lt;strong&gt;分配方式&lt;/strong&gt;有 &lt;strong&gt;“指针碰撞”&lt;/strong&gt; 和 &lt;strong&gt;“空闲列表”&lt;/strong&gt; 两种，&lt;strong&gt;选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存分配的两种方式&lt;/strong&gt; （补充内容，需要掌握）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指针碰撞：
    &lt;ul&gt;
      &lt;li&gt;适用场合：堆内存规整（即没有内存碎片）的情况下。&lt;/li&gt;
      &lt;li&gt;原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。&lt;/li&gt;
      &lt;li&gt;使用该分配方式的 GC 收集器：Serial, ParNew&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;空闲列表：
    &lt;ul&gt;
      &lt;li&gt;适用场合：堆内存不规整的情况下。&lt;/li&gt;
      &lt;li&gt;原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。&lt;/li&gt;
      &lt;li&gt;使用该分配方式的 GC 收集器：CMS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存分配并发问题（补充内容，需要掌握）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CAS+失败重试：&lt;/strong&gt; CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。&lt;strong&gt;虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TLAB：&lt;/strong&gt; 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;step3初始化零值&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#step3-初始化零值&quot;&gt;Step3:初始化零值&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。&lt;/p&gt;

&lt;h4 id=&quot;step4设置对象头&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#step4-设置对象头&quot;&gt;Step4:设置对象头&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;初始化零值完成之后，&lt;strong&gt;虚拟机要对对象进行必要的设置&lt;/strong&gt;，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 &lt;strong&gt;这些信息存放在对象头中。&lt;/strong&gt; 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。&lt;/p&gt;

&lt;h4 id=&quot;step5执行-init-方法&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#step5-执行-init-方法&quot;&gt;Step5:执行 init 方法&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;&lt;/code&gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;&lt;/code&gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。&lt;/p&gt;

&lt;h3 id=&quot;对象的内存布局&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#对象的内存布局&quot;&gt;对象的内存布局&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：&lt;strong&gt;对象头（Header）&lt;/strong&gt;、&lt;strong&gt;实例数据（Instance Data）*&lt;em&gt;和*&lt;/em&gt;对齐填充（Padding）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对象头包括两部分信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;标记字段（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。&lt;/li&gt;
  &lt;li&gt;类型指针（Klass pointer）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;实例数据部分是对象真正存储的有效信息&lt;/strong&gt;，也是在程序中所定义的各种类型的字段内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。&lt;/strong&gt; 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。&lt;/p&gt;

&lt;h3 id=&quot;对象的访问定位&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#对象的访问定位&quot;&gt;对象的访问定位&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：&lt;strong&gt;使用句柄&lt;/strong&gt;、&lt;strong&gt;直接指针&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;句柄&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#句柄&quot;&gt;句柄&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505042102847.png&quot; alt=&quot;对象的访问定位-使用句柄&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;直接指针&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html#直接指针&quot;&gt;直接指针&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;如果使用直接指针访问，reference 中存储的直接就是对象的地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505042102873.png&quot; alt=&quot;对象的访问定位-直接指针&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。&lt;/p&gt;

&lt;p&gt;HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大多数现代 HotSpot JVM 默认使用的是“直接指针”方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原因如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;访问速度更快&lt;/strong&gt;：省去了通过句柄的间接寻址。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;现代 JVM 优化 GC 时对对象移动有更强的控制能力，因此句柄带来的灵活性优势变小了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Java" /><category term="Java" /><summary type="html">java虚拟机对象探秘</summary></entry><entry><title type="html">小说下载</title><link href="https://mafulong.github.io/2025/05/04/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD/" rel="alternate" type="text/html" title="小说下载" /><published>2025-05-04T00:00:00+08:00</published><updated>2025-05-04T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/04/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD</id><content type="html" xml:base="https://mafulong.github.io/2025/05/04/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD/">&lt;h2 id=&quot;小说下载&quot;&gt;小说下载&lt;/h2&gt;

&lt;h2 id=&quot;小说格式&quot;&gt;小说格式&lt;/h2&gt;

&lt;p&gt;epub &amp;gt; mobi &amp;gt; txt.&lt;/p&gt;

&lt;p&gt;mobi好处是相比epub更轻量级，一般kindle在使用。直接epub即可。&lt;/p&gt;

&lt;h2 id=&quot;小说下载-1&quot;&gt;小说下载&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;推荐  https://github.com/freeok/so-novel 使用这个，命令行工具。可多次下载单章看是否乱码，推荐书源11.&lt;/li&gt;
  &lt;li&gt;https://github.com/uncle-novel/uncle-novel&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">小说下载</summary></entry><entry><title type="html">java垃圾回收</title><link href="https://mafulong.github.io/2025/05/03/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="alternate" type="text/html" title="java垃圾回收" /><published>2025-05-03T00:00:00+08:00</published><updated>2025-05-03T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/03/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6</id><content type="html" xml:base="https://mafulong.github.io/2025/05/03/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">&lt;h2 id=&quot;java垃圾回收&quot;&gt;java垃圾回收&lt;/h2&gt;

&lt;p&gt;垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。&lt;/p&gt;

&lt;h2 id=&quot;引用类型&quot;&gt;引用类型&lt;/h2&gt;

&lt;p&gt;无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。&lt;/p&gt;

&lt;p&gt;Java 提供了四种强度不同的引用类型。&lt;/p&gt;

&lt;h4 id=&quot;1-强引用&quot;&gt;1. 强引用&lt;/h4&gt;

&lt;p&gt;被强引用关联的对象不会被回收。&lt;/p&gt;

&lt;p&gt;使用 new 一个新对象的方式来创建强引用。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-软引用&quot;&gt;2. 软引用&lt;/h4&gt;

&lt;p&gt;被软引用关联的对象只有在内存不够的情况下才会被回收。&lt;/p&gt;

&lt;p&gt;使用 SoftReference 类来创建软引用。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;SoftReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SoftReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 使对象只被软引用关联&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-弱引用&quot;&gt;3. 弱引用&lt;/h4&gt;

&lt;p&gt;被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。&lt;/p&gt;

&lt;p&gt;使用 WeakReference 类来创建弱引用。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-虚引用&quot;&gt;4. 虚引用&lt;/h4&gt;

&lt;p&gt;又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。&lt;/p&gt;

&lt;p&gt;为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。&lt;/p&gt;

&lt;p&gt;使用 PhantomReference 来创建虚引用。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;PhantomReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PhantomReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;垃圾回收详解&quot;&gt;垃圾回收详解&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;常见面试题：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;如何判断对象是否死亡（两种方法）。&lt;/li&gt;
    &lt;li&gt;简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。&lt;/li&gt;
    &lt;li&gt;如何判断一个常量是废弃常量&lt;/li&gt;
    &lt;li&gt;如何判断一个类是无用的类&lt;/li&gt;
    &lt;li&gt;垃圾收集有哪些算法，各自的特点？&lt;/li&gt;
    &lt;li&gt;HotSpot 为什么要分为新生代和老年代？&lt;/li&gt;
    &lt;li&gt;常见的垃圾回收器有哪些？&lt;/li&gt;
    &lt;li&gt;介绍一下 CMS,G1 收集器。&lt;/li&gt;
    &lt;li&gt;Minor Gc 和 Full GC 有什么不同呢？&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;堆内存被通常分为下面三部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新生代内存(Young Generation). Eden和两个Survive&lt;/li&gt;
  &lt;li&gt;老生代(Old Generation)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Metaspace(元空间) 取代，元空间使用的是直接内存&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;对象内存分配&quot;&gt;对象内存分配&lt;/h3&gt;

&lt;h4 id=&quot;优先eden分配&quot;&gt;优先Eden分配&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;大对象直接老年代&quot;&gt;大对象直接老年代&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;长期存活的对象将进入老年代&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/jvm-garbage-collection.html#长期存活的对象将进入老年代&quot;&gt;长期存活的对象将进入老年代&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。&lt;/p&gt;

&lt;p&gt;大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&amp;gt;Survivor 区后对象的初始年龄变为 1)。&lt;/p&gt;

&lt;p&gt;对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-XX:MaxTenuringThreshold&lt;/code&gt; 来设置。&lt;/p&gt;

&lt;h3 id=&quot;不同区域gc&quot;&gt;不同区域GC&lt;/h3&gt;

&lt;p&gt;针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：&lt;/p&gt;

&lt;p&gt;部分收集 (Partial GC)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；&lt;/li&gt;
  &lt;li&gt;老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；&lt;/li&gt;
  &lt;li&gt;混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整堆收集 (Full GC)：收集整个 Java 堆和方法区。&lt;/p&gt;

&lt;h2 id=&quot;垃圾回收实现&quot;&gt;垃圾回收实现&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JDK 默认垃圾收集器（使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java -XX:+PrintCommandLineFlags -version&lt;/code&gt; 命令查看）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）
    &lt;ul&gt;
      &lt;li&gt;前者是标记复制，后者是标记整理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JDK 9 ~ JDK22: G1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。&lt;/p&gt;

&lt;p&gt;一般将堆分为新生代和老年代。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新生代使用：复制算法&lt;/li&gt;
  &lt;li&gt;老年代使用：标记 - 清除 或者 标记 - 整理 算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JVM 参数 GC可调， 具有四种类型的 GC 实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;串行垃圾收集器&lt;/li&gt;
  &lt;li&gt;并行垃圾收集器&lt;/li&gt;
  &lt;li&gt;CMS 垃圾收集器&lt;/li&gt;
  &lt;li&gt;G1 垃圾收集器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;垃圾收集器&quot;&gt;垃圾收集器&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505031212304.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；&lt;/li&gt;
  &lt;li&gt;串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;细节参考 &lt;a href=&quot;http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;收集器&lt;/th&gt;
      &lt;th&gt;新生代 / 老年代&lt;/th&gt;
      &lt;th&gt;是否并发&lt;/th&gt;
      &lt;th&gt;是否压缩整理&lt;/th&gt;
      &lt;th&gt;暂停时间&lt;/th&gt;
      &lt;th&gt;使用场景&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Serial&lt;/td&gt;
      &lt;td&gt;是 / 是&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;高&lt;/td&gt;
      &lt;td&gt;小内存、单核场景（如客户端）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Parallel&lt;/td&gt;
      &lt;td&gt;是 / 是&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;中&lt;/td&gt;
      &lt;td&gt;吞吐优先场景，如批处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CMS&lt;/td&gt;
      &lt;td&gt;是 / 是&lt;/td&gt;
      &lt;td&gt;部分并发&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;低&lt;/td&gt;
      &lt;td&gt;低延迟要求，但 JDK9 起废弃&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;G1&lt;/td&gt;
      &lt;td&gt;是 / 是（Region）&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;是（并发整理）&lt;/td&gt;
      &lt;td&gt;中低&lt;/td&gt;
      &lt;td&gt;推荐，默认 GC，适合大多数服务端应用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZGC&lt;/td&gt;
      &lt;td&gt;是 / 是（Region）&lt;/td&gt;
      &lt;td&gt;全并发&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;极低&lt;/td&gt;
      &lt;td&gt;超低延迟，大内存应用，JDK11+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shenandoah&lt;/td&gt;
      &lt;td&gt;是 / 是（Region）&lt;/td&gt;
      &lt;td&gt;全并发&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;极低&lt;/td&gt;
      &lt;td&gt;RedHat 主推，类似 ZGC，适合低延迟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Serial&lt;/strong&gt; 简单、低资源；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Parallel&lt;/strong&gt; 高吞吐；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CMS&lt;/strong&gt; 停顿短但容易碎片；&lt;strong&gt;CMS&lt;/strong&gt; 不建议使用，G1 是推荐替代方案。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;G1&lt;/strong&gt; 平衡型、适用于大多数服务端；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ZGC/Shenandoah&lt;/strong&gt; 面向超低延迟场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CMS 和 G1 有什么区别？&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;对比项&lt;/th&gt;
      &lt;th&gt;CMS&lt;/th&gt;
      &lt;th&gt;G1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;内存结构&lt;/td&gt;
      &lt;td&gt;新生代 + 老年代&lt;/td&gt;
      &lt;td&gt;Region 动态分配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;并发性&lt;/td&gt;
      &lt;td&gt;并发标记&lt;/td&gt;
      &lt;td&gt;并发标记 + 压缩&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;碎片问题&lt;/td&gt;
      &lt;td&gt;有&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;吞吐量&lt;/td&gt;
      &lt;td&gt;中&lt;/td&gt;
      &lt;td&gt;中高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;已废弃&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;否（默认）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;STW 是 JVM 在某些 GC 阶段需要 &lt;strong&gt;暂停所有用户线程&lt;/strong&gt;。为了减少影响：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用并发收集器（如 G1、ZGC）&lt;/li&gt;
  &lt;li&gt;设置合理参数（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaxGCPauseMillis&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;减少大对象和频繁分配&lt;/li&gt;
  &lt;li&gt;使用 GC 日志分析 GC 次数与耗时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GC卡顿排查&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启 GC 日志：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-Xlog:gc*&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-XX:+PrintGCDetails&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;分析 GC 时间、频率、Full GC 是否频繁&lt;/li&gt;
  &lt;li&gt;观察堆使用情况、晋升失败等&lt;/li&gt;
  &lt;li&gt;使用工具（如 VisualVM、jstat、JFR、Arthas）诊断&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;g1&quot;&gt;G1&lt;/h3&gt;

&lt;p&gt;G1 的思路是 —— &lt;strong&gt;以 Region 为单位整理活对象&lt;/strong&gt;。 G1 通过在 GC 过程中，按 Region 单位将活对象搬迁并压缩，避免碎片化，同时又分阶段进行，减轻暂停负担。&lt;/p&gt;

&lt;p&gt;✅ 具体流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;标记活对象（Concurrent Marking）&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;通过并发标记阶段，识别出所有“存活对象”&lt;/li&gt;
      &lt;li&gt;并计算每个 Region 的“回收价值”（垃圾比例）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;筛选 Region&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;G1 选择回收价值最高的部分 Region 进行回收（称为 &lt;strong&gt;收集集（Collection Set, CSet）&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对象转移（Evacuation）&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;将存活对象从 CSet 中迁移到新的空 Region（可 Eden、Survivor、Old）&lt;/li&gt;
      &lt;li&gt;迁移时是压缩式移动：&lt;strong&gt;连续地复制活对象 → 减少碎片&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更新引用&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;并发地通过记忆集（Remembered Set）和 SATB（Snapshot At The Beginning）机制，更新被引用地址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;旧 Region 回收&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;所有对象被转移后，旧 Region 被标记为空，可重用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;G1 的压缩不是在 &lt;strong&gt;Full GC&lt;/strong&gt; 阶段才执行，而是在 &lt;strong&gt;Young GC 和 Mixed GC 中增量地进行&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;每次 GC 只处理部分 Region，&lt;strong&gt;减少一次性 Stop-The-World 的开销&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;所以 G1 被称为支持“&lt;strong&gt;增量压缩&lt;/strong&gt;”的收集器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;qa&quot;&gt;QA&lt;/h2&gt;

&lt;h3 id=&quot;如何判断一个常量是废弃常量&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/jvm-garbage-collection.html#如何判断一个常量是废弃常量&quot;&gt;如何判断一个常量是废弃常量？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？&lt;/p&gt;

&lt;p&gt;假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了&lt;/p&gt;

&lt;h3 id=&quot;如何判断一个类是无用的类&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/jvm-garbage-collection.html#如何判断一个类是无用的类&quot;&gt;如何判断一个类是无用的类？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？&lt;/p&gt;

&lt;p&gt;判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 &lt;strong&gt;“无用的类”&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。&lt;/li&gt;
  &lt;li&gt;加载该类的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 已经被回收。&lt;/li&gt;
  &lt;li&gt;该类对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt; 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Java" /><category term="Java" /><summary type="html">java垃圾回收</summary></entry><entry><title type="html">java类加载机制</title><link href="https://mafulong.github.io/2025/05/03/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="alternate" type="text/html" title="java类加载机制" /><published>2025-05-03T00:00:00+08:00</published><updated>2025-05-03T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/03/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6</id><content type="html" xml:base="https://mafulong.github.io/2025/05/03/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">&lt;h2 id=&quot;java类加载机制&quot;&gt;java类加载机制&lt;/h2&gt;

&lt;h2 id=&quot;类加载机制核心知识点总结&quot;&gt;类加载机制核心知识点总结&lt;/h2&gt;

&lt;h3 id=&quot;类加载过程&quot;&gt;类加载过程&lt;/h3&gt;

&lt;p&gt;开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载过程：&lt;strong&gt;加载-&amp;gt;连接-&amp;gt;初始化&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;连接过程又可分为三步：&lt;strong&gt;验证-&amp;gt;准备-&amp;gt;解析&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505042107624.png&quot; alt=&quot;类加载过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;加载是类加载过程的第一步，主要完成下面 3 件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过全类名获取定义此类的二进制字节流&lt;/li&gt;
  &lt;li&gt;将字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/li&gt;
  &lt;li&gt;在内存中生成一个代表该类的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class&lt;/code&gt; 对象，作为方法区这些数据的访问入口&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;阶段&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;加载（Loading）&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;读取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 文件，生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class&lt;/code&gt; 对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;验证（Verification）&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;字节码格式验证、安全性验证&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;准备（Preparation）&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;分配静态变量内存并初始化默认值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;解析（Resolution）&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;将符号引用转换为直接引用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;初始化（Initialization）&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 方法，初始化静态变量和静态代码块&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。&lt;/li&gt;
  &lt;li&gt;每个 Java 类都有一个引用指向加载它的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;数组类不是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;类加载器加载规则&quot;&gt;&lt;a href=&quot;https://javaguide.cn/java/jvm/classloader.html#类加载器加载规则&quot;&gt;类加载器加载规则&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。&lt;/p&gt;

&lt;p&gt;对于已经加载的类会被放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。&lt;/p&gt;

&lt;h3 id=&quot;类加载器分类&quot;&gt;类加载器分类&lt;/h3&gt;

&lt;p&gt;JVM 中内置了三个重要的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BootstrapClassLoader&lt;/code&gt;(启动类加载器)&lt;/strong&gt;：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%JAVA_HOME%/lib&lt;/code&gt;目录下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rt.jar&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.jar&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;charsets.jar&lt;/code&gt;等 jar 包和类）以及被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-Xbootclasspath&lt;/code&gt;参数指定的路径下的所有类。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExtensionClassLoader&lt;/code&gt;(扩展类加载器)&lt;/strong&gt;：主要负责加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%JRE_HOME%/lib/ext&lt;/code&gt; 目录下的 jar 包和类以及被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.ext.dirs&lt;/code&gt; 系统变量所指定的路径下的所有类。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppClassLoader&lt;/code&gt;(应用程序类加载器)&lt;/strong&gt;：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;🌈 拓展一下：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rt.jar&lt;/code&gt;&lt;/strong&gt;：rt 代表“RunTime”，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rt.jar&lt;/code&gt;是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.xxx.*&lt;/code&gt;都在里面，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.*&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.io.*&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.nio.*&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.*&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.sql.*&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.math.*&lt;/code&gt;。&lt;/li&gt;
    &lt;li&gt;Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.base&lt;/code&gt; 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;加载器&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Bootstrap ClassLoader&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;加载 JDK 核心类，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.*&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Extension ClassLoader&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ext&lt;/code&gt; 目录下的扩展类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Application ClassLoader&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;加载 CLASSPATH 中的类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;自定义 ClassLoader&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;通过继承 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 自定义逻辑&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;双亲委派模型parent-delegation&quot;&gt;双亲委派模型（Parent Delegation）&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;加载请求会先委托给父加载器，层层向上，只有父类加载器无法加载时，才由当前加载器尝试加载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;双亲委派模型有什么好处？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;避免重复加载&lt;/li&gt;
  &lt;li&gt;防止核心类被篡改（如你写了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.String&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505042109001.png&quot; alt=&quot;类加载器层次关系图&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的。 自定义加载器的话，需要继承 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 。如果我们不想打破双亲委派模型，就重写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 类中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findClass()&lt;/code&gt; 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loadClass()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebAppClassLoader&lt;/code&gt; 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。&lt;/p&gt;

&lt;p&gt;其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MotherClassLoader&lt;/code&gt; 和一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FatherClassLoader&lt;/code&gt; 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。&lt;/p&gt;

&lt;p&gt;另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JVM 判定两个 Java 类是否相同的具体规则&lt;/strong&gt;：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class&lt;/code&gt; 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。&lt;/p&gt;

&lt;h2 id=&quot;类卸载&quot;&gt;类卸载&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;卸载类即该类的 Class 对象被 GC。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;卸载类需要满足 3 个要求:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。&lt;/li&gt;
  &lt;li&gt;该类没有在其他任何地方被引用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;该类的类加载器的实例已被 GC。ClassLoader GC才行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。&lt;/p&gt;

&lt;p&gt;只要想通一点就好了，JDK 自带的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BootstrapClassLoader&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExtClassLoader&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppClassLoader&lt;/code&gt; 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。&lt;/p&gt;

&lt;h2 id=&quot;spi&quot;&gt;SPI&lt;/h2&gt;

&lt;p&gt;SPI（&lt;strong&gt;Service Provider Interface&lt;/strong&gt;，服务提供接口）是 Java 提供的一种 &lt;strong&gt;服务发现机制&lt;/strong&gt;，用于实现模块间的解耦，常用于框架底层或插件式架构中。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;定义接口（服务接口）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实现接口（服务提供者）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在资源目录 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/META-INF/services/&lt;/code&gt; 下新建一个以接口全限定名命名的文件&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文件内容是具体的实现类的全限定名&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;场景&lt;/th&gt;
      &lt;th&gt;例子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;JDBC 驱动注册&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DriverManager&lt;/code&gt; 通过 SPI 加载驱动类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;日志框架适配&lt;/td&gt;
      &lt;td&gt;SLF4J -&amp;gt; Logback、Log4j&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Java 加密实现（JCE）&lt;/td&gt;
      &lt;td&gt;加载不同加密算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dubbo、Spring Boot 插件化&lt;/td&gt;
      &lt;td&gt;实现模块间解耦、插件注入&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;SPI 有什么缺点？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载是全量的，&lt;strong&gt;不能懒加载&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;实现类无法按条件优先级排序&lt;/li&gt;
  &lt;li&gt;配置文件容易拼写出错，不易调试&lt;/li&gt;
  &lt;li&gt;类加载器隔离问题（如 OSGi、Tomcat）可能导致无法发现服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改进方案&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;技术&lt;/th&gt;
      &lt;th&gt;优势&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Spring SPI&lt;/td&gt;
      &lt;td&gt;提供条件过滤、排序、懒加载等功能（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.factories&lt;/code&gt;）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dubbo SPI&lt;/td&gt;
      &lt;td&gt;增强 SPI，支持注解、扩展点自动激活&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Java 9 Module SPI&lt;/td&gt;
      &lt;td&gt;基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module-info.java&lt;/code&gt; 实现模块化 SPI&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Spring SPI = Spring 提供的一套 &lt;strong&gt;基于配置文件&lt;/strong&gt;的接口发现与扩展机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;META-INF/spring.factories&lt;/code&gt; 文件中，配置接口与实现类映射，Spring 会在运行时自动加载。&lt;/p&gt;

&lt;h2 id=&quot;qa&quot;&gt;QA&lt;/h2&gt;

&lt;h3 id=&quot;类是何时被加载进-jvm-的&quot;&gt;&lt;strong&gt;类是何时被加载进 JVM 的？&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;第一次主动使用时，比如：
    &lt;ul&gt;
      &lt;li&gt;创建对象（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;）&lt;/li&gt;
      &lt;li&gt;访问静态变量、方法&lt;/li&gt;
      &lt;li&gt;反射调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class.forName()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;子类初始化会先触发父类初始化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;类加载器之间的关系是继承还是组合&quot;&gt;&lt;strong&gt;类加载器之间的关系是继承还是组合？&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;是组合关系，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt; 实例之间通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt; 字段关联，不是继承树。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;类加载调试与工具&quot;&gt;类加载调试与工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;查看类加载器：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getClass().getClassLoader()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;显示加载路径：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.getProperty(&quot;java.class.path&quot;)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jcmd&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmap&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jstack&lt;/code&gt;：排查类加载问题&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-verbose:class&lt;/code&gt; 观察类加载过程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;什么时候会破坏双亲委派模型&quot;&gt;&lt;strong&gt;什么时候会破坏双亲委派模型？&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;自定义 ClassLoader 加载特定类（如 SPI 机制）&lt;/li&gt;
  &lt;li&gt;Tomcat、Spring Boot 为了实现热部署，故意打破模型&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Java" /><category term="Java" /><summary type="html">java类加载机制</summary></entry><entry><title type="html">Java算法基础</title><link href="https://mafulong.github.io/2025/04/26/Java%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html" title="Java算法基础" /><published>2025-04-26T00:00:00+08:00</published><updated>2025-04-26T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/04/26/Java%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="https://mafulong.github.io/2025/04/26/Java%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">&lt;h2 id=&quot;基本知识&quot;&gt;基本知识&lt;/h2&gt;

&lt;h3 id=&quot;输入输出&quot;&gt;输入输出&lt;/h3&gt;

&lt;h4 id=&quot;常用的包&quot;&gt;常用的包&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;java.io&lt;/li&gt;
  &lt;li&gt;java.util&lt;/li&gt;
  &lt;li&gt;java.math&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;基本输入输出&quot;&gt;基本输入输出&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//基本方法&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BufferedInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//更快&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;XXX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextXXX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//然后这样给一个XXX类型的变量从标准输入获取值&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSomeThing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//循环到EOF时这么写，后面也可以加上变量类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;PrintWriter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PrintWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BufferedOutputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//使用缓存加速，比直接使用System.out快&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%.2f\n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 与c语言中printf用法相同&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//输入char&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;无限输入&quot;&gt;无限输入&lt;/h4&gt;

&lt;p&gt;java中有个hasNext()函数,作用就是判断是否还有下一个元素，以CTRL+D结束。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
	    &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	   &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	   &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
	   &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		   &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextDouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		   &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
		   &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	   &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;控制台输入输出重定向到文件&quot;&gt;控制台输入输出重定向到文件&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nc&quot;&gt;FileInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b.in&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;nc&quot;&gt;PrintStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PrintStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileOutputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b.out&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;  
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setOut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;文件读写&quot;&gt;文件读写&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nc&quot;&gt;PrintStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PrintSteam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileOutputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c:\\datain.txt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/home/zjz/Desktop/myfile.txt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;int和string&quot;&gt;int和String&lt;/h3&gt;

&lt;h4 id=&quot;javamath&quot;&gt;java.Math&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;max(a,b)方法&lt;/li&gt;
  &lt;li&gt;sqrt返回double类型，记住两个数比较时转换为复杂类型,int比较double会都变double再比较&lt;/li&gt;
  &lt;li&gt;floor()返回double类型 floor(-8.5)=-9.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;四舍五入&quot;&gt;四舍五入&lt;/h4&gt;

&lt;p&gt;这个是四舍五入输出&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个也是四舍五入输出&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nc&quot;&gt;DecimalFormat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decimalFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DecimalFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.00&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimalFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;113.146134321&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;想要截取输出的办法&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decimalFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;113.146134321&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.005&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;13.4324&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   
  &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;算法基础&quot;&gt;算法基础&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.example&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.math.BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Object&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// getClass(). getClass() 会严格比较对象的类，不考虑继承关系。因此，只能判断对象是否确切为某个类，而不能判断它是否是该类的子类。&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Integer&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MIN_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 进制转换&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binaryString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toBinaryString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 输出 &quot;1010&quot;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//把int型数据转换乘X进制数并转换成string型&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binaryString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 输出 9&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// compare. 从小到大时compare返回负数， 返回负数，表示前面的“小”；谁想排在前面，就让它减掉对方！&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// BigInteger&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigInteger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;341241&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// String-Integer &amp;amp;&amp;amp; Integer-String&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// char&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bad&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;j&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// char - ascii&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asciiValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 转换为 ASCII 值&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;asciiValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asciiValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 转换为字符&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Character&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toUpperCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&apos;c&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Character&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&apos;C&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Character&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isLetter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Character&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDigit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&apos;3&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// String&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;adf&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;df&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;da#4#jk43#43&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d111%.2f&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.1465926&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// List&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// api: add, remove, get, set, contains, size()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Queue&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        这个也行Deque&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// tail: add, poll&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// head: addFirst, pollFirst&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        queue.getFirst();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        queue.getLast();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// heap&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//改为大顶堆&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//简化写法（匿名Lambda表达式）&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**
         * Map
         */&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getOrDefault&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//遍历&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//按键遍历&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//按值遍历&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//按Entry遍历&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;entrySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


        &lt;span class=&quot;cm&quot;&gt;/**
         * Set
         */&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//需要排序使用TreeSet&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;(((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// lower, higher 小于 大于，不包括等于&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// floor, ceiling 包含等于&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// first, last最小，最大&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**
         * List
         */&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;413&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4132&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;arrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ansList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ansList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])));&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**
         * Array
         */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;134&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3143&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**
         * Collections
         */&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        Collections.sort;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        Collections.reverse();&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/**
         * 二分查找
         * 存在时返回index. 不存在时返回-(index+1), 是负数，index是插入点, 可还原
         */&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        Arrays.binarySearch(, );&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        Collections.binarySearch()&lt;/span&gt;


    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fulong Ma</name></author><category term="Java" /><category term="Java" /><summary type="html">基本知识</summary></entry></feed>