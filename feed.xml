<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://mafulong.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mafulong.github.io/" rel="alternate" type="text/html" /><updated>2025-07-07T17:11:11+08:00</updated><id>https://mafulong.github.io/feed.xml</id><title type="html">Fulongのblog</title><subtitle>Fulongのblog</subtitle><author><name>Fulong Ma</name></author><entry><title type="html">Solidity</title><link href="https://mafulong.github.io/2025/06/28/Solidity/" rel="alternate" type="text/html" title="Solidity" /><published>2025-06-28T00:00:00+08:00</published><updated>2025-06-28T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/28/Solidity</id><content type="html" xml:base="https://mafulong.github.io/2025/06/28/Solidity/">&lt;h2 id=&quot;solidity&quot;&gt;Solidity&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_basic/&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;智能合约-与-solidity-语言&quot;&gt;智能合约 与 Solidity 语言&lt;/h2&gt;

&lt;p&gt;智能合约是运行在链上的程序，合约开发者可以通过智能合约实现与链上资产/数据进行交互，用户可以通过自己的链上账户来调用合约，访问资产与数据。因为区块链保留区块历史记录的链式结构、去中心化、不可篡改等特征，智能合约相比传统应用来说能更公正、透明。&lt;/p&gt;

&lt;p&gt;然而，因为智能合约需要与链进行交互，部署、数据写入等操作都会消耗一定费用，数据存储与变更成本也比较高，因此在设计合约时需要着重考虑资源的消耗。此外，常规智能合约一经部署就无法进行修改，因此，合约设计时也需要多考虑其安全性、可升级性与拓展性。&lt;/p&gt;

&lt;p&gt;Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言，在 EVM 虚拟机上运行，语法整体类似于 Javascript，是目前最流行的智能合约语言，也是入门区块链与 Web3 所必须掌握的语言。&lt;/p&gt;

&lt;h2 id=&quot;开发调试工具&quot;&gt;开发/调试工具&lt;/h2&gt;

&lt;p&gt;与常规编程语言不同，Solidity 智能合约的开发往往无法直接通过一个 IDE 或本地环境进行方便的调试，而是需要与一个链上节点进行交互。开发调试往往也不会直接与主网（即真实资产、数据与业务所在的链）进行交互，否则需要承担高额手续费。目前开发调试主要有以下几种方式与框架：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://remix.ethereum.org/&quot;&gt;Remix IDE&lt;/a&gt;。通过 Ethereum 官方提供的基于浏览器的 Remix 开发工具进行调试，Remix 会提供完整的 IDE、编译工具、部署调试的测试节点环境、账户等，可以很方便地进行测试，这是我学习使用时用的最多的工具。Remix 还可以通过 MetaMask 插件与测试网、主网进行直接交互，部分生产环境也会使用它进行编译部署。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/trufflesuite/truffle&quot;&gt;Truffle&lt;/a&gt;。Truffle 是一个非常流行的 Javascript 的 Solidity 合约开发框架，提供了完整的开发、测试、调试工具链，可以与本地或远程网络进行交互。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/eth-brownie/brownie&quot;&gt;Brownie&lt;/a&gt;。Brownie 是一个基于 Python 的 Solidity 合约开发框架，以简洁的 Python 语法为调试和测试提供了便捷的工具链。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/NomicFoundation/hardhat&quot;&gt;Hardhat&lt;/a&gt;。Hardhat 是另一个基于 Javascript 的开发框架，提供了非常丰富的插件系统，适合开发复杂的合约项目。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Fundry 是什么？ 也是个开发框架？从 B 站上看到的，待定。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了开发框架外，更好地进行 Solidity 还需要熟悉一些工具：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Remix IDE 对于语法提示等并不完善，因此，可以使用 &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt; 配合 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=juanblanco.solidity&quot;&gt;Solidity&lt;/a&gt; 进行编写，有更好的体验。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://metamask.io/&quot;&gt;MetaMask&lt;/a&gt;。一个常用的钱包应用，开发过程中可以通过浏览器插件与测试网、主网进行交互，方便开发者进行调试。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://trufflesuite.com/ganache/&quot;&gt;Ganache&lt;/a&gt;。Ganache 是一个开源的虚拟本地节点，提供了一个虚拟链网络，可以通过各类 Web3.js、Remix 或一些框架工具与之交互，适合有一定规模的项目进行本地调试与测试。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://infura.io/&quot;&gt;Infura&lt;/a&gt;。Infura 是一个 IaaS（Infrastructure as a Service）产品，我们可以申请自己的 Ethereum 节点，通过 Infura 提供的 API 进行交互，可以很方便地进行调试，也更接近生产环境。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.openzeppelin.com/&quot;&gt;OpenZeppelin&lt;/a&gt;。OpenZeppelin 提供了非常多的合约开发库与应用，能兼顾安全、稳定的同时给予开发者更好的开发体验，降低合约开发成本。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;合约编译部署-&quot;&gt;合约编译/部署 &lt;a href=&quot;https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_basic/#合约编译部署&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Solidity 合约是以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.sol&lt;/code&gt; 为后缀的文件，无法直接执行，需要编译为 EVM（Ethereum Virtual Machine）可识别的字节码才能在链上运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202506281017561.png&quot; alt=&quot;compile_solidity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译完成后，由合约账户进行部署到链上，其他账户可通过钱包与合约进行交互，实现链上业务逻辑。&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">Solidity</summary></entry><entry><title type="html">binance课程笔记</title><link href="https://mafulong.github.io/2025/06/28/binance%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="binance课程笔记" /><published>2025-06-28T00:00:00+08:00</published><updated>2025-06-28T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/28/binance%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://mafulong.github.io/2025/06/28/binance%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">&lt;h1 id=&quot;binance课程笔记&quot;&gt;binance课程笔记&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/track/beginner-track&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;初级&quot;&gt;初级&lt;/h1&gt;

&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-is-blockchain-and-how-does-it-work&quot;&gt;区块链概念及其运行方式介绍&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/positives-and-negatives-of-blockchain&quot;&gt;区块链的优点和缺点&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-is-a-cryptocurrency&quot;&gt;加密货币的概念及其运作方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/how-to-create-your-own-cryptocurrency&quot;&gt;如何创建专属加密货币？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/the-complete-beginners-guide-to-decentralized-finance-defi&quot;&gt;什么是去中心化金融 (DeFi)？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-is-an-automated-market-maker-amm&quot;&gt;什么是自动化做市商(AMM)？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/the-evolution-of-the-internet-web-3-0-explained&quot;&gt;Web 3.0及其重要性介绍&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/difference-between-blockchain-and-bitcoin&quot;&gt;区块链与比特币的区别&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-are-governance-tokens&quot;&gt;治理代币是什么？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-is-a-decentralized-exchange-dex&quot;&gt;什么是去中心化交易平台(DEX)？&lt;/a&gt; CEX 与 DEX&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-is-an-ido-initial-dex-offering&quot;&gt;什么是IDO（首次去中心化交易所发行）？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/courses/track/beginner-track/crypto-fundamentals/how-to-use-crypto-wallets&quot;&gt;模块： 如何使用加密货币钱包？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/custodial-vs-non-custodial-wallets-what-s-the-difference&quot;&gt;托管型与非托管型钱包有何差异？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;去中心化-web3&quot;&gt;去中心化 web3&lt;/h2&gt;

&lt;h2 id=&quot;qa&quot;&gt;QA&lt;/h2&gt;

&lt;h3 id=&quot;杂&quot;&gt;杂&lt;/h3&gt;

&lt;p&gt;“&lt;strong&gt;流动性挖矿&lt;/strong&gt;”（英文：&lt;em&gt;Liquidity Mining&lt;/em&gt;）是&lt;strong&gt;去中心化金融（DeFi）&lt;/strong&gt;中的一种激励机制，指的是用户将自己的加密资产存入去中心化交易平台（如 Uniswap、SushiSwap、Curve 等）中提供流动性，从而获得平台代币奖励的行为。&lt;/p&gt;

&lt;h3 id=&quot;cex-vs-dex&quot;&gt;CEX vs DEX&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://academy.binance.com/zh-CN/articles/what-is-a-spot-market-and-how-to-do-spot-trading&quot;&gt;参考: &lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://academy.binance.com/zh/articles/what-is-a-decentralized-exchange-dex&quot;&gt;去中心化交易平台&lt;/a&gt;(DEX)是另一种主流加密货币交易平台。DEX提供许多与中心化交易平台相同的基础服务。不同之处在于，DEX利用区块链技术匹配买卖订单。在多数情况下，DEX用户无需创建账户即可与其他用户直接交易，无需将所持资产转入DEX。&lt;/li&gt;
  &lt;li&gt;交易活动直接在智能合约与交易者的&lt;a href=&quot;https://academy.binance.com/zh-CN/glossary/wallet&quot;&gt;钱包&lt;/a&gt;之间完成。智能合约是区块链中自动执行的代码片段。许多用户倾向于在DEX交易，因为相较于常规交易平台，DEX能妥善保护隐私并提升交易自由度。然而，DEX也有不足之处。例如，出现问题时，缺乏身份认证和客户支持会带来很大的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;中心化交易所（CEX）&lt;/th&gt;
      &lt;th&gt;去中心化交易所（DEX）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;代表平台&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Binance、Coinbase、OKX、Bitget&lt;/td&gt;
      &lt;td&gt;Uniswap、SushiSwap、Curve、dYdX&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;资产托管&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;平台托管（你把币“充进去”）&lt;/td&gt;
      &lt;td&gt;你自己托管（钱包交易）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;交易撮合&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;订单簿撮合（买卖双方出价匹配）&lt;/td&gt;
      &lt;td&gt;自动做市商（AMM）模型，基于流动性池&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;KYC要求&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;需要实名认证&lt;/td&gt;
      &lt;td&gt;通常无需 KYC，钱包连接即可交易&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;交易速度&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;快（平台自建撮合系统）&lt;/td&gt;
      &lt;td&gt;慢一些（依赖区块链确认速度）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;使用门槛&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;适合新手，界面友好&lt;/td&gt;
      &lt;td&gt;适合懂钱包和链操作的用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;高度依赖平台安全性&lt;/td&gt;
      &lt;td&gt;高度依赖智能合约安全&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;监管合规&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;多数接受监管，有被封风险&lt;/td&gt;
      &lt;td&gt;脱链运行，难以监管&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;区块链-vs-比特币&quot;&gt;区块链 vs 比特币&lt;/h3&gt;

&lt;p&gt;●   区块链是一种用于记录信息的特殊技术（数据块）。&lt;/p&gt;

&lt;p&gt;●   加密货币则是一种使用区块链技术的最流行且最普遍的方式。&lt;/p&gt;

&lt;p&gt;●   反过来，比特币是一种最流行的加密货币。&lt;/p&gt;

&lt;h3 id=&quot;货币--vs-代币&quot;&gt;货币  vs 代币&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;货币（Coin）&lt;/th&gt;
      &lt;th&gt;代币（Token）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;所属区块链&lt;/td&gt;
      &lt;td&gt;自带区块链&lt;/td&gt;
      &lt;td&gt;基于其他区块链（如以太坊）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;示例&lt;/td&gt;
      &lt;td&gt;比特币（BTC）、以太坊（ETH）&lt;/td&gt;
      &lt;td&gt;USDT（Tether）、UNI（Uniswap）、LINK（Chainlink）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;标准&lt;/td&gt;
      &lt;td&gt;无统一标准&lt;/td&gt;
      &lt;td&gt;常见有 ERC-20、BEP-20、ERC-721（NFT）等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;创建方式&lt;/td&gt;
      &lt;td&gt;区块链挖矿、共识机制（PoW、PoS）&lt;/td&gt;
      &lt;td&gt;通过智能合约发行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;控制权&lt;/td&gt;
      &lt;td&gt;通常由协议社区控制&lt;/td&gt;
      &lt;td&gt;通常由一个项目方或团队控制&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;稳定币&quot;&gt;稳定币&lt;/h3&gt;

&lt;p&gt;稳定币（&lt;strong&gt;Stablecoin&lt;/strong&gt;）是&lt;strong&gt;锚定某种“稳定资产”的加密货币&lt;/strong&gt;，旨在保持其价格&lt;strong&gt;相对稳定&lt;/strong&gt;，通常与美元、欧元、黄金等挂钩。&lt;/p&gt;

&lt;p&gt;为什么需要稳定币？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通加密货币（如 BTC、ETH）价格波动大。&lt;/li&gt;
  &lt;li&gt;在 DeFi、交易所、支付场景中，需要&lt;strong&gt;“稳定价值媒介”&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;稳定币弥合了法币和加密世界之间的桥梁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;稳定币的主要类型&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;锚定方式&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;举例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;法币抵押型&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;由真实的美元等资产托管担保&lt;/td&gt;
      &lt;td&gt;1:1 抵押，价格最稳定&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://tether.to/&quot;&gt;USDT&lt;/a&gt;、USDC、BUSD（已停发）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;加密资产抵押型&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;抵押加密资产（如 ETH）&lt;/td&gt;
      &lt;td&gt;抵押率通常超过 100% 以防价格波动&lt;/td&gt;
      &lt;td&gt;DAI、sUSD&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;算法稳定币&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;依靠算法自动调节供需&lt;/td&gt;
      &lt;td&gt;不依赖任何抵押物，价格容易崩盘&lt;/td&gt;
      &lt;td&gt;UST（已崩溃）、Ampleforth&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;商品挂钩型&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;锚定黄金、石油等商品&lt;/td&gt;
      &lt;td&gt;类似“加密黄金”&lt;/td&gt;
      &lt;td&gt;PAXG（锚定黄金）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;比如 USDT,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户用 &lt;strong&gt;美元等法币&lt;/strong&gt;存入银行账户，公司再在区块链上发行等额稳定币。&lt;/li&gt;
  &lt;li&gt;理论上你可以随时用 1 枚 USDT 换回 1 美元。公司会公布审计报告，证明“币=钱”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;抵押-vs-质押&quot;&gt;抵押 vs 质押&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;「抵押（Collateral）」&lt;/strong&gt; vs &lt;strong&gt;「质押（Staking）」&lt;/strong&gt;，它们虽然中文看起来相似，但在区块链中的含义、目的和机制&lt;strong&gt;完全不同&lt;/strong&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;抵押（Collateral）&lt;/th&gt;
      &lt;th&gt;质押（Staking）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;功能&lt;/td&gt;
      &lt;td&gt;担保借贷 / 铸币&lt;/td&gt;
      &lt;td&gt;参与区块链共识、赚奖励&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;用户收益&lt;/td&gt;
      &lt;td&gt;借出资产（如 DAI）&lt;/td&gt;
      &lt;td&gt;区块奖励、手续费&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;资产控制&lt;/td&gt;
      &lt;td&gt;有清算风险&lt;/td&gt;
      &lt;td&gt;有锁仓期、作恶惩罚&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;示例&lt;/td&gt;
      &lt;td&gt;抵押 ETH 得到 DAI&lt;/td&gt;
      &lt;td&gt;质押 ETH 获得年化收益&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;托管型与非托管型钱包对比&quot;&gt;托管型与非托管型钱包对比&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;托管型服务&lt;/th&gt;
      &lt;th&gt;非托管型服务&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;私钥&lt;/td&gt;
      &lt;td&gt;第三方所有权&lt;/td&gt;
      &lt;td&gt;钱包持有者所有权&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;辅助功能&lt;/td&gt;
      &lt;td&gt;注册帐户&lt;/td&gt;
      &lt;td&gt;向所有人开放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;交易成本&lt;/td&gt;
      &lt;td&gt;通常较高&lt;/td&gt;
      &lt;td&gt;通常较低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;安全性&lt;/td&gt;
      &lt;td&gt;通常较低&lt;/td&gt;
      &lt;td&gt;通常较高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;通常较高&lt;/td&gt;
      &lt;td&gt;通常较低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://academy.binance.com/zh/articles/what-is-kyc-know-your-customer&quot;&gt;身份认证(KYC)&lt;/a&gt;要求&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">binance课程笔记</summary></entry><entry><title type="html">阅读区块链入门指南笔记</title><link href="https://mafulong.github.io/2025/06/27/%E9%98%85%E8%AF%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="阅读区块链入门指南笔记" /><published>2025-06-27T00:00:00+08:00</published><updated>2025-06-27T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/27/%E9%98%85%E8%AF%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://mafulong.github.io/2025/06/27/%E9%98%85%E8%AF%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/">&lt;h1 id=&quot;阅读区块链入门指南笔记&quot;&gt;阅读区块链入门指南笔记&lt;/h1&gt;

&lt;p&gt;以下为阅读《&lt;a href=&quot;https://guide.pseudoyu.com/zh/&quot;&gt;区块链入门指南&lt;/a&gt;》 的笔记。&lt;/p&gt;

&lt;h1 id=&quot;区块链基础知识与关键技术&quot;&gt;区块链基础知识与关键技术&lt;/h1&gt;

&lt;h3 id=&quot;共识机制&quot;&gt;共识机制&lt;/h3&gt;

&lt;p&gt;区块链网络是由多个网络节点组成的，其中每个节点都存有一份信息备份，那它们是如何对交易达成一致的呢？也就是说，它们作为独立的节点，需要有一种机制来保障互相信任，这就是共识机制。&lt;/p&gt;

&lt;p&gt;常用的共识机制有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PoW(Proof of Work)&lt;/code&gt;工作量证明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PoS(Proof of Stake)&lt;/code&gt;权益证明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DPoS(Delegated Proof of Stake&lt;/code&gt;委任权益证明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBFT(Delegated Byzantine Fault Tolerance)&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;比特币/以太坊主要采用的是工作量证明机制，通过算力比拼来增加恶意节点的作恶成本。通过动态调整挖矿的难度来让一笔交易时间控制在 10 分钟左右（6 个确认），但随着比特币挖矿越来越火热，消耗资源越来越多，对环境造成破坏；有些矿池拥有大量资源，也会造成一些中心化的风险。&lt;/p&gt;

&lt;p&gt;权益证明机制则是通过权益（一般是代币）持有者进行投票来达成共识。这种机制不需要像工作量证明一样进行大量的算力比拼，但是也有一些风险，称为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing at Stake&lt;/code&gt;问题，很多权益持有者会在所有区块都投注并从中获利。为了解决这个问题，系统设置了一些规则，如对同时在多个链创建区块的用户/在错误链上创建区块的用户设置一些惩罚机制。目前以太坊正在向这种共识机制转变。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EOS&lt;/code&gt;则采用了委任权益证明，选出一些代表性的节点来进行投票，这种方式目的是优化社区投票的效率和结果，但带来了一些中心化的风险。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBFT&lt;/code&gt;共识机制则是通过对节点分配不同的角色来达成共识，这样可以很大程度降低开销和避免分叉，但是也有核心角色作恶的风险。&lt;/p&gt;

&lt;h1 id=&quot;比特币核心技术解读&quot;&gt;比特币核心技术解读&lt;/h1&gt;

&lt;p&gt;节点分为全节点和轻节点两种，早期所有的节点都是全节点，但随着数据量越来越大，运行在手机或平板等设备上的比特币客户端不需要存储整个区块链的信息，称为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Simplified Payment Verification(SPV)&lt;/code&gt;节点，也叫轻节点。&lt;/p&gt;

&lt;p&gt;Merkle Tree（默克尔树）是区块链系统中非常核心的数据结构，主要用于&lt;strong&gt;数据完整性验证&lt;/strong&gt;和&lt;strong&gt;提高效率&lt;/strong&gt;。它在比特币、以太坊等主流区块链中都有使用。Merkle Tree 是一种&lt;strong&gt;哈希二叉树&lt;/strong&gt;，每个叶子节点是一段数据（如交易记录）的哈希值，每个非叶子节点是其两个子节点哈希值的再哈希：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数据完整性验证&lt;/td&gt;
      &lt;td&gt;一笔交易变动会导致整棵树根变动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;轻节点验证&lt;/td&gt;
      &lt;td&gt;SPV 客户端只需 Merkle 证明即可验证交易&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;节省带宽&lt;/td&gt;
      &lt;td&gt;不用全量同步交易数据&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Merkle Tree 可以在不下载全部区块数据的情况下验证某笔交易是否包含在一个区块中。&lt;/p&gt;

&lt;p&gt;这叫做 &lt;strong&gt;SPV（Simplified Payment Verification）轻节点机制&lt;/strong&gt;，比特币钱包常用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只需下载：
    &lt;ul&gt;
      &lt;li&gt;该交易的哈希值&lt;/li&gt;
      &lt;li&gt;到 Merkle Root 的“路径节点”（叫 Merkle Proof）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了钱包（和资产）后，就可以开始交易了。我们来通过一个典型的比特币交易来理解这一流程：&lt;/p&gt;

&lt;p&gt;A 和 B 都拥有一个比特币钱包地址（可以用 Bitcoin Client 生成，原理如上），假设 A 要给 B 转账 5 个 BTC，A 需要得到 B 的钱包地址，然后用自己的私钥对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A-&amp;gt;B转账5个BTC&lt;/code&gt;这笔交易签名（因为 A 的私钥仅有自己知道，所以拥有私钥则是拥有钱包资产的归属权）；然后发布这笔交易，在比特币系统中发起交易需要支付小额矿工费作为交易手续费；矿工会开始验证这笔交易的合法性，得到六个确认后交易就可以被比特币账本所接受，整个验证过程大约 10 分钟。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比特币系统中怎么避免双重花费呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比特币采用了一种叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO(Unspent Transaction Outputs)&lt;/code&gt;的概念，当一个用户收到一笔 BTC 交易时，会计入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;在这个示例中，A 想要给 B 转账 5 个 BTC，A 的这 5 个 BTC 可能来自于两个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;(2 BTC + 3 BTC)，因此 A 在转账给 B 时，矿工需要检验的是这两笔&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;在这笔交易之前有没有被花掉，如果检测已经被花费了，则交易不合法。&lt;/p&gt;

&lt;p&gt;此外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;有一个很重要的特性，不可分割，假如 A 有 20 个 BTC，他想转账 5 个 BTC 给 B，那交易会先将 20 个 BTC 作为输入，然后产生两个输出，一个向 B 转账 5 个 BTC，一个返还给 A 剩下的 15 个 BTC，因此，A 又拥有了一笔价值为 15 BTC 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;；如果单个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;不够支付，则可以组合多个形成输入，但总额一定要大于交易额。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;矿工怎么验证交易发起者有足够的余额呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题看起来很简单，第一反应是像支付宝这样查询一下余额是否足够就可以。但比特币是一种基于交易的账本模式，并没有帐户概念，因此并不能直接查询余额，要想知道一个帐户的剩余资产，则需要回顾以前所有的交易，并且找到所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;并相加。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;挖矿难度是如何调整的呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统会在每产生 2016 个区块时（约两周）调整一次目标阈值，存在块头中，全网所有节点需要遵从新的难度进行挖矿，如果恶意节点不调整代码中的 target 的话，诚实的矿工则不会认可&lt;/p&gt;

&lt;h1 id=&quot;ethereum-核心技术解读&quot;&gt;Ethereum 核心技术解读&lt;/h1&gt;

&lt;p&gt;比特币作为一种去中心化的数字货币，是极其成功的，但受限于比特币脚本（非图灵完备，只能处理一些简单的逻辑），并不能处理很复杂的业务。而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;引入了智能合约，使去中心化的概念能够应用于更丰富的应用场景，因此也被称为区块链 2.0。&lt;/p&gt;

&lt;p&gt;简单来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;是一个开源的去中心化系统，使用区块链来存储系统状态变化，因此也被称为“世界计算机”；它支持开发者在区块链上部署运行不可变的程序，称为智能合约，因此可以支持广泛的应用场景；它使用数字货币&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ether&lt;/code&gt;来衡量系统资源消耗，激励更多人参与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;系统建设。&lt;/p&gt;

&lt;h3 id=&quot;去中心化应用-dapp&quot;&gt;去中心化应用 DApp&lt;/h3&gt;

&lt;p&gt;狭义来说，DApp 其实就是一个集成了用户界面、支持智能合约、运行于以太坊区块链上的应用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202506280932337.png&quot; alt=&quot;ethereum_architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;应用实例部署在区块链网络上（智能合约运行于区块链虚拟机中），而 Web 程序只需要通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web3.js&lt;/code&gt;对区块链网络进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RPC&lt;/code&gt;远程调用，这样用户就可以通过浏览器（DApp 浏览器或 MetaMask 等插件工具）访问去中心化服务应用了。&lt;/p&gt;

&lt;h3 id=&quot;账户&quot;&gt;账户&lt;/h3&gt;

&lt;p&gt;当我们需要登录一个网站或系统（比如邮箱）时，往往需要一个帐号和一个密码，密码通过加密算法以暗文的形式存储在中心化的数据库中。然而，以太坊是一个去中心化的系统，那是怎么生成账户的呢？&lt;/p&gt;

&lt;p&gt;和比特币系统原理类似&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先生成一个仅有自己知道的私钥，假设为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sk&lt;/code&gt;，采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECDSA(Elliptic Curve Digital Signature Algorithm)&lt;/code&gt;椭圆曲线算法生成对应的公钥&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keccak256&lt;/code&gt;算法对公钥&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;求哈希值&lt;/li&gt;
  &lt;li&gt;截取后 160 位作为以太坊的地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户的私钥和地址一起组成了以太坊的账户，可以存储余额、发起交易等（比特币的余额是通过计算所有的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTXO&lt;/code&gt;得到的，而不是像以太坊一样存储在账户中）。&lt;/p&gt;

&lt;p&gt;其实&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;账户分为两种类型，上述方式生成的叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Externally Owned Accounts(EOA)&lt;/code&gt;，外部账户，也就是常规用户拥有的账户，主要是用来发送/接收&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ether&lt;/code&gt;代币或者向智能合约发送交易（即调用智能合约）。&lt;/p&gt;

&lt;p&gt;而另一种则是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Contract Accounts&lt;/code&gt;，合约账户，不同于外部账户，这种账户是没有对应的私钥的，而是在部署合约的时候生成的，存储智能合约代码。值得注意的是，合约账户必须要被外部账户或者其他合约调用才能够发送或接收&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ether&lt;/code&gt;，而不能自己主动执行交易。&lt;/p&gt;

&lt;h3 id=&quot;钱包&quot;&gt;钱包&lt;/h3&gt;

&lt;p&gt;存储和管理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;账户的软件/插件称为钱包，提供了诸如交易签名、余额管理等功能。钱包生成主要有两种方式，非确定性随机生成或根据随机种子生成。&lt;/p&gt;

&lt;h3 id=&quot;智能合约&quot;&gt;智能合约&lt;/h3&gt;

&lt;p&gt;上文提到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;区块链不仅仅存储交易信息，还会存储与执行智能合约代码。&lt;/p&gt;

&lt;p&gt;智能合约控制应用和交易逻辑，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;系统中的智能合约采用专属&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt;语言，语法类似于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;，除此之外，还有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vyper&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bamboo&lt;/code&gt;等编程语言。智能合约代码会被编译为字节码并部署至区块链中，一旦上链则不可以再编辑。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EVM&lt;/code&gt;作为一个智能合约执行环境，能够保障执行结果的确定性。&lt;/p&gt;

&lt;h3 id=&quot;交易&quot;&gt;交易&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;中，一个典型的交易是怎么样的呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开发者部署智能合约至区块链&lt;/li&gt;
  &lt;li&gt;DApp 实例化合约、传入相应值以执行合约&lt;/li&gt;
  &lt;li&gt;DApp 对交易进行数字签名&lt;/li&gt;
  &lt;li&gt;本地对交易进行验证&lt;/li&gt;
  &lt;li&gt;广播交易至网络中&lt;/li&gt;
  &lt;li&gt;矿工节点接收交易并进行验证&lt;/li&gt;
  &lt;li&gt;矿工节点确认可信区块后广播至网络中&lt;/li&gt;
  &lt;li&gt;本地节点与网络进行同步，接收新区块&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;架构&quot;&gt;架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202506280931004.png&quot; alt=&quot;ethereum_architecture_simple&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;采用的是一种&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Order - Execute - Validate - Update State&lt;/code&gt;的系统架构。在这种架构下，当产生一笔新的交易，矿工会进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PoW&lt;/code&gt;工作量证明机制的运算；验证完成后，将区块通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gossip&lt;/code&gt;协议广播至网络中；网络中的其他节点接收到新区块后，也会对区块进行验证；最终，提交至区块链，更新状态。&lt;/p&gt;

&lt;h1 id=&quot;ethereum-mptmerkle-patricia-tries&quot;&gt;Ethereum MPT(Merkle Patricia Tries)&lt;/h1&gt;

&lt;p&gt;Ethereum 的 MPT（Merkle Patricia Trie）是以太坊中用于存储和验证数据结构的核心组成部分，它结合了 &lt;strong&gt;Merkle Tree&lt;/strong&gt; 与 &lt;strong&gt;Patricia Trie&lt;/strong&gt; 的优点，具备以下功能：&lt;/p&gt;

&lt;p&gt;MPT（Merkle Patricia Trie）是一个&lt;strong&gt;确定性前缀树&lt;/strong&gt;（deterministic prefix tree），带有加密哈希功能，主要用于：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;账户状态树（state trie）&lt;/strong&gt;：存储每个账户的 nonce、余额、存储根和代码哈希。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;存储树（storage trie）&lt;/strong&gt;：每个合约账户有自己的 trie，存储变量的 key-value。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;交易树（transaction trie）&lt;/strong&gt;：按顺序存储一个区块内所有交易。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;收据树（receipt trie）&lt;/strong&gt;：记录交易结果（gas 用量、日志等）。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;哈希结构&lt;/td&gt;
      &lt;td&gt;所有节点都以 RLP 编码后，再进行 Keccak256 哈希计算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可验证性&lt;/td&gt;
      &lt;td&gt;通过 Merkle Proof 机制，可验证某个 key 是否存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;前缀压缩&lt;/td&gt;
      &lt;td&gt;Patricia Trie 会合并重复路径，提高查找效率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;不可变性&lt;/td&gt;
      &lt;td&gt;修改数据后整棵树哈希变化，因此可防篡改、可回滚&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;QA:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pactricia Trie 是路径压缩的前缀树。 Trie 结构比较浪费存储空间，当键值对分布稀疏时效率较低，而以太坊的账户地址是 40 位十六进制数，地址约为 2^160 种，极其稀疏（防止哈希碰撞）。因此，需要对 Trie 结构进行路径压缩，也就是 Pactricia Trie，经过压缩后，树的高度明显减少，空间和效率都得到提升。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">阅读区块链入门指南笔记</summary></entry><entry><title type="html">京东读书上海图书馆</title><link href="https://mafulong.github.io/2025/06/12/%E4%BA%AC%E4%B8%9C%E8%AF%BB%E4%B9%A6%E4%B8%8A%E6%B5%B7%E5%9B%BE%E4%B9%A6%E9%A6%86/" rel="alternate" type="text/html" title="京东读书上海图书馆" /><published>2025-06-12T00:00:00+08:00</published><updated>2025-06-12T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/12/%E4%BA%AC%E4%B8%9C%E8%AF%BB%E4%B9%A6%E4%B8%8A%E6%B5%B7%E5%9B%BE%E4%B9%A6%E9%A6%86</id><content type="html" xml:base="https://mafulong.github.io/2025/06/12/%E4%BA%AC%E4%B8%9C%E8%AF%BB%E4%B9%A6%E4%B8%8A%E6%B5%B7%E5%9B%BE%E4%B9%A6%E9%A6%86/">&lt;h2 id=&quot;京东读书上海图书馆&quot;&gt;京东读书上海图书馆&lt;/h2&gt;

&lt;p&gt;微信公众号 / 小程序: 上海图书馆&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="DailyLife" /><category term="DailyLife" /><summary type="html">京东读书上海图书馆</summary></entry><entry><title type="html">钱包</title><link href="https://mafulong.github.io/2025/06/12/%E9%92%B1%E5%8C%85/" rel="alternate" type="text/html" title="钱包" /><published>2025-06-12T00:00:00+08:00</published><updated>2025-06-12T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/12/%E9%92%B1%E5%8C%85</id><content type="html" xml:base="https://mafulong.github.io/2025/06/12/%E9%92%B1%E5%8C%85/">&lt;h2 id=&quot;钱包&quot;&gt;钱包&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;钱包系统架构设计,包括热/冷钱包、签名服务、Key管理、多签方案;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;岗位要求:

1、计算机、信息安全或相关专业本科及以上学历,5年以上软件开发经验,5年以上数字资产钱包开发经验;
2、熟悉区块链底层原理,对账户模型有深入理解;
3、精通一种或多种主流开发语言(如Go、Rust、Java、TypeScript);
4、熟练掌握钱包系统架构设计,包括热/冷钱包、签名服务、Key管理、多签方案;
5、有实际集成并运维HSM(如Thales,Utimaco,YubiHSM等)的经验;
6、熟悉冷钱包构建流程,包括离线签名机制、二维码或USB数据传输、安全审批等;
7、理解MPC(多方安全计算)、Threshold Signature等现代密码技术先;
8、对安全合规有强烈意识,有应对监管合规要求(如SOC2、ISO27001、FATFTravelRule)的项目经验者优先；


加分项:

1、有从0到1搭建托管级钱包系统的经验;
2、熟悉Fireblocks、Copper、Anchorage、Ledger Vault等托管方案;
3、有数字资产交易所、托管机构、银行系统等金融类系统开发经验;
4、有参与或主导开源钱包项目经历者优先;
5、有国内外合规要求(如土耳其、欧盟、香港、新加坡等)落地经验者优先；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fulong Ma</name></author><category term="Web3" /><category term="Web3" /><summary type="html">钱包</summary></entry><entry><title type="html">免费开源远程操控 Rustdesk</title><link href="https://mafulong.github.io/2025/06/08/%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7/" rel="alternate" type="text/html" title="免费开源远程操控 Rustdesk" /><published>2025-06-08T00:00:00+08:00</published><updated>2025-06-08T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/08/%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7</id><content type="html" xml:base="https://mafulong.github.io/2025/06/08/%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7/">&lt;h2 id=&quot;免费开源远程操控rustdesk&quot;&gt;免费开源远程操控Rustdesk&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;官网：https://rustdesk.com&lt;/li&gt;
  &lt;li&gt;自建服务器。免费&lt;/li&gt;
  &lt;li&gt;控制测可浏览器控制。&lt;/li&gt;
  &lt;li&gt;除了控制电脑，还可以控制手机，因为国内手机容易被诈骗所以封了 IP，控制手机要开手机开 vpn。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">免费开源远程操控Rustdesk</summary></entry><entry><title type="html">intellij激活</title><link href="https://mafulong.github.io/2025/06/06/intellij%E6%BF%80%E6%B4%BB/" rel="alternate" type="text/html" title="intellij激活" /><published>2025-06-06T00:00:00+08:00</published><updated>2025-06-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/06/06/intellij%E6%BF%80%E6%B4%BB</id><content type="html" xml:base="https://mafulong.github.io/2025/06/06/intellij%E6%BF%80%E6%B4%BB/">&lt;h2 id=&quot;intellij激活&quot;&gt;intellij激活&lt;/h2&gt;

&lt;p&gt;参考: &lt;a href=&quot;https://www.yuque.com/zimengfengling/tcb2sg/qh1rp38pxfv0451f?singleDoc#&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装包多版本下载地址（自选下载）： https://www.jetbrains.com/goland/download/other.html&lt;/p&gt;

&lt;p&gt;学习成功教程1(2019-2024win和 MAC c2025.1)：&lt;/p&gt;

&lt;p&gt;苹果系统MAC用这个↓ https://www.yuque.com/zimengfengling/tcb2sg/qh1rp38pxfv0451f?singleDoc#&lt;/p&gt;

&lt;p&gt;注意：学习过程中如有红色文字报错请用语雀文档中的《备用方案》，再试一次即可。&lt;/p&gt;

&lt;p&gt;最新↓ 2025 2025 2025 2025用这个↓只有Windows。 学习成功教程2(2024-2025）：  http://113.44.197.69/ide/gl/&lt;/p&gt;

&lt;p&gt;https://www.yuque.com/zimengfengling/tcb2sg/fg8bsgzmbsr0gosg?singleDoc#%20%E3%80%8AMac%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E3%80%8B&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="Tools" /><category term="Tools" /><summary type="html">intellij激活</summary></entry><entry><title type="html">浦东公租房</title><link href="https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF/" rel="alternate" type="text/html" title="浦东公租房" /><published>2025-05-15T00:00:00+08:00</published><updated>2025-05-15T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF</id><content type="html" xml:base="https://mafulong.github.io/2025/05/15/%E6%B5%A6%E4%B8%9C%E5%85%AC%E7%A7%9F%E6%88%BF/">&lt;h2 id=&quot;公租房&quot;&gt;公租房&lt;/h2&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/720027504&lt;/p&gt;

&lt;h2 id=&quot;浦东地图&quot;&gt;浦东地图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505152350009.png&quot; alt=&quot;image-20250515235026893&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;房源&quot;&gt;房源&lt;/h2&gt;

&lt;h3 id=&quot;公租房-1&quot;&gt;公租房&lt;/h3&gt;

&lt;h4 id=&quot;仁文公寓&quot;&gt;仁文公寓&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=9765&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3700&lt;/strong&gt;元/月 53平。&lt;/p&gt;

&lt;p&gt;一室一厅，停车300一月。&lt;/p&gt;

&lt;p&gt;靠近二甲 上海明珠医院。&lt;/p&gt;

&lt;p&gt;48分钟，41km， 26分钟。&lt;/p&gt;

&lt;h4 id=&quot;浦三路930弄-艾东苑&quot;&gt;浦三路930弄 艾东苑&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=8613486F-AA0F-4AD6-9BD1-B6D62BCFA29B&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;49.87&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4128&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;48分钟，44km，17分钟，12km.&lt;/p&gt;

&lt;h4 id=&quot;川和路399弄张江兴科苑&quot;&gt;川和路399弄（张江兴科苑）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;4081&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;47.72&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 205&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-03-16&lt;/li&gt;
  &lt;li&gt;地址： 川和路399弄（张江兴科苑）/11-12号/02楼/205&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没有车位。&lt;/p&gt;

&lt;p&gt;52分钟，48km， 14分钟，4.5km。&lt;/p&gt;

&lt;h3 id=&quot;公租房三林&quot;&gt;公租房三林&lt;/h3&gt;

&lt;h4 id=&quot;三舒路-城林美苑&quot;&gt;三舒路 城林美苑&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=706833db-607b-4f3c-846b-96f144c516d7&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2850&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;67.55&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 08楼&lt;/p&gt;

&lt;p&gt;房号： 806&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 三舒路33弄（城林美苑）/04号/08楼/806&lt;/li&gt;
  &lt;li&gt;室内配套：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;52 分 ，18km, 32 分钟。&lt;/p&gt;

&lt;h4 id=&quot;永泰路136弄&quot;&gt;永泰路136弄&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=B3EC3477-2161-4A31-8441-ACD494761328&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2963&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：2准入资格证202517140007390 （2025-05-19）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;51.61&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 203&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 永泰路136弄/33号/2楼/203&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;56mins, 27mins.&lt;/p&gt;

&lt;h4 id=&quot;三旋路506弄绿波家园&quot;&gt;三旋路506弄（绿波家园&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=34BE3519-D644-4915-AC8F-DE4864AF83FB&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2793&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：9准入资格证202317140008848 （2023-06-07）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;64.99&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 21楼&lt;/p&gt;

&lt;p&gt;房号： 2104&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 三旋路506弄（绿波家园）/19号/21楼/2104&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;52mins, 31mins。&lt;/p&gt;

&lt;h4 id=&quot;杨南路&quot;&gt;杨南路&lt;/h4&gt;

&lt;p&gt;https://select.pdgzf.com/houseDetails?Id=8633&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3365&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：2准入资格证202317140018617 （2023-11-30）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;一室&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;56.80&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 02楼&lt;/p&gt;

&lt;p&gt;房号： 202&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-22&lt;/li&gt;
  &lt;li&gt;地址： 杨南路694弄/81号/2楼/202&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;55mins, 25mins&lt;/p&gt;

&lt;h4 id=&quot;和炯路77弄盛世南苑&quot;&gt;和炯路77弄（盛世南苑）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;2633&lt;/strong&gt;元/月&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;已选：6准入资格证202317140009994 （2023-06-25）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;户型： &lt;strong&gt;二室一厅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面积： &lt;strong&gt;65.26&lt;/strong&gt; 平方米&lt;/p&gt;

&lt;p&gt;楼层： 01楼&lt;/p&gt;

&lt;p&gt;房号： 101&lt;/p&gt;

&lt;p&gt;朝向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;起租日期： 2025-05-09&lt;/li&gt;
  &lt;li&gt;地址： 和炯路77弄（盛世南苑）/13号/1楼/101&lt;/li&gt;
  &lt;li&gt;室内配套：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;55mins, 32mins&lt;/p&gt;

&lt;h3 id=&quot;非公租房&quot;&gt;非公租房&lt;/h3&gt;

&lt;h4 id=&quot;高科苑&quot;&gt;高科苑&lt;/h4&gt;

&lt;p&gt;高科苑，就在复旦大学和曙光医院旁边，距离中科路不远，这个小区环境不错，可以租一室一厅&lt;/p&gt;

&lt;p&gt;小区没有二房东，是张江高科集团建的对外出租，不存在二房东改造问题&lt;/p&gt;

&lt;p&gt;地下车库地上车库都有，停车费也不贵&lt;/p&gt;

&lt;p&gt;52分钟，50km, 距离公司 3km&lt;/p&gt;

&lt;h4 id=&quot;张江万科翡翠公园&quot;&gt;张江万科翡翠公园&lt;/h4&gt;

&lt;p&gt;53分钟，50km, 14分钟，4.5km。&lt;/p&gt;

&lt;h3 id=&quot;保租房&quot;&gt;保租房&lt;/h3&gt;

&lt;h4 id=&quot;纳仕&quot;&gt;纳仕&lt;/h4&gt;

&lt;p&gt;纳什国际，新的&lt;/p&gt;

&lt;p&gt;贵的不行&lt;/p&gt;</content><author><name>Fulong Ma</name></author><category term="DailyLife" /><category term="DailyLife" /><summary type="html">公租房</summary></entry><entry><title type="html">Spring AOP</title><link href="https://mafulong.github.io/2025/05/06/Spring-AOP/" rel="alternate" type="text/html" title="Spring AOP" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20AOP</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-AOP/">&lt;h2 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h2&gt;

&lt;h2 id=&quot;谈谈自己对于-aop-的了解&quot;&gt;谈谈自己对于 AOP 的了解&lt;/h2&gt;

&lt;p&gt;AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。&lt;/p&gt;

&lt;p&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;

&lt;p&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;strong&gt;JDK Proxy&lt;/strong&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;strong&gt;Cglib&lt;/strong&gt; 生成一个被代理对象的子类来作为代理&lt;/p&gt;

&lt;p&gt;当然你也可以使用 &lt;strong&gt;AspectJ&lt;/strong&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;

&lt;p&gt;AOP 切面编程涉及到的一些专业术语：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;术语&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;目标(Target)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被通知的对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代理(Proxy)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;连接点(JoinPoint)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切入点(Pointcut)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通知(Advice)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;切面(Aspect)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Weaving(织入)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Spring&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AOP&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AspectJ&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;注解&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;如&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;来声明切面&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;它是单独的aop框架&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;可以在非spring里使用&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;和spring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aop是两套&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;它是编译时织入&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使用代理方式实现&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AOP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JDK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;动态代理&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;接口型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CGLIB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;动态代理&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;类型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;aop-常见的通知类型有哪些&quot;&gt;AOP 常见的通知类型有哪些？&lt;/h2&gt;

&lt;p&gt;AOP 一般有 &lt;strong&gt;5 种&lt;/strong&gt;环绕方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前置通知 (@Before)&lt;/li&gt;
  &lt;li&gt;返回通知 (@AfterReturning)&lt;/li&gt;
  &lt;li&gt;异常通知 (@AfterThrowing)&lt;/li&gt;
  &lt;li&gt;后置通知 (@After)&lt;/li&gt;
  &lt;li&gt;环绕通知 (@Around)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062358585.png&quot; alt=&quot;三分恶面渣逆袭：环绕方式&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;aspectj-是什么&quot;&gt;AspectJ 是什么？&lt;/h2&gt;

&lt;h3 id=&quot;aspectj&quot;&gt;AspectJ&lt;/h3&gt;

&lt;p&gt;AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 表示这是一个切面类&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Spring 管理该类的 Bean&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 定义一个切入点，匹配 HelloService 中的所有方法&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Pointcut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;execution(* com.example.demo.HelloService.*(..))&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;helloServiceMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 方法执行之前的通知（Before Advice）&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloServiceMethods()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logBefore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Method is about to execute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 方法执行之后的通知（After Advice）&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@After&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloServiceMethods()&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logAfter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Method has executed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;spring-aop-和-aspectj-aop-有什么区别&quot;&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;Spring AOP&lt;/th&gt;
      &lt;th&gt;AspectJ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;增强方式&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时增强（基于动态代理）&lt;/td&gt;
      &lt;td&gt;编译时增强、类加载时增强（直接操作字节码）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;切入点支持&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;方法级（Spring Bean 范围内，不支持 final 和 staic 方法）&lt;/td&gt;
      &lt;td&gt;方法级、字段、构造器、静态方法等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;运行时依赖代理，有一定开销，切面多时性能较低&lt;/td&gt;
      &lt;td&gt;运行时无代理开销，性能更高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;简单，易用，适合大多数场景&lt;/td&gt;
      &lt;td&gt;功能强大，但相对复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Spring 应用下比较简单的 AOP 需求&lt;/td&gt;
      &lt;td&gt;高性能、高复杂度的 AOP 需求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;如何选择？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能考量&lt;/strong&gt;：AspectJ 支持更复杂的 AOP 场景，Spring AOP 更简单易用。如果你需要增强 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 方法、静态方法、字段访问、构造器调用等，或者需要在非 Spring 管理的对象上应用增强逻辑，AspectJ 是唯一的选择。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能考量&lt;/strong&gt;：切面数量较少时两者性能差异不大，但切面较多时 AspectJ 性能更优。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一句话总结&lt;/strong&gt;：简单场景优先使用 Spring AOP；复杂场景或高性能需求时，选择 AspectJ。&lt;/p&gt;

&lt;p&gt;Spring AOP 属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;运行时增强&lt;/code&gt;，主要具有如下特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现&lt;/li&gt;
  &lt;li&gt;Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现&lt;/li&gt;
  &lt;li&gt;在性能上，由于 Spring AOP 是基于&lt;strong&gt;动态代理&lt;/strong&gt;来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。&lt;/li&gt;
  &lt;li&gt;Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AspectJ 是一个易用的功能强大的 AOP 框架，属于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;编译时增强&lt;/code&gt;， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。&lt;/p&gt;

&lt;p&gt;AspectJ 属于&lt;strong&gt;静态织入&lt;/strong&gt;，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。&lt;/li&gt;
  &lt;li&gt;编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。&lt;/li&gt;
  &lt;li&gt;类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sprint-aop&quot;&gt;Sprint AOP&lt;/h2&gt;

&lt;h3 id=&quot;spring-aop-发生在什么时候&quot;&gt;Spring AOP 发生在什么时候？&lt;/h3&gt;

&lt;p&gt;Spring AOP 基于运行时代理机制，这意味着 Spring AOP 是在运行时通过动态代理生成的，而不是在编译时或类加载时生成的。&lt;/p&gt;

&lt;p&gt;在 Spring 容器初始化 Bean 的过程中，Spring AOP 会检查 Bean 是否需要应用切面。如果需要，Spring 会为该 Bean 创建一个代理对象，并在代理对象中织入切面逻辑。这一过程发生在 Spring 容器的后处理器（BeanPostProcessor）阶段。&lt;/p&gt;

&lt;h3 id=&quot;说说-jdk-动态代理和-cglib-代理&quot;&gt;说说 JDK 动态代理和 CGLIB 代理？&lt;/h3&gt;

&lt;p&gt;AOP 是通过&lt;a href=&quot;https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg&quot;&gt;动态代理&lt;/a&gt;实现的，代理方式有两种：JDK 动态代理和 CGLIB 代理。&lt;/p&gt;

&lt;p&gt;①、JDK 动态代理是基于接口的代理，只能代理实现了接口的类。&lt;/p&gt;

&lt;p&gt;使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：只需依赖 JDK 自带的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类，不需要额外的库；缺点：只能代理接口，不能代理类本身。&lt;/p&gt;

&lt;p&gt;②、CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。&lt;/p&gt;

&lt;p&gt;使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。&lt;/p&gt;

&lt;p&gt;优点：可以代理没有实现接口的类，灵活性更高；缺点：需要依赖 CGLIB 库，创建代理对象的开销相对较大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;只能代理实现了接口的类。它的实现基于 Java 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.lang.reflect.Proxy&lt;/code&gt; 类和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InvocationHandler&lt;/code&gt; 接口，&lt;strong&gt;运行时在内存中动态生成代理类的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 文件并加载执行&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;JDK Proxy 是通过在内存中动态创建一个实现了同样接口的代理类来“代理”目标对象的方法调用。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;比较维度&lt;/th&gt;
      &lt;th&gt;JDK 动态代理&lt;/th&gt;
      &lt;th&gt;CGLIB 动态代理&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;代理对象&lt;/td&gt;
      &lt;td&gt;必须实现接口&lt;/td&gt;
      &lt;td&gt;不需要接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;实现方式&lt;/td&gt;
      &lt;td&gt;JDK Proxy + 反射&lt;/td&gt;
      &lt;td&gt;继承 + 字节码增强&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;性能（早期）&lt;/td&gt;
      &lt;td&gt;较低&lt;/td&gt;
      &lt;td&gt;较高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;限制&lt;/td&gt;
      &lt;td&gt;不能代理类本身&lt;/td&gt;
      &lt;td&gt;不能代理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 类/方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Spring 默认策略&lt;/td&gt;
      &lt;td&gt;有接口：JDK 动态代理无接口：CGLIB&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;选择-cglib-还是-jdk-动态代理&quot;&gt;选择 CGLIB 还是 JDK 动态代理？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果目标对象没有实现任何接口，则只能使用 CGLIB 代理。如果目标对象实现了接口，通常首选 JDK 动态代理。&lt;/li&gt;
  &lt;li&gt;虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能。对于性能敏感且代理对象创建频率不高的场景，可以考虑使用 CGLIB。&lt;/li&gt;
  &lt;li&gt;JDK 动态代理是 Java 原生支持的，不需要额外引入库。而 CGLIB 需要将 CGLIB 库作为依赖加入项目中。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Spring AOP</summary></entry><entry><title type="html">Spring IoC</title><link href="https://mafulong.github.io/2025/05/06/Spring-IoC/" rel="alternate" type="text/html" title="Spring IoC" /><published>2025-05-06T00:00:00+08:00</published><updated>2025-05-06T00:00:00+08:00</updated><id>https://mafulong.github.io/2025/05/06/Spring%20IoC</id><content type="html" xml:base="https://mafulong.github.io/2025/05/06/Spring-IoC/">&lt;h2 id=&quot;sprint-ioc&quot;&gt;Sprint IoC&lt;/h2&gt;

&lt;h3 id=&quot;谈谈自己对于-spring-ioc-的了解&quot;&gt;谈谈自己对于 Spring IoC 的了解&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;IoC（Inversion of Control:控制反转）&lt;/strong&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么叫控制反转？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;控制&lt;/strong&gt;：指的是对象创建（实例化、管理）的权力&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;反转&lt;/strong&gt;：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;

&lt;p&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;

&lt;p&gt;IOC 是一种思想，&lt;strong&gt;DI&lt;/strong&gt; 是实现 IOC 的具体方式，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。&lt;/p&gt;

&lt;h3 id=&quot;将一个类声明为-bean-的注解有哪些&quot;&gt;将一个类声明为 Bean 的注解有哪些?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;：通用的注解，可标注任意类为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 组件。如果一个 Bean 不知道属于哪个层，可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解标注。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Repository&lt;/code&gt; : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Service&lt;/code&gt; : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Controller&lt;/code&gt; : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 层返回数据给前端页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;component-和-bean-的区别是什么&quot;&gt;@Component 和 @Bean 的区别是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransferServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注入-bean-的注解有哪些&quot;&gt;注入 Bean 的注解有哪些？&lt;/h3&gt;

&lt;p&gt;Spring 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 以及 JDK 内置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Annotation&lt;/th&gt;
      &lt;th&gt;Package&lt;/th&gt;
      &lt;th&gt;Source&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;org.springframework.bean.factory&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Spring 2.5+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.annotation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-250&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.inject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Java JSR-330&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;使用的比较多一些。&lt;/p&gt;

&lt;p&gt;推荐构造函数注入。&lt;/p&gt;

&lt;h3 id=&quot;autowired-和-resource-的区别是什么&quot;&gt;@Autowired 和 @Resource 的区别是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;
  &lt;li&gt;当一个接口存在多个实现类的情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;都需要通过名称才能正确匹配到对应的 Bean。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Autowired&lt;/code&gt; 可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Qualifier&lt;/code&gt; 注解来显式指定名称，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 属性来显式指定名称。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 支持在构造函数、方法、字段和参数上使用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt; 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注入-bean-的方式有哪些&quot;&gt;注入 Bean 的方式有哪些？&lt;/h3&gt;

&lt;p&gt;依赖注入 (Dependency Injection, DI) 的常见方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造函数注入：通过类的构造函数来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Setter 注入：通过类的 Setter 方法来注入依赖项。&lt;/li&gt;
  &lt;li&gt;Field（字段） 注入：直接在类的字段上使用注解（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;）来注入依赖项。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Spring 官方推荐构造函数注入&lt;/strong&gt;，这种注入方式的优势如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。&lt;/li&gt;
  &lt;li&gt;不可变性：有助于创建不可变对象，提高了线程安全性。&lt;/li&gt;
  &lt;li&gt;初始化保证：组件在使用前已完全初始化，减少了潜在的错误。&lt;/li&gt;
  &lt;li&gt;测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;构造函数注入适合处理&lt;strong&gt;必需的依赖项&lt;/strong&gt;，而 &lt;strong&gt;Setter 注入&lt;/strong&gt; 则更适合&lt;strong&gt;可选的依赖项&lt;/strong&gt;，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。&lt;/p&gt;

&lt;p&gt;在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是&lt;strong&gt;唯一的选择&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;bean-的作用域有哪些&quot;&gt;Bean 的作用域有哪些?&lt;/h3&gt;

&lt;p&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;singleton&lt;/strong&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean()&lt;/code&gt; 两次，得到的是不同的 Bean 实例。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;request&lt;/strong&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;session&lt;/strong&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;application/global-session&lt;/strong&gt; （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;websocket&lt;/strong&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bean-的生命周期了解么&quot;&gt;Bean 的生命周期了解么?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;创建 Bean 的实例&lt;/strong&gt;：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bean 属性赋值/填充&lt;/strong&gt;：为 Bean 设置相关属性和依赖，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 等注解注入的对象、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Value&lt;/code&gt; 注入的值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法或构造函数注入依赖和值、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Resource&lt;/code&gt;注入的各种资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bean 初始化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。
     - 如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;
      &lt;li&gt;与上面的类似，如果实现了其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法&lt;/li&gt;
      &lt;li&gt;如果 Bean 实现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterPropertiesSet()&lt;/code&gt;方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 属性，执行指定的方法。&lt;/li&gt;
      &lt;li&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postProcessAfterInitialization()&lt;/code&gt; 方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;销毁 Bean&lt;/p&gt;

    &lt;p&gt;：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果 Bean 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 接口，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy()&lt;/code&gt; 方法。&lt;/li&gt;
      &lt;li&gt;如果 Bean 在配置文件中的定义包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy-method&lt;/code&gt; 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@PreDestroy&lt;/code&gt; 注解标记 Bean 销毁之前执行的方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bean 的生命周期大致分为五个阶段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062341884.png&quot; alt=&quot;三分恶面渣逆袭：Bean生命周期五个阶段&quot; /&gt;三分恶面渣逆袭：Bean生命周期五个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;实例化&lt;/strong&gt;：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;属性赋值&lt;/strong&gt;：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为依赖注入，确保 Bean 所需的所有依赖都被注入。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用中&lt;/strong&gt;：Bean 准备好可以使用了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;销毁&lt;/strong&gt;：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何记忆呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整体上可以简单分为四步：实例化 —&amp;gt; 属性赋值 —&amp;gt; 初始化 —&amp;gt; 销毁。&lt;/li&gt;
  &lt;li&gt;初始化这一步涉及到的步骤比较多，包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aware&lt;/code&gt; 接口的依赖注入、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanPostProcessor&lt;/code&gt; 在初始化前后的处理以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializingBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init-method&lt;/code&gt; 的初始化操作。&lt;/li&gt;
  &lt;li&gt;销毁这一步会注册相关销毁回调接口，最后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DisposableBean&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destory-method&lt;/code&gt; 进行销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再分享一张清晰的图解（图源：&lt;a href=&quot;https://chaycao.github.io/2020/02/15/如何记忆Spring-Bean的生命周期.html&quot;&gt;如何记忆 Spring Bean 的生命周期&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505062339187.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-中的单例-bean-会存在线程安全问题吗&quot;&gt;Spring 中的单例 Bean 会存在线程安全问题吗？&lt;/h3&gt;

&lt;p&gt;Spring Bean 的默认作用域是单例（Singleton），这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会被多个线程共享。&lt;/p&gt;

&lt;p&gt;如果单例 Bean 是无状态的，也就是没有成员变量，那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，基本上都是无状态的。&lt;/p&gt;

&lt;p&gt;但如果 Bean 的内部状态是可变的，且没有进行适当的同步处理，就可能出现线程安全问题。&lt;/p&gt;

&lt;p&gt;对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;避免可变成员变量&lt;/strong&gt;: 尽量设计 Bean 为无状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;&lt;/strong&gt;: 将可变成员变量保存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 中，确保线程独立。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用同步机制&lt;/strong&gt;: 利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 来进行同步控制，确保线程安全。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fulong Ma</name></author><category term="Spring" /><category term="Spring" /><summary type="html">Sprint IoC</summary></entry></feed>