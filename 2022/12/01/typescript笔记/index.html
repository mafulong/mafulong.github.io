<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>typescript笔记 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="typescript笔记"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="typescript笔记"><meta name="og:description" content="typescript笔记"><meta property="og:url" content="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2022-12-01"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="typescript笔记"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">typescript笔记</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2022/12/01 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#FrontEnd" title="FrontEnd">FrontEnd</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 10602 字，约 31 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/images/qrcode.jpg" alt="傻了吧" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="typescript笔记">typescript笔记</h1><h2 id="javascript-与-typescript-的区别">JavaScript 与 TypeScript 的区别</h2><p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p><p>TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：</p><ul><li>类型批注和编译时类型检查</li><li>类型推断</li><li>类型擦除</li><li>接口</li><li>枚举</li><li>Mixin</li><li>泛型编程</li><li>名字空间</li><li>元组</li><li>Await</li></ul><p>支持es6标准。</p><p>从 TypeScript 的名字就可以看出来，「类型」是其最核心的特性。</p><p>我们知道，JavaScript 是一门非常灵活的编程语言：</p><ul><li>它没有类型约束，一个变量可能初始化时是字符串，过一会儿又被赋值为数字。</li><li>由于隐式类型转换的存在，有的变量的类型很难在运行前就确定。</li><li>基于原型的面向对象编程，使得原型上的属性或方法可以在运行时被修改。</li><li>函数是 JavaScript 中的一等公民[<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-2">2]</a>，可以赋值给变量，也可以当作参数或返回值。</li></ul><p><strong>TypeScript 是静态类型</strong></p><p>TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 <strong>TypeScript 是静态类型</strong></p><p>什么是 TypeScript？</p><ul><li>TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。</li><li>TypeScript 是一门静态类型、弱类型的语言。</li><li>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。</li><li>TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。</li><li>TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。</li><li>TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。</li><li>TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。</li><li>TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。</li><li>TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。</li></ul><h2 id="安装">安装</h2><p>如果你的本地环境已经安装了 npm 工具，可以使用以下命令来安装。</p><p>使用国内镜像：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm config set registry https://registry.npmmirror.com
</code></pre></div></div><p>安装 typescript：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install -g typescript
</code></pre></div></div><p>安装完成后我们可以使用 <strong>tsc</strong> 命令来执行 TypeScript 的相关代码，以下是查看版本号：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tsc -v
Version 3.2.2
</code></pre></div></div><p>编译一个 TypeScript 文件很简单：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tsc hello.ts
</code></pre></div></div><p>我们约定使用 TypeScript 编写的文件以 <code class="language-plaintext highlighter-rouge">.ts</code> 为后缀，用 TypeScript 编写 React 时，以 <code class="language-plaintext highlighter-rouge">.tsx</code> 为后缀。</p><p>为了vscode可以运行ts. 需要下面安装</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">npm</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">ts</span><span class="o">-</span><span class="n">node</span>
</code></pre></div></div><h2 id="helloworld">helloworld</h2><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">hello</span> <span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello World!</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span>
</code></pre></div></div><h1 id="基础">基础</h1><h2 id="原始数据类型">原始数据类型</h2><p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code class="language-plaintext highlighter-rouge">boolean</code> 定义布尔值类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isDone</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

<span class="c1">// 编译通过</span>
<span class="c1">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span>
</code></pre></div></div><p>注意，使用构造函数 <code class="language-plaintext highlighter-rouge">Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">createdByNewBoolean</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div><p>使用 <code class="language-plaintext highlighter-rouge">number</code> 定义数值类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">decLiteral</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div></div><p>使用 <code class="language-plaintext highlighter-rouge">string</code> 定义字符串类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 模板字符串</span>
<span class="kd">let</span> <span class="nx">sentence</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Hello, my name is </span><span class="p">${</span><span class="nx">myName</span><span class="p">}</span><span class="s2">.
I'll be </span><span class="p">${</span><span class="nx">myAge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="s2"> years old next month.`</span><span class="p">;</span>
</code></pre></div></div><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code class="language-plaintext highlighter-rouge">void</code> 表示没有任何返回值的函数：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">alertName</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">My name is Tom</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>声明一个 <code class="language-plaintext highlighter-rouge">void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>（只在 –strictNullChecks 未指定时）：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">unusable</span><span class="p">:</span> <span class="k">void</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div></div><p>在 TypeScript 中，可以使用 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code> 来定义这两个原始数据类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">u</span><span class="p">:</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">n</span><span class="p">:</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div><p>与 <code class="language-plaintext highlighter-rouge">void</code> 的区别是，<code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 是所有类型的子类型。也就是说 <code class="language-plaintext highlighter-rouge">undefined</code> 类型的变量，可以赋值给 <code class="language-plaintext highlighter-rouge">number</code> 类型的变量：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这样不会报错</span>
<span class="kd">let</span> <span class="nx">num</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div></div><p>而 <code class="language-plaintext highlighter-rouge">void</code> 类型的变量不能赋值给 <code class="language-plaintext highlighter-rouge">number</code> 类型的变量：</p><h2 id="任意值">任意值</h2><p><code class="language-plaintext highlighter-rouge">any</code> 类型，则允许被赋值为任意类型。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</code></pre></div></div><p>在任意值上访问任何属性都是允许的：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">anyThing</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">anyThing</span><span class="p">.</span><span class="nx">myName</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">anyThing</span><span class="p">.</span><span class="nx">myName</span><span class="p">.</span><span class="nx">firstName</span><span class="p">);</span>
</code></pre></div></div><p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">something</span><span class="p">;</span>
</code></pre></div></div><h2 id="类型推论">类型推论</h2><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="c1">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span>
</code></pre></div></div><p>事实上，它等价于：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="c1">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span>
</code></pre></div></div><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code class="language-plaintext highlighter-rouge">any</code> 类型而完全不被类型检查</strong>：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</code></pre></div></div><h2 id="联合类型">联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</code></pre></div></div><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong></p><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div><h2 id="接口">接口</h2><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">25</span>
<span class="p">};</span>
</code></pre></div></div><ul><li>定义的变量比接口少了一些属性是不允许的。会编译报错</li><li>多一些属性也是不允许的。 可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</li></ul><p>可选</p><ul><li>有时我们希望不要完全匹配一个形状，那么可以用可选属性. 可选属性的含义是该属性可以不存在。这时<strong>仍然不允许添加未定义的属性</strong>：</li></ul><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
      <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="p">}</span>
 
</code></pre></div></div><p>任意类型</p><ul><li>有时候我们希望一个接口允许有任意的属性，可以使用如下方式。 使用 <code class="language-plaintext highlighter-rouge">[propName: string]</code> 定义了任意属性取 <code class="language-plaintext highlighter-rouge">string</code> 类型的值。需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>。</li></ul><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="p">[</span><span class="nx">propName</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">any</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><ul><li>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型</li></ul><p>只读属性</p><ul><li>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code class="language-plaintext highlighter-rouge">readonly</code> 定义只读属性。 <strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</li></ul><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="k">readonly</span> <span class="nx">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>基于interface声明新变量的技巧</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">{</span>
  <span class="n">id</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span>
  <span class="n">name</span><span class="k">:</span> <span class="err">"</span><span class="kt">name</span><span class="err">"</span>
<span class="o">}</span>

<span class="n">以下都是</span> <span class="n">可以的</span><span class="err">，</span><span class="n">会根据id</span><span class="o">,</span><span class="n">name这些fieldname匹配对应的值</span><span class="err">，</span><span class="n">同时支持别名</span><span class="err">，</span><span class="n">比如id1是id的别名</span><span class="err">。</span>
<span class="n">const</span> <span class="o">{</span><span class="n">id</span><span class="o">}</span> <span class="k">=</span> <span class="n">p</span>
<span class="nv">console</span><span class="o">.</span><span class="py">log</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
<span class="n">const</span> <span class="o">{</span><span class="n">name</span><span class="o">}</span> <span class="k">=</span> <span class="n">p</span>
<span class="n">const</span> <span class="o">{</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">}</span> <span class="k">=</span> <span class="n">p</span>
<span class="n">const</span> <span class="o">{</span><span class="n">id</span><span class="k">:</span> <span class="kt">id1</span><span class="o">}</span> <span class="k">=</span> <span class="n">p</span>
<span class="nv">console</span><span class="o">.</span><span class="py">log</span><span class="o">(</span><span class="n">id1</span><span class="o">)</span>
</code></pre></div></div><h2 id="数组的类型">数组的类型</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">fibonacci</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</code></pre></div></div><p>数组的项中<strong>不允许</strong>出现其他的类型</p><p>我们也可以使用数组泛型（Array Generic） <code class="language-plaintext highlighter-rouge">Array&lt;elemType&gt;</code> 来表示数组：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">fibonacci</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</code></pre></div></div><h2 id="类数组">类数组</h2><p>类数组（Array-like Object）不是数组类型</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">args</span><span class="p">:</span> <span class="p">{</span>
        <span class="p">[</span><span class="nx">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">]:</span> <span class="kr">number</span><span class="p">;</span>
        <span class="nl">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
        <span class="nl">callee</span><span class="p">:</span> <span class="nb">Function</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code class="language-plaintext highlighter-rouge">length</code> 和 <code class="language-plaintext highlighter-rouge">callee</code> 两个属性。</p><h2 id="函数的类型">函数的类型</h2><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p><h3 id="函数表达式">函数表达式</h3><p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">mySum</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code class="language-plaintext highlighter-rouge">mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code class="language-plaintext highlighter-rouge">mySum</code> 添加类型，则应该是这样：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">mySum</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>注意不要混淆了 TypeScript 中的 <code class="language-plaintext highlighter-rouge">=&gt;</code> 和 ES6 中的 <code class="language-plaintext highlighter-rouge">=&gt;</code>。</p><p>在 TypeScript 的类型定义中，<code class="language-plaintext highlighter-rouge">=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><p>在 ES6 中，<code class="language-plaintext highlighter-rouge">=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#箭头函数">ES6 中的箭头函数</a>。</p><h3 id="用接口定义函数">用接口定义函数</h3><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">SearchFunc</span> <span class="p">{</span>
    <span class="p">(</span><span class="nx">source</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">subString</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">mySearch</span><span class="p">:</span> <span class="nx">SearchFunc</span><span class="p">;</span>
<span class="nx">mySearch</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">source</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">subString</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">source</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">subString</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>采用函数表达式<code class="language-plaintext highlighter-rouge">|</code>接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><h3 id="可选参数和默认值剩余参数">可选参数和默认值、剩余参数</h3><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">buildName</span><span class="p">(</span><span class="nx">firstName</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">?:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">function</span> <span class="nx">buildName</span><span class="p">(</span><span class="nx">firstName</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Cat</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">push</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong></p><h3 id="重载">重载</h3><p>联合类型<strong>缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p><p>以下重载可避免。支持重载。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span> <span class="o">|</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">''</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="dl">''</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">''</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="类型断言">类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">值</span> <span class="k">as</span> <span class="nx">类型</span>

<span class="nx">animal</span> <span class="k">as</span> <span class="nx">Fish</span>
</code></pre></div></div><p>用途</p><ul><li>联合类型可以被断言为其中一个类型</li><li>父类可以被断言为子类</li><li>任何类型都可以被断言为 any</li><li><p>any 可以被断言为任何类型</p></li><li><p>若 <code class="language-plaintext highlighter-rouge">A</code> 兼容 <code class="language-plaintext highlighter-rouge">B</code>，那么 <code class="language-plaintext highlighter-rouge">A</code> 能够被断言为 <code class="language-plaintext highlighter-rouge">B</code>，<code class="language-plaintext highlighter-rouge">B</code> 也能被断言为 <code class="language-plaintext highlighter-rouge">A</code>。</p></li><li>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除。所以类型断言不是类型转换，它不会真的影响到变量的类型。只是让编译器正确地编译，骗过编译器。</li></ul><h2 id="声明文件">声明文件</h2><blockquote><p><a href="https://ts.xcatliu.com/basics/declaration-files.html">声明文件</a></p></blockquote><p>参考引用即可。</p><ul><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-var"><code class="language-plaintext highlighter-rouge">declare var</code></a> 声明全局变量</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-function"><code class="language-plaintext highlighter-rouge">declare function</code></a> 声明全局方法</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-class"><code class="language-plaintext highlighter-rouge">declare class</code></a> 声明全局类</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-enum"><code class="language-plaintext highlighter-rouge">declare enum</code></a> 声明全局枚举类型</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-namespace"><code class="language-plaintext highlighter-rouge">declare namespace</code></a> 声明（含有子属性的）全局对象</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#interface-和-type"><code class="language-plaintext highlighter-rouge">interface</code> 和 <code class="language-plaintext highlighter-rouge">type</code></a> 声明全局类型</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export"><code class="language-plaintext highlighter-rouge">export</code></a> 导出变量</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-namespace"><code class="language-plaintext highlighter-rouge">export namespace</code></a> 导出（含有子属性的）对象</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-default"><code class="language-plaintext highlighter-rouge">export default</code></a> ES6 默认导出</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-1"><code class="language-plaintext highlighter-rouge">export =</code></a> commonjs 导出模块</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-as-namespace"><code class="language-plaintext highlighter-rouge">export as namespace</code></a> UMD 库声明全局变量</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-global"><code class="language-plaintext highlighter-rouge">declare global</code></a> 扩展全局变量</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-module"><code class="language-plaintext highlighter-rouge">declare module</code></a> 扩展模块</li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html#san-xie-xian-zhi-ling"><code class="language-plaintext highlighter-rouge">/// </code></a> 三斜线指令</li></ul><h1 id="进阶">进阶</h1><h2 id="类型别名">类型别名</h2><p>类型别名用来给一个类型起个新名字。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Name</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">NameResolver</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">NameOrResolver</span> <span class="o">=</span> <span class="nx">Name</span> <span class="o">|</span> <span class="nx">NameResolver</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">getName</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span> <span class="nx">NameOrResolver</span><span class="p">):</span> <span class="nx">Name</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>上例中，我们使用 <code class="language-plaintext highlighter-rouge">type</code> 创建类型别名。</p><p>类型别名常用于联合类型。</p><h2 id="字符串字面量类型">字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">EventNames</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">handleEvent</span><span class="p">(</span><span class="nx">ele</span><span class="p">:</span> <span class="nx">Element</span><span class="p">,</span> <span class="nx">event</span><span class="p">:</span> <span class="nx">EventNames</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something</span>
<span class="p">}</span>

<span class="nx">handleEvent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// 没问题</span>
<span class="nx">handleEvent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">dblclick</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 报错，event 不能为 'dblclick'</span>

<span class="c1">// index.ts(7,47): error TS2345: Argument of type '"dblclick"' is not assignable to parameter of type 'EventNames'.</span>
</code></pre></div></div><p>上例中，我们使用 <code class="language-plaintext highlighter-rouge">type</code> 定了一个字符串字面量类型 <code class="language-plaintext highlighter-rouge">EventNames</code>，它只能取三种字符串中的一种。</p><p>注意，<strong>类型别名与字符串字面量类型都是使用 <code class="language-plaintext highlighter-rouge">type</code> 进行定义。</strong></p><h2 id="元组">元组</h2><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p><p>元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。</p><p>定义一对值分别为 <code class="language-plaintext highlighter-rouge">string</code> 和 <code class="language-plaintext highlighter-rouge">number</code> 的元组：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tom</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">,</span> <span class="mi">25</span><span class="p">];</span>
</code></pre></div></div><p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tom</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">];</span>
<span class="nx">tom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">tom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</code></pre></div></div><p>也可以只赋值其中一项</p><p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tom</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">];</span>
<span class="nx">tom</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">,</span> <span class="mi">25</span><span class="p">];</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">male</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="c1">// Argument of type 'true' is not assignable to parameter of type 'string | number'.</span>
</code></pre></div></div><h2 id="枚举">枚举</h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><p>枚举使用 <code class="language-plaintext highlighter-rouge">enum</code> 关键字来定义：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Days</span> <span class="p">{</span><span class="nx">Sun</span><span class="p">,</span> <span class="nx">Mon</span><span class="p">,</span> <span class="nx">Tue</span><span class="p">,</span> <span class="nx">Wed</span><span class="p">,</span> <span class="nx">Thu</span><span class="p">,</span> <span class="nx">Fri</span><span class="p">,</span> <span class="nx">Sat</span><span class="p">};</span>
</code></pre></div></div><p>枚举成员会被赋值为从 <code class="language-plaintext highlighter-rouge">0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Days</span> <span class="p">{</span><span class="nx">Sun</span><span class="p">,</span> <span class="nx">Mon</span><span class="p">,</span> <span class="nx">Tue</span><span class="p">,</span> <span class="nx">Wed</span><span class="p">,</span> <span class="nx">Thu</span><span class="p">,</span> <span class="nx">Fri</span><span class="p">,</span> <span class="nx">Sat</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="dl">"</span><span class="s2">Sun</span><span class="dl">"</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="dl">"</span><span class="s2">Mon</span><span class="dl">"</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="dl">"</span><span class="s2">Tue</span><span class="dl">"</span><span class="p">]</span> <span class="o">===</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="dl">"</span><span class="s2">Sat</span><span class="dl">"</span><span class="p">]</span> <span class="o">===</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Sun</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Mon</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Tue</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Sat</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div><p>我们也可以给枚举项手动赋值：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Days</span> <span class="p">{</span><span class="nx">Sun</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="nx">Mon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Tue</span><span class="p">,</span> <span class="nx">Wed</span><span class="p">,</span> <span class="nx">Thu</span><span class="p">,</span> <span class="nx">Fri</span><span class="p">,</span> <span class="nx">Sat</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="dl">"</span><span class="s2">Sun</span><span class="dl">"</span><span class="p">]</span> <span class="o">===</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="dl">"</span><span class="s2">Mon</span><span class="dl">"</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div><p>未手动赋值的枚举项会接着上一个枚举项递增。如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的。所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p><h2 id="类">类</h2><h3 id="实例属性">实例属性</h3><p>ES6 中实例的属性只能通过构造函数中的 <code class="language-plaintext highlighter-rouge">this.xxx</code> 来定义，ES7 提案中可以直接在类里面定义：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Jack</span><span class="dl">'</span><span class="p">;</span>

  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Jack</span>
</code></pre></div></div><h3 id="静态属性">静态属性</h3><p>ES7 提案中，可以使用 <code class="language-plaintext highlighter-rouge">static</code> 定义一个静态属性：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">num</span><span class="p">);</span> <span class="c1">// 42</span>
</code></pre></div></div><h3 id="public-private-和-protected">public private 和 protected</h3><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">private</code> 和 <code class="language-plaintext highlighter-rouge">protected</code>。</p><p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 <code class="language-plaintext highlighter-rouge">private</code> 属性在外部的可访问性。</p><h3 id="构造函数参数可带访问属性">构造函数参数可带访问属性</h3><p>修饰符和<code class="language-plaintext highlighter-rouge">readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="c1">// public name: string;</span>
  <span class="k">public</span> <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this.name = name;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>注意如果 <code class="language-plaintext highlighter-rouge">readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="c1">// public readonly name;</span>
  <span class="k">public</span> <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="k">readonly</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this.name = name;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="抽象类">抽象类</h3><p><code class="language-plaintext highlighter-rouge">abstract</code> 用于定义抽象类和其中的抽象方法。</p><p>首先，抽象类是不允许被实例化的：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="k">public</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">public</span> <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="kd">abstract</span> <span class="nx">sayHi</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><p>其次，抽象类中的抽象方法必须被子类实现</p><h2 id="类与接口">类与接口</h2><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code class="language-plaintext highlighter-rouge">implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Door</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">SecurityDoor</span> <span class="kd">extends</span> <span class="nx">Door</span> <span class="k">implements</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">SecurityDoor alert</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>一个类可以实现多个接口：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Light</span> <span class="p">{</span>
    <span class="nx">lightOn</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">lightOff</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Car</span> <span class="k">implements</span> <span class="nx">Alarm</span><span class="p">,</span> <span class="nx">Light</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Car alert</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">lightOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Car light on</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">lightOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Car light off</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>接口与接口之间可以是继承关系：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">LightableAlarm</span> <span class="kd">extends</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nx">lightOn</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">lightOff</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Point</span> <span class="p">{</span>
    <span class="nl">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Point3d</span> <span class="kd">extends</span> <span class="nx">Point</span> <span class="p">{</span>
    <span class="nl">z</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="泛型">泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><p>泛型函数、泛型类、泛型接口、泛型类默认泛型</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createArray</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="na">result</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">createArray</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// ['x', 'x', 'x']</span>

<span class="c1">// or 自动推算</span>
<span class="nx">createArray</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// ['x', 'x', 'x']</span>

</code></pre></div></div><p>定义泛型的时候，可以一次定义多个类型参数：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">swap</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">[</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="p">]):</span> <span class="p">[</span><span class="nx">U</span><span class="p">,</span> <span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>

<span class="nx">swap</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">]);</span> <span class="c1">// ['seven', 7]</span>
</code></pre></div></div><p>当然也可以使用含有泛型的接口来定义函数的形状：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">CreateArrayFunc</span> <span class="p">{</span>
    <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">GenericNumber</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="na">zeroValue</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
    <span class="nl">add</span><span class="p">:</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myGenericNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GenericNumber</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">();</span>
<span class="nx">myGenericNumber</span><span class="p">.</span><span class="nx">zeroValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">myGenericNumber</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createArray</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="na">result</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="声明合并">声明合并</h2><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：</p><p>函数合并就是函数类型里提到的<strong>重载</strong></p><p>接口中的属性在合并时会简单的合并到一个接口中：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nl">price</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nl">weight</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>相当于：</p><div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
    <span class="nl">price</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">weight</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>注意，<strong>合并的属性的类型必须是唯一的</strong></p><p>类的合并与接口的合并规则一致。</p><h1 id="参考">参考</h1><ul><li><a href="https://ts.xcatliu.com/">TypeScript 入门教程</a></li></ul></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
