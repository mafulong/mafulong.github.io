<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Junit和Mockito &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2022/07/17/Junit%E5%92%8CMockito/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="Junit和Mockito"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="Junit4"><meta name="og:description" content="Junit4"><meta property="og:url" content="https://mafulong.github.io/2022/07/17/Junit%E5%92%8CMockito/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2022-07-17"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Junit和Mockito"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Junit和Mockito</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2022/07/17 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 16490 字，约 48 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/images/qrcode.jpg" alt="傻了吧" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="junit4">Junit4</h1><h2 id="例子常用注解">例子+常用注解</h2><p>需要使用junit.jar这个包。</p><p>@Test 注解，表示这个方法是一个测试方法。</p><p>常用注解</p><ul><li>@Test:将一个普通方法修饰成一个测试方法 @Test(excepted=xx.class): xx.class 表示异常类，表示测试的方法抛出此异常时，认为是正常的测试通过的 @Test(timeout = 毫秒数) :测试方法执行时间是否符合预期</li><li>@BeforeClass： 会在所有的方法执行前被执行，static 方法 （全局只会执行一次，而且是第一个运行）</li><li>@AfterClass：会在所有的方法执行之后进行执行，static 方法 （全局只会执行一次，而且是最后一个运行）</li><li>@Before：会在每一个测试方法被运行前执行一次</li><li>@After：会在每一个测试方法运行后被执行一次</li><li>@Ignore：所修饰的测试方法会被测试运行器忽略</li><li>@RunWith：可以更改测试运行器 org.junit.runner.Runner</li><li>@Parameters：参数化注解</li></ul><p>例子</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">Assert</span><span class="o">.*;</span>

<span class="kn">import</span> <span class="nn">org.junit.*</span><span class="o">;</span>

<span class="cm">/**
 * 了解一个测试类单元测试的执行顺序为：
 * @BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass
 * @author hao
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestJunit1</span> <span class="o">{</span>
  <span class="nd">@BeforeClass</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setUpBeforeClass</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in BeforeClass================"</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@AfterClass</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">tearDownAfterClass</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in AfterClass================="</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@Before</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in Before"</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@After</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">after</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in After"</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@Test</span><span class="o">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testadd</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">TestJunit2</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TestJunit2</span><span class="o">();</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in Test ----Add"</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testdivision</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">TestJunit2</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TestJunit2</span><span class="o">();</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">division</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in Test ----Division"</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@Ignore</span>
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test_ignore</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">TestJunit2</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TestJunit2</span><span class="o">();</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in test_ignore"</span><span class="o">);</span>
  <span class="o">}</span>
 
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">teest_fail</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">fail</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TestJunit2</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
   
  <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>
 
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
 
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">division</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>一个<strong>测试类单元测试的执行顺序</strong>为：</p><p><strong>@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass</strong></p><p>每一个<strong>测试方法的调用顺序</strong>为：</p><p>@Before –&gt; @Test –&gt; @After</p><h2 id="junit的一些注意事项">JUnit的一些注意事项</h2><ul><li>测试方法必须使用 @Test 修饰</li><li>测试方法必须使用 public void 进行修饰，不能带参数</li><li>一般使用单元测试会新建一个 test 目录存放测试代码，在生产部署的时候只需要将 test 目录下代码删除即可</li><li>测试代码的包应该和被测试代码包结构保持一致</li><li>测试单元中的每个方法必须可以独立测试，方法间不能有任何依赖</li><li>测试类一般使用 Test 作为类名的后缀</li><li>测试方法使一般用 test 作为方法名的前缀</li></ul><h2 id="assert的用法"><strong>Assert的用法</strong></h2><p>Assert就是断言，断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。</p><p>Assert的核心方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202207171631342.jpeg" alt="img" /></p><h2 id="testsuite测试套件">TestSuite测试套件</h2><p>测试套件，一下执行多个测试类。</p><p>需要遵循以下规则：</p><ol><li>创建一个空类作为测试套件的入口。</li><li>使用注解 org.junit.runner.RunWith 和 org.junit.runners.Suite.SuiteClasses 修饰这个空类。</li><li>将 org.junit.runners.Suite 作为参数传入注解 RunWith，以提示 JUnit 为此类使用套件运行器执行。</li><li>将需要放入此测试套件的测试类组成数组作为注解 SuiteClasses 的参数。</li><li>保证这个空类使用 public 修饰，而且存在公开的不带有任何参数的构造函数</li></ol><h2 id="测试隔离">测试隔离</h2><p>JUnit中每个测试方法都是在独立的类实例中执行的，因此只要没有使用全局变量和外部资源（如数据库和API），这些测试都将是彼此隔离的，即不管一个测试做什么，都不会影响其他测试。</p><p><a href="https://www.letianbiji.com/java/java-test-junit-isolate.html">参考</a></p><h3 id="测试运行器">测试运行器</h3><p>JUnit 中所有的测试方法都是由测试运行器负责执行的。JUnit 为单元测试提供了默认的测试运行器，但 JUnit 并没有限制您必须使用默认的运行器。相反，您不仅可以定制自己的运行器（所有的运行器都继承自 org.junit.runner.Runner），而且还可以为每一个测试类指定使用某个具体的运行器。指定方法也很简单，使用注解 <code class="language-plaintext highlighter-rouge">org.junit.runner.RunWith</code> 在测试类上显式的声明要使用的运行器即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">CustomTestRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> 
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestWordDealUtil</span> <span class="o">{</span> 
<span class="err">……</span>
 <span class="o">}</span>
</code></pre></div></div><p>显而易见，如果测试类没有显式的声明使用哪一个测试运行器，JUnit 会启动默认的测试运行器执行测试类（比如上面提及的单元测试代码）。一般情况下，默认测试运行器可以应对绝大多数的单元测试要求；当使用 JUnit 提供的一些高级特性（例如即将介绍的两个特性）或者针对特殊需求定制 JUnit 测试方式时，显式的声明测试运行器就必不可少了。</p><h2 id="异常测试参数测试">异常测试、参数测试</h2><p><a href="https://www.w3cschool.cn/junit/1h4e1hva.html">参考</a></p><h1 id="junit5">Junit5</h1><p>区别:</p><p>注解不同：</p><ul><li>@Before变成了@BeforeEach。</li><li>@After变成了@AfterEach。</li><li>@BeforeClass变成了@BeforeAll。</li><li>@AfterClass变成了@AfterAll。</li><li>@Ignore变成了@Disabled。</li><li>@Category变成了@Tag。</li><li>@Rule和@ClassRule没有了，用@ExtendWith和@RegisterExtension代替。</li></ul><p>扩展不同：</p><p>在JUnit 4中，使用Spring框架构建测试看起来是这样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyControllerTest</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>在JUnit 5中，你可以用Spring扩展来代替：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">SpringExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">MyControllerTest</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>@ExtendWith 注解是可重复的，这意味着多个扩展可以很容易地组合在一起。</p><p>你也可以通过创建一个类来实现org.junit.jupiter.api.extendWith中的一个或多个接口，然后用@ExtendWith将其添加到你的测试中，从而轻松定义你自己的自定义扩展。</p><p>import不同</p><p><strong>JUnit 4 导入示例：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javaCopy code
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
</code></pre></div></div><p><strong>JUnit 5 导入示例：</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javaCopy code
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
</code></pre></div></div><h1 id="mockito-core-低版本">Mockito-core 低版本</h1><p><a href="https://www.baeldung.com/mockito-series">Tutorial</a></p><p>高版本兼容低版本。</p><p>低版本<strong>不能mock静态、final、私有方法</strong></p><h2 id="添加mockito">添加mockito</h2><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="nt">&lt;dependency&gt;</span>
          <span class="nt">&lt;groupId&gt;</span>org.mockito<span class="nt">&lt;/groupId&gt;</span>
          <span class="nt">&lt;artifactId&gt;</span>mockito-all<span class="nt">&lt;/artifactId&gt;</span>
          <span class="nt">&lt;version&gt;</span>1.9.5<span class="nt">&lt;/version&gt;</span>
          <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
      <span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">mockito</span><span class="o">.</span><span class="na">Mockito</span><span class="o">.*;</span>
</code></pre></div></div><p>测试类加相关注解</p><p>Junit5:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceUnitTest</span> <span class="o">{</span>

</code></pre></div></div><p>Junit4:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">MockitoJUnitRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="n">不支持对静态方法的Mock和Stub</span><span class="err">。</span>

<span class="nd">@RunWith</span><span class="o">(</span><span class="nc">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="n">这个可以mock静态方法</span> <span class="n">包括Mock静态方法</span><span class="err">、</span><span class="n">final类</span><span class="err">、</span><span class="n">构造函数等</span><span class="err">。</span>
<span class="n">适用于需要Mock静态方法</span><span class="err">、</span><span class="n">final类等特殊场景的测试</span><span class="err">。</span>
</code></pre></div></div><h2 id="创建-mock-对象">创建 Mock 对象</h2><div class="language-reasonml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="nc">Test</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">createMockObject</span><span class="bp">()</span> <span class="p">{</span>
    <span class="c1">// 使用 mock 静态方法创建 Mock 对象.</span>
    <span class="nc">List</span> <span class="n">mockedList</span> <span class="o">=</span> <span class="n">mock</span><span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">mockedList</span> <span class="n">instanceof</span> <span class="nc">List</span><span class="p">);</span>

    <span class="c1">// mock 方法不仅可以 Mock 接口类, 还可以 Mock 具体的类型.</span>
    <span class="nc">ArrayList</span> <span class="n">mockedArrayList</span> <span class="o">=</span> <span class="n">mock</span><span class="p">(</span><span class="nn">ArrayList</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">mockedArrayList</span> <span class="n">instanceof</span> <span class="nc">List</span><span class="p">);</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">mockedArrayList</span> <span class="n">instanceof</span> <span class="nc">ArrayList</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>如上代码所示, 我们调用了 <strong>mock</strong> 静态方法来创建一个 Mock 对象. mock 方法接收一个 class 类型, 即我们需要 mock 的类型.</p><p>Mockito.when需要在mock对象上操作！！</p><p>只有调用mock对象的方法才是走的mock逻辑，其它new出来的对象还不是mock的。</p><h2 id="配置-mock-对象-when和return">配置 Mock 对象 when和return</h2><p>当我们有了一个 Mock 对象后, 我们可以定制它的具体的行为. 例如:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">configMockObject</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span> <span class="n">mockedList</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="c1">// 我们定制了当调用 mockedList.add("one") 时, 返回 true</span>
    <span class="n">when</span><span class="o">(</span><span class="n">mockedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"one"</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="c1">// 当调用 mockedList.size() 时, 返回 1</span>
    <span class="n">when</span><span class="o">(</span><span class="n">mockedList</span><span class="o">.</span><span class="na">size</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">mockedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"one"</span><span class="o">));</span>
    <span class="c1">// 因为我们没有定制 add("two"), 因此返回默认值, 即 false.</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">mockedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"two"</span><span class="o">));</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">mockedList</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="mi">1</span><span class="o">);</span>

    <span class="nc">Iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Iterator</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">when</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">"Hello,"</span><span class="o">).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">"Mockito!"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="c1">//assert</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="s">"Hello, Mockito!"</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>使用 <strong>when(…).thenReturn(…)</strong> 方法链来定义一个行为, 例如 “when(mockedList.add(“one”)).thenReturn(true)” 表示: <strong>当调用了mockedList.add(“one”), 那么返回 true.</strong>. 并且要注意的是, <strong>when(…).thenReturn(…)</strong> 方法链不仅仅要匹配方法的调用, 而且要方法的参数一样才行. 可以用Mockito.any()期待参数匹配。</p><p><strong>when(​…).thenReturn(​…)</strong> 方法链可以指定多个返回值, 当这样做后, 如果多次调用指定的方法, 那么这个方法会依次返回这些值.</p><p>支持手动抛出异常Mockito.doThrow: <code class="language-plaintext highlighter-rouge">doThrow(ExceptionX).when(x).methodCall</code>, 它的含义是: 当调用了 x.methodCall 方法后, 抛出异常 ExceptionX.</p><h2 id="误解-注意事项">误解 注意事项</h2><p>Mockito.mock() 并不是mock一整个类，而是根据传进去的一个类，mock出属于这个类的一个对象，并且返回这个mock对象；而传进去的这个类本身并没有改变，用这个类new出来的对象也没有受到任何改变！</p><p>mock出来的对象并不会自动替换掉正式代码里面的对象，你必须要有某种方式把mock对象应用到正式代码里面。一般是构造函数传入或者自动注入。</p><p>mock后直接生效 默认是无限次数。</p><p>对于一个mock对象，我们可以指定返回值和执行特定的动作，当然，也可以不指定，如果不指定的话，一个mock对象的所有非void方法都将返回默认值：int、long类型方法将返回0，boolean方法将返回false，对象方法将返回null等等；而void方法将什么都不做。</p><h2 id="特殊case-对于手动new而不是依赖注入的mock">特殊case: 对于手动new而不是依赖注入的Mock</h2><p><a href="https://stackoverflow.com/questions/5920153/test-class-with-a-new-call-in-it-with-mockito">参考</a></p><ol><li><p>改写prod逻辑，改成用工厂生成，这样就可以Mock这个工厂了</p></li><li><p>把new 的那个函数给mock掉。</p></li></ol><h3 id="校验-mock-对象的方法调用">校验 Mock 对象的方法调用</h3><p>Mockito 会追踪 Mock 对象的所用方法调用和调用方法时所传递的参数. 我们可以通过 verify() 静态方法来来校验指定的方法调用是否满足断言. 语言描述有一点抽象, 下面我们仍然以代码来说明一下.</p><pre><code class="language-routeros">@Test
public void testVerify() {
    List mockedList = mock(List.class);
    mockedList.add("one");
    mockedList.add("two");
    mockedList.add("three times");
    mockedList.add("three times");
    mockedList.add("three times");
    when(mockedList.size()).thenReturn(5);
    Assert.assertEquals(mockedList.size(), 5);

    verify(mockedList, atLeastOnce()).add("one");
    verify(mockedList, times(1)).add("two");
    verify(mockedList, times(3)).add("three times");
    verify(mockedList, never()).isEmpty();
}
</code></pre><p>上面的例子前半部份没有什么特别的, 我们关注后面的:</p><div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">verify</span><span class="o">(</span><span class="nt">mockedList</span><span class="o">,</span> <span class="nt">atLeastOnce</span><span class="o">())</span><span class="nc">.add</span><span class="o">(</span><span class="s2">"one"</span><span class="o">)</span><span class="p">;</span>
<span class="nt">verify</span><span class="o">(</span><span class="nt">mockedList</span><span class="o">,</span> <span class="nt">times</span><span class="o">(</span><span class="nt">1</span><span class="o">))</span><span class="nc">.add</span><span class="o">(</span><span class="s2">"two"</span><span class="o">)</span><span class="p">;</span>
<span class="nt">verify</span><span class="o">(</span><span class="nt">mockedList</span><span class="o">,</span> <span class="nt">times</span><span class="o">(</span><span class="nt">3</span><span class="o">))</span><span class="nc">.add</span><span class="o">(</span><span class="s2">"three times"</span><span class="o">)</span><span class="p">;</span>
<span class="nt">verify</span><span class="o">(</span><span class="nt">mockedList</span><span class="o">,</span> <span class="nt">never</span><span class="o">())</span><span class="nc">.isEmpty</span><span class="o">()</span><span class="p">;</span>
</code></pre></div></div><p>读者根据代码也应该可以猜测出它的含义了, 很简单:</p><ul><li>第一句校验 mockedList.add(“one”) 至少被调用了 1 次(atLeastOnce)</li><li>第二句校验 mockedList.add(“two”) 被调用了 1 次(times(1))</li><li>第三句校验 mockedList.add(“three times”) 被调用了 3 次(times(3))</li><li>第四句校验 mockedList.isEmpty() 从未被调用(never)</li></ul><p>Mockito.verify(mockUserManager).performLogin(“xiaochuang”, “xiaochuang password”);</p><p>这句话的作用是，验证 mockUserManager 的 performLogin() 得到了调用，同时参数是“xiaochuang”和”xiaochuang password”。其实更准确的说法是，这行代码验证的是， mockUserManager 的 performLogin() 方法得到了 一次 调用。因为这行代码其实是：</p><p>Mockito.verify(mockUserManager, Mockito.times(1)).performLogin(“xiaochuang”, “xiaochuang password”);</p><p>的简写，或者说重载方法，注意其中的 Mockito.times(1) 。</p><h2 id="使用-spy-部分模拟对象">使用 spy() 部分模拟对象</h2><p>对于一个mock对象，我们可以指定返回值和执行特定的动作，当然，也可以不指定，如果不指定的话，一个mock对象的所有非void方法都将返回默认值：int、long类型方法将返回0，boolean方法将返回false，对象方法将返回null等等；而void方法将什么都不做。</p><p>如果你想实现这样的效果：指定时执行指定的动作，不指定时调用这个对象的默认实现，同时又能拥有验证方法调用的功能。那你可以使用Mockito.spy()来创建对象。</p><p>Mockito 提供的 spy 方法可以包装一个真实的 Java 对象, 并返回一个包装后的新对象. 若没有特别配置的话, 对这个新对象的所有方法调用, 都会委派给实际的 Java 对象. 例如:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSpy</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span>
    <span class="nc">List</span> <span class="n">spy</span> <span class="o">=</span> <span class="n">spy</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>

    <span class="c1">// 对 spy.size() 进行定制.</span>
    <span class="n">when</span><span class="o">(</span><span class="n">spy</span><span class="o">.</span><span class="na">size</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>

    <span class="n">spy</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"one"</span><span class="o">);</span>
    <span class="n">spy</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"two"</span><span class="o">);</span>

    <span class="c1">// 因为我们没有对 get(0), get(1) 方法进行定制,</span>
    <span class="c1">// 因此这些调用其实是调用的真实对象的方法.</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">spy</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="s">"one"</span><span class="o">);</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">spy</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="s">"two"</span><span class="o">);</span>

    <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">spy</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="mi">100</span><span class="o">);</span>
  
  
    <span class="c1">//方式2：spy一个已存在的对象</span>
    <span class="nc">List</span> <span class="n">spy2</span> <span class="o">=</span> <span class="nc">Mockito</span><span class="o">.</span><span class="na">spy</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="o">}</span>
</code></pre></div></div><p>这个例子中我们实例化了一个 LinkedList 对象, 然后使用 spy() 方法对 list 对象进行部分模拟. 接着我们使用 <strong>when(…).thenReturn(…)</strong> 方法链来规定 spy.size() 方法返回值是 100. 随后我们给 spy 添加了两个元素, 然后再 调用 spy.get(0) 获取第一个元素.</p><p>这里有意思的地方是: 因为我们没有定制 add(“one”), add(“two”), get(0), get(1), 因此通过 spy 调用这些方法时, 实际上是委派给 list 对象来调用的. 然而我们 定义了 spy.size() 的返回值, 因此当调用 spy.size() 时, 返回 100.</p><h3 id="spy和mock-对比stub存根">Spy和mock 对比，Stub存根</h3><p>spy 和 mock不同，不同点是：</p><ul><li>spy 的参数是对象示例，mock 的参数是 class。</li><li>被 spy 的对象，调用其方法时默认会走真实方法。mock 对象不会。</li></ul><p>mock默认是返回默认值的。</p><p>假如想要只有调用<code class="language-plaintext highlighter-rouge">dao</code>层的某方法时它的返回值是什么，而其它正常，这个过程就是<strong>Stub</strong>. 可以对spy对象的某个方法进行存根以指定返回值且避免调用此方法实际逻辑。</p><h3 id="问题-存根后也调用了实际逻辑">问题: 存根后也调用了实际逻辑</h3><p>对spy对象的某个方法进行存根时有什么特殊要求吗？为什么我有时明明做了存根操作，方法的实际逻辑还是会被调用？</p><ol><li>存根要求：使用doXXX(x).when(spy).m1()的方式而不是whenXXX(spy.m1()).thenXXX(x)的方式。</li><li>实际逻辑为什么会被调用：因为使用了whenXXX(spy.m1()).thenXXX(x)存根方式。</li></ol><p><a href="https://juejin.cn/post/6975525979418525709#heading-8">参考链接</a></p><p>定义存根方法的方式:</p><ul><li>Mockito.when(foo.sum()).thenXXX(…);<ul><li>即对foo.sum()方法存根。</li><li>注意：<ul><li>foo对象应该是一个mock对象。spy对象不建议使用此方式进行存根。因为当代码执行到when(foo.sum())时。foo.sum()方法会首先执行。导致sum()方法的实际代码逻辑被执行。（sum()的实际代码逻辑是否会被执行要看被spy对象的类型，当被spy对象是一个mock对象或者接口时不会执行-这些类型也没有实际代码逻辑可以执行。当被spy对象一个具体的对象时则实际代码逻辑会被执行）</li></ul></li></ul></li><li>Mockito.doXXX(…).when(foo).sum();<ul><li>即对foo.sum()方法存根。</li><li>可以存根void方法。</li><li>foo对象可以是一个mock对象，也可以是一个spy对象。</li></ul></li></ul><h2 id="将某方法替换成另一个方法替换实现">将某方法替换成另一个方法，替换实现</h2><p>通过doAnswer方法，生成替换，里面取Arguments手动转化来做某些事情。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span><span class="err"> </span><span class="kd">class</span><span class="err"> </span><span class="nc">LoginPresenterTest</span><span class="err"> </span><span class="o">{</span>
<span class="err"> </span> <span class="err"> </span><span class="nc">LoginPresenter</span><span class="err"> </span><span class="n">loginPresenter</span><span class="o">;</span>
<span class="err"> </span> <span class="err"> </span><span class="nd">@Test</span>
<span class="err"> </span> <span class="err"> </span><span class="kd">public</span><span class="err"> </span><span class="kt">void</span><span class="err"> </span><span class="n">testLogin</span><span class="o">()</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nc">UserManager</span><span class="err"> </span><span class="n">mockUserManager</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="nc">Mockito</span><span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="nc">UserManager</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nc">PasswordValidator</span><span class="err"> </span><span class="n">mPasswordValidator</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="nc">Mockito</span><span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="nc">PasswordValidator</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nc">Mockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">mPasswordValidator</span><span class="o">.</span><span class="na">verifyPassword</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">anyString</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="n">loginPresenter</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="k">new</span><span class="err"> </span><span class="nc">LoginPresenter</span><span class="o">(</span><span class="n">mockUserManager</span><span class="o">,</span><span class="err"> </span><span class="n">mPasswordValidator</span><span class="o">);</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nc">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="k">new</span><span class="err"> </span><span class="nc">Answer</span><span class="o">()</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nd">@Override</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="kd">public</span><span class="err"> </span><span class="nc">Object</span><span class="err"> </span><span class="n">answer</span><span class="o">(</span><span class="nc">InvocationOnMock</span><span class="err"> </span><span class="n">invocation</span><span class="o">)</span><span class="err"> </span><span class="kd">throws</span><span class="err"> </span><span class="nc">Throwable</span><span class="err"> </span><span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="c1">//这里可以获得传给performLogin的参数</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nc">Object</span><span class="o">[]</span><span class="err"> </span><span class="n">arguments</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="n">invocation</span><span class="o">.</span><span class="na">getArguments</span><span class="o">();</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="c1">//callback是第三个参数</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="nc">UserManager</span><span class="o">.</span><span class="na">NetCallback</span><span class="err"> </span><span class="n">callback</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="o">(</span><span class="nc">UserManager</span><span class="o">.</span><span class="na">NetCallback</span><span class="o">)</span><span class="err"> </span><span class="n">arguments</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="n">callback</span><span class="o">.</span><span class="na">onFailure</span><span class="o">(</span><span class="s">"404 Not found"</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="k">return</span><span class="err"> </span><span class="mi">404</span><span class="o">;</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">mockUserManager</span><span class="o">).</span><span class="na">performLogin</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">anyString</span><span class="o">(),</span><span class="err"> </span><span class="nc">Mockito</span><span class="o">.</span><span class="na">anyString</span><span class="o">(),</span><span class="err"> </span><span class="nc">Mockito</span><span class="o">.</span><span class="na">any</span><span class="o">(</span><span class="nc">UserManager</span><span class="o">.</span><span class="na">NetCallback</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="n">loginPresenter</span><span class="o">.</span><span class="na">login</span><span class="o">(</span><span class="s">"aya"</span><span class="o">,</span><span class="err"> </span><span class="s">"123456"</span><span class="o">);</span>
<span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="注解mock-spy">注解@Mock @Spy</h2><p>@Mock用于代替Mockito.mock创建mock对象。 用在类字段上。</p><p>spy 对应注解 @Spy，和 @Mock 是一样用的。部分mock。对于@Spy，如果发现修饰的变量是 null，会自动调用类的无参构造函数来初始化。</p><p>所以下面两种写法是等价的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写法1</span>
<span class="nd">@Spy</span>
<span class="kd">private</span> <span class="nc">ExampleService</span> <span class="n">spyExampleService</span><span class="o">;</span>

<span class="c1">// 写法2</span>
<span class="nd">@Spy</span>
<span class="kd">private</span> <span class="nc">ExampleService</span> <span class="n">spyExampleService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ExampleService</span><span class="o">();</span>
</code></pre></div></div><h2 id="测试隔离-1">测试隔离</h2><p>根据 JUnit 单测隔离 ，当 Mockito 和 JUnit 配合使用时，也会将非static变量或者非单例隔离开。</p><p>比如使用 @Mock 修饰的 mock 对象在不同的单测中会被隔离开。不管一个测试做什么，都不会影响其他测试。</p><h2 id="实现原理-继承">实现原理-继承</h2><p>Mockito使用继承的方式实现mock的，用CGLIB生成mock对象代替真实的对象进行执行，为了mock实例的方法，你可以在subclass中覆盖它。</p><p>因此无法mock静态方法。</p><p><strong>不能mock静态、final、私有方法</strong></p><h2 id="参考">参考</h2><p><a href="https://segmentfault.com/a/1190000006746409">手把手教你 Mockito 的使用</a></p><h1 id="mockito-inlinemockito-core的升级版">Mockito-inline(Mockito-core的升级版)</h1><p>依赖上，一般是说要用 <code class="language-plaintext highlighter-rouge">mockito-inline</code> 替换 <code class="language-plaintext highlighter-rouge">mockito-core</code> 依赖。 实质上 <code class="language-plaintext highlighter-rouge">mockito-inline</code> 就是给 mockito-core 添加了两个插件配置</p><p>使用了什么技术？ bytebuddy, 运行时生成Java class</p><p>注意mockito mock静态只对当前线程有效， 这点不如powermock。</p><p>支持mock静态、final等</p><p>如果你需要使用<code class="language-plaintext highlighter-rouge">mockito-inline</code>模块提供的额外功能，你需要显式地将它导入到项目中，而不是默认包含在<code class="language-plaintext highlighter-rouge">mockito-core</code>中。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="nv">org</span><span class="o">.</span><span class="py">mockito</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">mockito</span><span class="o">-</span><span class="n">inline</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="n">版本号</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">scope</span><span class="o">&gt;</span><span class="n">test</span><span class="o">&lt;/</span><span class="n">scope</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</code></pre></div></div><h2 id="mock无参的静态方法">Mock无参的静态方法</h2><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">givenStaticMethodWithNoArgs_whenMocked_thenReturnsMockSuccessfully</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="nc">StaticUtils</span><span class="o">.</span><span class="na">name</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"Baeldung"</span><span class="o">);</span>

    <span class="k">try</span> <span class="o">(</span><span class="nc">MockedStatic</span><span class="o">&lt;</span><span class="nc">StaticUtils</span><span class="o">&gt;</span> <span class="n">utilities</span> <span class="o">=</span> <span class="nc">Mockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="nc">StaticUtils</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">utilities</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="nl">StaticUtils:</span><span class="o">:</span><span class="n">name</span><span class="o">).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">"Eugen"</span><span class="o">);</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="nc">StaticUtils</span><span class="o">.</span><span class="na">name</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"Eugen"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">assertThat</span><span class="o">(</span><span class="nc">StaticUtils</span><span class="o">.</span><span class="na">name</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"Baeldung"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>从 Mockito 3.4.0 开始，我们可以使用<code class="language-plaintext highlighter-rouge">Mockito.mockStatic(Class&lt;T&gt; classToMock)</code>方法来模拟对静态方法调用的调用。<strong>此方法为我们的类型返回一个MockedStatic对象，它是一个作用域模拟对象。</strong></p><p>因此，在我们上面的单元测试中，<em>实用程序</em>变量表示具有线程局部显式范围的模拟。<strong>请务必注意，作用域模拟必须由激活模拟的实体关闭。</strong>这就是为什么我们在 try-with-resources 构造中定义我们的模拟，以便在我们完成作用域块时自动关闭模拟。</p><h2 id="mock带参数的静态方法">Mock带参数的静态方法</h2><p>我们通常用的 <code class="language-plaintext highlighter-rouge">Mockito.when(T methodCall) </code>的参数是一个方法调用的返回值，所以当 Mock 带参数的静态方法时与<code class="language-plaintext highlighter-rouge"> Mockito.when(obj.foo(1, 2)).thenReturn(34)) </code>的用法是不一样的，MockedStatic.when() 的参数需要放一个 () -&gt; 对象.of(anyInt(), anyInt(), anyInt()) 这样的 Lambda.</p><p>比如要mock静态函数A(b int)</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">theMock</span><span class="o">.</span><span class="na">when</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">类</span><span class="o">.</span><span class="na">A</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">xxx</span><span class="o">);</span>
</code></pre></div></div><p>theMock就是MockStatic返回的。</p><p>对静态方法调用的 verify 也要用 theMock 的 verify() 方法，而不是 Mockito.verify()。</p><h2 id="mock-final类和final方法">Mock final类和final方法</h2><p>和mock一般方法无区别</p><p><a href="https://www.baeldung.com/mockito-final">参考</a></p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">MyList</span> <span class="n">myList</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MyList</span><span class="o">();</span>

    <span class="nc">MyList</span> <span class="n">mock</span> <span class="k">=</span> <span class="nf">mock</span><span class="o">(</span><span class="nv">MyList</span><span class="o">.</span><span class="py">class</span><span class="o">);</span>
    <span class="nf">when</span><span class="o">(</span><span class="nv">mock</span><span class="o">.</span><span class="py">finalMethod</span><span class="o">()).</span><span class="py">thenReturn</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div><h2 id="mock-构造函数-mock代码里自己new的对象">Mock 构造函数 Mock代码里自己new的对象</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        //mock代码中自己new的实例及“该实例的方法”        
        MockedConstruction&lt;NewObject&gt; newObjectMocked = 	  Mockito.mockConstruction(NewObject.class);        Mockito.when(obj.haha()).thenReturn("who am i ?");

</code></pre></div></div><p><a href="https://cloud.tencent.com/developer/article/1877722">参考</a></p><h1 id="powermockito">PowerMockito</h1><h2 id="和mockito比较">和mockito比较</h2><p><strong>Mockito、EasyMock、JMock等比较流行Mock框架有个共同的缺点，都不能mock静态、final、私有方法等，而PowerMock可以完美解决以上框架的不足</strong></p><p><strong>PowerMockito is a PowerMock’s extension API to support Mockito</strong>. The PowerMock framework provides a class called PowerMockito used to create mock objects and initiates verification and expectation. The PowerMockito provides the functionality to work with the Java reflection API.</p><p>是PowerMock的一部分。</p><h2 id="使用">使用</h2><p><a href="https://juejin.cn/post/6850418110105649166">参考</a></p><p>开头包是PowerMockito</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nv">PowerMockRunner</span><span class="o">.</span><span class="py">class</span><span class="o">)</span>
<span class="nd">@PrepareForTest</span><span class="o">({</span><span class="nv">SchoolManageProxy</span><span class="o">.</span><span class="py">class</span><span class="o">,</span> <span class="nv">RedisUtils</span><span class="o">.</span><span class="py">class</span><span class="o">,</span> <span class="nv">StudentService</span><span class="o">.</span><span class="py">class</span><span class="o">})</span>
<span class="c1">// @PowerMockIgnore({"javax.management.*", "javax.net.ssl.*"})</span>
<span class="nd">@SuppressStaticInitializationFor</span><span class="o">({</span><span class="s">"cn.ganzhiqiang.ares.unittest.SchoolManageProxy"</span><span class="o">})</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">StudentServiceTest</span> <span class="o">{</span>
<span class="o">...</span>
</code></pre></div></div><h3 id="mock对redis的静态调用">mock对Redis的静态调用</h3><p>我们使用PowerMock来mock对静态方法的调用，注意需要将<code class="language-plaintext highlighter-rouge">RedisUtils</code>类，加入<code class="language-plaintext highlighter-rouge">@PrepareForTest</code>注解中，我们既mock了<code class="language-plaintext highlighter-rouge">getArray</code>方法，也mock了<code class="language-plaintext highlighter-rouge">setArray</code>方法，其实<code class="language-plaintext highlighter-rouge">setArray</code>不需要mock这里显式的mock了</p><p>mock静态类注意</p><ol><li>加到PrepareForTest</li><li>mockStatic下</li></ol><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="nc">RedisUtils</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// mock掉对Redis的静态调用</span>
<span class="nc">PowerMockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="nc">RedisUtils</span><span class="o">.</span><span class="na">getArray</span><span class="o">(</span><span class="n">eq</span><span class="o">(</span><span class="s">"tom"</span><span class="o">),</span> <span class="n">eq</span><span class="o">(</span><span class="nc">StudentBo</span><span class="o">.</span><span class="na">class</span><span class="o">))).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">());</span>
<span class="c1">// 显式的mock掉静态的void的方法（可以不mock）</span>
<span class="nc">PowerMockito</span><span class="o">.</span><span class="na">doNothing</span><span class="o">().</span><span class="na">when</span><span class="o">(</span><span class="nc">RedisUtils</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"setArray"</span><span class="o">,</span> <span class="n">anyString</span><span class="o">(),</span> <span class="n">anyList</span><span class="o">(),</span> <span class="n">anyInt</span><span class="o">());</span>
<span class="n">复制代码</span>
</code></pre></div></div><h3 id="mock单例类">mock单例类</h3><p>mock单例类相对来说复杂一点，逻辑上先用Powermock mock出单例类，然后再给单例类的<code class="language-plaintext highlighter-rouge">getInstance</code>方法打桩，返回之前mock，再对mock类实际调用的方法打桩即可，代码如下</p><div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">PowerMockito</span><span class="nc">.mockStatic</span><span class="o">(</span><span class="nt">SchoolManageProxy</span><span class="nc">.class</span><span class="o">)</span><span class="p">;</span>
<span class="c1">// Powermock mock出单例类</span>
<span class="nt">SchoolManageProxy</span> <span class="nt">mockSchoolManageProxy</span> <span class="o">=</span> <span class="nt">PowerMockito</span><span class="nc">.mock</span><span class="o">(</span><span class="nt">SchoolManageProxy</span><span class="nc">.class</span><span class="o">)</span><span class="p">;</span>
<span class="c1">// 给单例类的getInstance方法打桩</span>

<span class="nt">PowerMockito</span><span class="nc">.when</span><span class="o">(</span><span class="nt">SchoolManageProxy</span><span class="nc">.getInstance</span><span class="o">())</span><span class="nc">.thenReturn</span><span class="o">(</span><span class="nt">mockSchoolManageProxy</span><span class="o">)</span><span class="p">;</span>
<span class="c1">// 对mock类queryPerson的方法打桩</span>
<span class="nt">when</span><span class="o">(</span><span class="nt">mockSchoolManageProxy</span><span class="nc">.queryPerson</span><span class="o">(</span><span class="nt">anyList</span><span class="o">()))</span><span class="nc">.thenReturn</span><span class="o">(</span><span class="nt">Collections</span><span class="nc">.emptyList</span><span class="o">())</span><span class="p">;</span>
</code></pre></div></div><p>单例类就是构造方法为private无法实例化，</p><h3 id="mock私有方法">mock私有方法</h3><p>可以看到<code class="language-plaintext highlighter-rouge">queryStudentScoreByKeyword</code>方法调用了该类的私有方法<code class="language-plaintext highlighter-rouge">processKeyword</code>，如果该方法耗时过长，使用powermock也可以mock该私有方法。 这里用spy演示。</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mock 实例</span>
<span class="c1">// spy的标准是：如果不打桩，默认执行真实的方法，如果打桩则返回桩实现。</span>
<span class="n">studentServiceUnderTest</span> <span class="p">=</span> <span class="n">PowerMockito</span><span class="p">.</span><span class="nf">spy</span><span class="p">(</span><span class="n">studentServiceUnderTest</span><span class="p">);</span>
<span class="c1">// mock私有方法processKeyword</span>
<span class="c1">// doReturn(...) when(...)不做真实调用，但是when(...) thenReturn(...)还是会真实调用原方法，只是返回了指定的结果</span>
<span class="n">PowerMockito</span><span class="p">.</span><span class="nf">doReturn</span><span class="p">(</span><span class="s">"tom"</span><span class="p">).</span><span class="nf">when</span><span class="p">(</span><span class="n">studentServiceUnderTest</span><span class="p">,</span> <span class="s">"processKeyword"</span><span class="p">,</span> <span class="nf">anyString</span><span class="p">());</span>
</code></pre></div></div><p>注意：</p><ol><li>when不能调用private方法了，所以是用字符串表示。</li></ol><h2 id="注解-preparefortest">注解 @PrepareForTest</h2><p>当使用PowerMockito.whenNew方法时，必须加注解@PrepareForTest和@RunWith。注解@PrepareForTest里写的类是需要mock的new对象代码所在的类。</p><p>当需要mock final方法的时候，必须加注解@PrepareForTest和@RunWith。注解@PrepareForTest里写的类是final方法所在的类。</p><p>当需要mock静态方法的时候，必须加注解@PrepareForTest和@RunWith。注解@PrepareForTest里写的类是静态方法所在的类。</p><p>当需要mock私有方法的时候, 只是需要加注解@PrepareForTest，注解里写的类是私有方法所在的类</p><p>当需要mock系统类的静态方法的时候，必须加注解@PrepareForTest和@RunWith。注解里写的类是需要调用系统方法所在的类</p><h1 id="其他">其他</h1><h2 id="visiblefortesting">@VisibleForTesting</h2><p><code class="language-plaintext highlighter-rouge">@VisibleForTesting</code>是Google Guava库中的一个注解，用于标识方法、构造函数、字段等在单元测试中可见，但在正常的类使用过程中应该被视为“仅限测试使用”。</p><p><code class="language-plaintext highlighter-rouge">@VisibleForTesting</code>注解仅仅是一个用于表明可见性意图的注解，它不会改变方法的实际访问权限。因此，将<code class="language-plaintext highlighter-rouge">@VisibleForTesting</code>注解标注在<code class="language-plaintext highlighter-rouge">private</code>方法上并不会使该方法在测试中变为可访问，也不会直接影响对该方法的<code class="language-plaintext highlighter-rouge">mock</code>操作。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.google.common.annotations.VisibleForTesting</span><span class="o">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">MyService</span> <span class="o">{</span>
    <span class="k">private</span> <span class="nc">SomeDependency</span> <span class="n">dependency</span><span class="o">;</span>

    <span class="nd">@VisibleForTesting</span>
    <span class="k">protected</span> <span class="n">void</span> <span class="nf">setDependency</span><span class="o">(</span><span class="nc">SomeDependency</span> <span class="n">dependency</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="py">dependency</span> <span class="k">=</span> <span class="n">dependency</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 使用 dependency 进行操作...</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><h2 id="严重是否抛出异常">严重是否抛出异常</h2><p>If verify it doesn’t throw exception.The test case will fail when it find exception. Just throw it directly.</p><p>Otherwise, org.junit.jupiter.api.assertThrowsExactly 可以判断它是否抛出了异常。</p><h2 id="injectmock">@InjectMock</h2><blockquote><p><a href="https://juejin.cn/post/6975525979418525709#heading-4">参考</a></p></blockquote><p>被@InjectMocks注解的对象就是要被我们测试的对象，它会被自动的实例化。且其包含的成员变量会被相应的@Mock注解的对象自动赋值。</p><ul><li>允许快速的mock和spy注入。</li><li>最大限度地减少重复的mock和spy注入代码。</li></ul><p><strong>Mockito 将尝试仅通过构造函数注入、setter 注入或属性注入依次注入mock对象。如果任一策略失败，则 Mockito不会报告失败</strong>；策略细节<a href="https://juejin.cn/post/6975525979418525709#heading-6">参考</a></p><p>被测对象<code class="language-plaintext highlighter-rouge">foo</code>内如果包含<code class="language-plaintext highlighter-rouge">Bar</code>类型的成员变量，此时Mockito会自动将<code class="language-plaintext highlighter-rouge">bar</code>注入到<code class="language-plaintext highlighter-rouge">foo</code>中被<code class="language-plaintext highlighter-rouge">@InjectMocks</code>注解的对象<code class="language-plaintext highlighter-rouge">foo</code>在调用其方法时会执行其实际的代码逻辑。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">public</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span>

    <span class="k">private</span> <span class="nc">Bar</span> <span class="n">bar</span><span class="o">;</span>

    <span class="n">public</span> <span class="n">int</span> <span class="nf">sum</span><span class="o">(</span><span class="n">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nv">bar</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">Bar</span> <span class="o">{</span>

    <span class="n">public</span> <span class="n">int</span> <span class="nf">add</span><span class="o">(</span><span class="n">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">//注意我们使用了MockitoJUnitRunner</span>
<span class="nd">@RunWith</span><span class="o">(</span><span class="nv">MockitoJUnitRunner</span><span class="o">.</span><span class="py">class</span><span class="o">)</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">MockitoTest</span> <span class="o">{</span>
  	<span class="c1">//foo 对象内部的成员变量会自动被 @Mock 注解的生成的对象注入。</span>
    <span class="nd">@InjectMocks</span>
    <span class="k">private</span> <span class="nc">Foo</span> <span class="n">foo</span><span class="o">;</span>

  	<span class="c1">//bar 对象会自动的注入到 @InjectMocks 注解的对象的成员变量中去。</span>
    <span class="nd">@Mock</span>
    <span class="k">private</span> <span class="nc">Bar</span> <span class="n">bar</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="n">public</span> <span class="n">void</span> <span class="nf">mockTest</span><span class="o">()</span> <span class="o">{</span>
      	<span class="c1">//先对mock对象的待测方法进行存根，当真正执行到mock对象的此方法时</span>
      	<span class="c1">//会直接返回存根的结果而不会调用mock对象的实际代码</span>
        <span class="nv">Mockito</span><span class="o">.</span><span class="py">when</span><span class="o">(</span><span class="nv">bar</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)).</span><span class="py">thenReturn</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
        
      	<span class="n">int</span> <span class="n">result</span> <span class="k">=</span> <span class="nv">foo</span><span class="o">.</span><span class="py">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
      	<span class="c1">//验证是否是存根返回的值</span>
        <span class="nv">Assert</span><span class="o">.</span><span class="py">assertEquals</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>使用注解是做java单测的最佳实践。</p><ul><li>使用@InjectMocks注解，同时结合在类上使用注解@RunWith(MockitoJUnitRunner.class)。我们的原则是尽量使用注解的方式创建测试相关的对象。</li><li>使用@Mock而不是Mockito.mock()方法创建mock对象。</li><li>使用@Spy而不是Mockito.spy()方法创建spy对象。当然在某个具体测试方法内你发现@Spy不能方便的满足你的需求时请使用Mockito.spy()的方式。</li></ul><h1 id="总结">总结</h1><p>mockito-core支持mock public方法，不支持static, final, private方法。</p><p>mockito-inline额外支持mock static/final方法/final类，mock构造方法。</p><p>powerMockito最好用，啥都支持，也支持Mock private方法，但只能与Junit4集成，不能用于Junit5。</p></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
