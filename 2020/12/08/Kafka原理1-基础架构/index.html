<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>kafka原理1-基础架构 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="kafka原理1-基础架构"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="KafkaServer"><meta name="og:description" content="KafkaServer"><meta property="og:url" content="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-12-08"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="kafka原理1-基础架构"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">kafka原理1-基础架构</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/12/08 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Mq" title="Mq">Mq</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5131 字，约 15 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="kafkaserver">KafkaServer</h2><p>使用消息队列的主要好处有：</p><ul><li>解耦</li><li>峰值处理能力、异步</li><li>持久化</li><li>顺序保证</li><li>扩展性</li></ul><h2 id="1-架构">1. 架构</h2><h3 id="11-概念">1.1 概念</h3><p><strong>Broker：</strong></p><p>Kafka集群中的一台服务器。</p><p><strong>Topic：</strong></p><p>主题。消息的分类，是逻辑上的概念，实际以partition的形式存放在各Broker服务器上。</p><p><strong>Partition：</strong></p><ul><li>分区。是物理上的概念，组成Topic的单位。</li></ul><p><strong>Replica：</strong></p><p>副本。是具体的分区，比Partition更具体的物理概念，一个真实的目录，存放在一台Broker服务器上。在代码中又分为leader和follower。</p><p><strong>Producer：</strong></p><ul><li>生产者。负责发送消息到Broker。</li></ul><p><strong>Consumer：</strong></p><ul><li>消费者。负责订阅Topic并拉取消息。</li></ul><p><strong>CousumerGroup：</strong></p><p>消费者组。每条消息只被组内成员消费一次。</p><h3 id="12-逻辑架构">1.2 逻辑架构</h3><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/60af40353a110cbc9948067b4502a75d.png" alt="image" /></p><h3 id="13-物理架构">1.3 物理架构</h3><h4 id="131-集群物理架构">1.3.1 集群物理架构</h4><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/0993d208eeb5dfe12a9e6f132e9d0eef.png" alt="image" /></td></tr></tbody></table></li></ul><p>如上图，本集群有：</p><ul><li>4台broker。broker_1 到 broker_4</li><li>2个topic。topic_A和topic_B</li><li>topic_A的分区数是4。topicA_0 到 topic_3</li><li>topic_A的副本因子是2。例如topicA_0这个分区，有两个副本，分别分布在broker_1和broker_3两台机器上。</li></ul><h4 id="132-一个副本目录结构">1.3.2 一个副本目录结构</h4><p>上图中的topicA-0是一个partition，准确的说应该称之为一个副本，即Replica。它是broker_1服务器上的一个日志目录，其内部由多个segment文件组成。topicA-0目录结构：</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/15917459e5a10f3a6839bc535f0afbc6.png" alt="image" /></td></tr></tbody></table></li></ul><p><strong>*.log文件</strong>：日志文件</p><p><strong>*.index文件</strong>：稀疏索引文件</p><p><strong>*.timeindex文件</strong>：时间戳索引文件。根据时间戳快速定位消息所在位置。（Kafka API offsetsForTimes方法所使用）</p><p>index文件与log文件关系:</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/42a9581fb80035875abcaff0e6902542.png" alt="image" /></td></tr></tbody></table></li></ul><h3 id="14-代码架构">1.4 代码架构</h3><h4 id="141-线程池">1.4.1 线程池</h4><p>KafkaServer在启动时，初始化KafkaRequestHandlerPool线程池</p><p>KafkaRequestHandlerPool（线程池）由KafkaRequestHandler组成</p><p>KafkaRequestHandler调用KafkaApis处理request</p><p>下图：Kafka处理request的线程池</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/83fbd9155e52d987bb704a028f719772.png" alt="image" /></td></tr></tbody></table></li></ul><p>kafkaServer接收的请求，包括来自客户端的请求和来自其他server的请求。客户端请求例如producer发送消息请求、consumer消费消息请求。其他broker请求例如副本同步日志请求。请求类型有21个枚举值。</p><p>所有的请求最终会收敛到Broker服务器上的KafkaApis.handle方法，如下图：</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/9fb206ff88bb93e7d92cf7dced0e540b.png" alt="image" /></td></tr></tbody></table></li></ul><h4 id="142-处理request的组件">1.4.2 处理request的组件</h4><p>有3个重要组件处理上图21种请求，它们分别是：</p><ul><li><p><strong>ReplicaManager</strong></p><ul><li>把Produce日志写入磁盘</li><li>如果副本是follower，启动副本同步线程，发送fetch请求</li><li>如果副本是leader，处理来自副本的fetch请求</li></ul></li><li><p><strong>Coordinator</strong></p><ul><li>管理Consumer的balance</li></ul></li><li><p><strong>KafkaController</strong></p><ul><li>Broker 的上线、下线</li><li>新建 topic 或已有 topic 的扩容，topic 删除</li><li>处理replica的分配、迁移、leader 选举、leader 切换</li></ul></li></ul><p>下图：处理request请求</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/d85330c319388dddad5de8b90e743c9a.png" alt="image" /></td></tr></tbody></table></li></ul><h2 id="2-可用性可靠性保障">2. 可用性、可靠性保障</h2><h3 id="21-集群高可用性">2.1 集群高可用性</h3><p>在应对单点故障时，kafka仍然能够对外提供服务，主要通过以下特性保证：</p><ul><li>分布式集群模式，多台服务器，分散单服务器压力。</li><li>一个topic拆分成多partition分区</li><li>一个partition建立n个副本，分为leader和follower，保持同步。leader一旦宕机从follower选举出新的leader提供读写日志服务。</li></ul><h3 id="22-消息可靠性与一致性"><strong>2.2 消息可靠性与一致性</strong></h3><p>面对故障时是否仍然保持最终一致。</p><ul><li>producer.ACKS = [ -1, 0, 1] 保证日志生产的准确性。</li><li>HW和LEO机制。保证日志同步的准确性。</li></ul><h4 id="221-produceracks">2.2.1 producer.ACKs</h4><p><strong>ACKs=1</strong></p><ul><li>producer发送日志，只要Leader写入成功，则返回producer成功</li></ul><p><strong>ACKs=0</strong></p><ul><li>producer发送日志，不需要等待leader返回成功</li><li>传输效率最高，可靠性最差</li></ul><p><strong>ACKs=-1</strong></p><ul><li>producer发送日志，Leader需要等待ISR中所有的Replica同步完成后，才返回给客户端成功</li><li>可靠性最高，效率最差。集群的瓶颈卡在了最差的那台机器</li></ul><h4 id="222-hw和leo">2.2.2 HW和LEO</h4><p><strong>LEO</strong></p><ul><li>LogEndOffset，日志末端偏移量</li><li>每个Replica最后一条log所在的位置</li></ul><p><strong>HW</strong></p><ul><li>HighWaterMark，高水位</li><li>HW = min( ISR.LEO )</li><li>已经被ISR完成同步的消息的位置</li><li>Consumer最多只能消费到HW所在的位置</li><li>对于内部Replica的同步消息请求，没有HW的限制</li></ul><p>如下图，HW与LEO位置示意：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/b9466c871eb1de0157d41377cd06d94a.png" alt="image" /></p><p><strong>HW与LEO更新过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/d64eb94018321663dfe38c6ea278bbde.png" alt="image" /></p><p><strong>HW与LEO更新过程（详细）：</strong></p><p>HW与LEO存在于每一个副本，并不仅仅存在于leader。</p><p>leader中维护了两套LEO，一套是自己的，另一套是follower的。</p><p>假设目前消息队列为空，follower启动的同步消息线程，不会获取到任何消息，也不会更新HW和LEO</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/ec19a2cae1dc96baef8fe646f758b97a.png" alt="image" /></td></tr></tbody></table></li></ul><p>此时，Producer给leader发送了一条日志</p><ol><li>leader的LEO + 1</li><li>leader尝试更新HW，HW = min(LEO)，仍然是0</li></ol><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/219fab4d24791360c434d96ad75c71e8.png" alt="image" /></td></tr></tbody></table></li></ul><p>follower发送fetch请求：</p><ul><li><table><tbody><tr><td>*<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/65578cc63bfff21a8529caed7fd904ff.png" alt="image" /></td></tr></tbody></table></li></ul><ol><li>req的offset参数是0，表示从第0个消息开始fetch</li><li>leader更新remote LEO=0，这是因为follower request的offset是0</li><li>leader尝试更新HW，HW = min(LEO)，仍然是0</li><li>leader把数据和此时的leader HW返回给follower</li><li>follower接收到respsonse，更新LEO=1，更新HW仍然是0</li></ol><p>follower发送第二轮fetch请求:</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/a730c7a7e7b6ea34fa9d3a71e1911f57.png" alt="image" /></p><ol><li>req的offset参数是1，表示请求同步第一个消息</li><li>leader更新remote LEO=1，因为follower request的offset是1</li><li>leader尝试更新HW，HW=min(LEO)，<strong>此时更新HW=1</strong></li><li>leader把数据和此时的leader HW返回给follower</li><li>follower接收到respsonse，更新HW，<strong>此时更新HW=1</strong></li></ol><p>至此，producer生产的消息已经保存到kafka的各个副本上了，Consumer已经可以消费到HW位置了。</p><p>一个消息从写入kafka到完成更新HW，需要follower发送两轮fetch请求。 第一轮fetch是follow告诉leader自己的leo, 以及更新offset以及leo. 第二轮fetch是告诉producer自己最新的leo用于leader更新hw.</p><h2 id="3-常见的选举分配rebalance">3. 常见的选举、分配、Rebalance</h2><p>Kafka集群依赖Zookeeper，Zookeeper的数据模型是一棵树，kafka的组件把回调函数注册到zk树节点下，在节点发生变更时，zk通过回调通知kafka。</p><h3 id="31-controller选举">3.1 Controller选举</h3><p>KafkaController的选举过程比较简单，所有的broker启动时，抢占注册Zookeeper的/Controller节点，注册成功即成为Controller。伪代码如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def elect: Boolean = {
    leaderId = getControllerID   // 查询当前集群ControllerId
    
    if(leaderId != -1) {  // Controller早已存在了
       return amILeader
    }
    try {
        zkCheckedEphemeral.create()  // 注册到zookeeper leader节点
    } catch {
        case _: ZkNodeExistsException =&gt;   // leader被别人注册，抛异常
        leaderId = getControllerID
    }
    return amILeader
}
</code></pre></div></div><h3 id="32-consumer启动触发rebalance">3.2 Consumer启动触发Rebalance</h3><p>由于Broker数量通常不会很多，所以Controller选举采用抢占注册的方式不会给zookeeper带来很大压力。</p><p>但是对于Consumer而言，一个大的Topic可能对应创建了数量庞大的Consumer，Kafka老版本也确实是这么实现的，这种情况下，存在两个问题：</p><ul><li>羊群效应：任何一个Consumer的增减都会触发所有Consumer的Rebalance</li><li>脑裂效应：每个Consumer分别单独通过Zookeeper判断哪些Consumer 宕机了，那么不同Consumer在同一时刻从Zookeeper看到的视角就可能不一样。这就会造成不正确的Reblance尝试。</li></ul><p>新版本的Kafka对此做了优化，使用了“协调员”这一角色，作为“权威”“指挥”Consumer Rebalance</p><p>新版本，Consumer启动过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/5849ad51359fe5c181c7c4673b8f6da8.png" alt="image" /></p><ol><li>Consumer启动，向任意一台broker发送请求，得到响应。响应内容为“协调员的地址”。</li><li>Consumer找到自己的Coordinator，<strong>持续</strong>发送心跳请求</li><li>Consumer判断心跳请求的响应的ErrorCode，如果没有异常则消费数据。如果有IllegalGeneration异常，说明Coordinator正在计算rebalance，统一给Consumer分配Partition。</li><li>Consumer给Coordinator发送JonGroup请求，得到响应，得知自己被分配了哪个Partition，连接那个partition进行消费。</li></ol><h3 id="33-leader-replica宕机触发rebalance">3.3 Leader Replica宕机触发Rebalance</h3><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/c981ddff865953bf37066940aa92cc28.png" alt="image" /></p><p>图：broker宕机触发replica选举</p><p>Replica分布在broker上，Replica leader掉线其实就是leader所在的broker的宕机，从宕机到集群恢复稳定态过程：</p><ol><li>Broker启动，在zookeeper的broker/ids路径注册临时节点</li><li>Controller启动，注册watcher函数，监听zookeeper上述路径的节点变化</li><li>Broker因为网络、断电、机器故障等原因宕机</li><li>zookeeper监听到broker节点掉线，触发controller注册的watcher，通过回调函数通知Controller</li><li>Controller决定一个set_p集合，包含宕机broker上的所有partition</li><li>对于上述的partition，Controller从/brokers/topics/[topic]/partitions/[partition]/state读取该 Partition 当前的 ISR</li><li>Controller从上述ISR中选出Leader。选举算法是quorum（法定人数）算法，通过数据冗余来保证数据一致性的投票算法。对于Kafka而言，选举人数就是ISR。</li><li>Controller将新的 Leader、ISR 和新的leader_epoch及controller_epoch写入/brokers/topics/[topic]/partitions/[partition]/state</li><li>向set_p相关的broker发送LeaderAndIsrRequest通知受影响的broker更新信息</li></ol><h3 id="34-topic分配到broker">3.4 topic分配到broker</h3><ol><li>用户调用脚本创建topic，指定分区数和副本数</li><li>Controller接收CreateTopic请求，计算broker与partition的对应关系</li><li>Controller向Broker发送LeaderAndIsr请求，通知Broker有了新的Topic，各broker负责创建Partition</li></ol><p>副本分配算法：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* To achieve this goal for replica assignment without considering racks, we:
* 1. Assign the first replica of each partition by round-robin, starting from a random position in the broker list.
* 2. Assign the remaining replicas of each partition with an increasing shift.
*
* Here is an example of assigning
* broker-0  broker-1  broker-2  broker-3  broker-4
* p0        p1        p2        p3        p4       (1st replica)
* p5        p6        p7        p8        p9       (1st replica)
* p4        p0        p1        p2        p3       (2nd replica)
* p8        p9        p5        p6        p7       (2nd replica)
* p3        p4        p0        p1        p2       (3nd replica)
* p7        p8        p9        p5        p6       (3nd replica)
</code></pre></div></div></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
