<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>系统设计 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2020/12/28/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="系统设计"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="系统设计- 参考"><meta name="og:description" content="系统设计- 参考"><meta property="og:url" content="https://mafulong.github.io/2020/12/28/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-12-28"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="系统设计"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">系统设计</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/12/28 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#SystemDesign" title="SystemDesign">SystemDesign</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6460 字，约 19 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="系统设计--参考">系统设计- 参考</h2><p>几本书：</p><ul><li><p><a href="https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd6.html">谷歌面试准备完全指南 Done</a></p></li><li><a href="https://github.com/donnemartin/system-design-primer">donnemartin/system-design-primer多语言翻译 Done</a><ul><li><a href="https://wizardforcel.gitbooks.io/system-design-primer/content/">中文版本</a></li></ul></li><li><a href="https://github.com/lei-hsia/grokking-system-design"> 必看Grokking system design, repo无法访问</a></li></ul><p>设计数据密集型应用-Data-Intensive Application</p><p><a href="https://github.com/donnemartin/interactive-coding-challenges">https://github.com/donnemartin/interactive-coding-challenges</a></p><p><a href="https://acecodeinterview.com/2_week_prep/">两周系统设计面试速成大纲</a></p><h2 id="答题流程">答题流程</h2><p>高可用，主要以下几个方面:</p><ul><li>数据持久化</li><li>主从复制</li><li>自动故障恢复</li><li>集群化</li></ul><p>问面试官问题，即便很清晰也要问，将问题重新定义。</p><ol><li>Users: who will use, how the system will be used?</li><li>Scale: qps, tps等</li><li>Performance: the delay of write-to-read</li><li>Cost</li></ol><p>需求重新定义：这里不需要问面试官</p><p>对于功能模块: 定义api: name以及req, resp</p><p>对于非功能需求: 规模、性能、可用性。</p><p>scalability, performance, availability(灾备、无单点)</p><p>consistency, cost</p><p>一个大模块就组织出来了。</p><p>数据模型，来存储。</p><p>各有什么优缺点。</p><p>SQL是否可以满足，如何满足的，这块Nosql满足的话成本是不是更少。</p><p>处理服务 processing service</p><h3 id="时间分配">时间分配</h3><p>以40分钟的面试时间来算（掐头去尾除去自我介绍问问题），我面试的大概流程如下。</p><ul><li>【3分钟】理解需求 （询问系统的商业目的 + 询问系统的功能和技术需求 + 定义成功）<ul><li>Functional Requirements<ul><li>用户是否需要登录</li><li>仅仅上传图片，不需要上传视频</li><li>图片保存有效期</li></ul></li><li>Non-functional Requirements<ul><li>基本可用性</li><li>交互流畅、低延迟</li><li>是否支持某个动作反馈有一定延迟</li></ul></li></ul></li><li>【0-5分钟】资源估算（optional)（计算需要多少台机器，需要多少内存硬盘和CPU的能力）<ul><li>Capacity 可能非核心内容加上时间有限，做个大致计算估计的方法。<ul><li>Traffic<ul><li>qps xx times per day, xx times per second</li><li>tps, 按读写比10:1</li><li>peak qps: qps * 5</li></ul></li><li>Storage<ul><li>add data xx per day, xx per year</li><li>cache xx..</li></ul></li></ul></li></ul></li><li><p>【5分钟】High-level diagram</p></li><li><p>划分模块</p></li><li><p>【5分钟】数据结构与存储</p></li><li><p>【10分钟】核心子服务设计</p></li><li><p>【5分钟】接口设计</p></li><li><p>【5分钟】扩展性，容错性，延迟要求</p><ul><li><p>架构扩展性：</p><ul><li>关注： 存储数据量， 存储吞吐量； 解决方案：存储拆分、单体吞吐低可以batch，多级缓存。</li><li>服务： 吞吐压力： 先尝试扩容，无状态服务。否则降级： 保障核心服务，关闭弱依赖。</li><li>伸缩性： 无状态，可横向扩容</li><li>高峰期流量过高: mq削峰</li></ul></li><li><p>业务可扩展性</p><ul><li><p>搞多app矩阵的支持，增加namespace, appId</p></li><li><p>类型增加，增加ItemType</p></li></ul></li><li><p>容错性</p><ul><li>数据库挂了怎么办<ul><li>主从灾备</li></ul></li><li>接口挂了怎么办<ul><li>失败重试，缓存队列</li><li>防止雪崩，要熔断</li></ul></li><li>降级、熔断</li><li>异步<ul><li>消息队列 削锋</li></ul></li></ul></li></ul></li><li>【2-7分钟】专题 deep dive<ul><li>用户scope变大<ul><li>多机房同步</li><li>多语言</li></ul></li><li>某个时间点流量特别大了怎么办<ul><li>降级、熔断</li><li>异步</li></ul></li><li>缓存<ul><li>大V设计</li></ul></li></ul></li></ul><h2 id="系统设计时间估算">系统设计时间估算</h2><p><a href="https://www.raychase.net/6280">参考</a></p><p>1天86400s</p><p>每个字符占用 2 个字节</p><p>bit 是位，1 byte == 8 bits</p><p>B=byte, 1M = 1024byte</p><p>读写比默认10:1</p><p>数据类型的空间占用： 在很多系统中，Boolean 占用 1 个字节，字符占用 2 个字节，Integer/Float 是 4 个字节，Long/Double 则是 8 个字节。</p><h4 id="时间数量级">时间数量级</h4><p>Jeff Dean 十年前有一个<a href="https://research.cs.cornell.edu/ladis2009/talks/dean-keynote-ladis2009.pdf">著名的分享</a>，介绍了他认为重要的系统的数值。我觉在讨论多数系统来说，有这样几个关于时间的数值（参考数量级）比较常见（注意时间单位的关系：1 秒 = 1000 毫秒 (millisecond) = 1,000,000 微秒 (microsecond) = 1,000,000,000(nanosecond)）：</p><ul><li>CPU 访问（包括 CPU 缓存）：10 纳秒</li><li>内存访问：100 纳秒</li><li>HDD 磁盘访问：10 毫秒，如果是 SSD 大约快 100 倍</li><li>HDD 磁盘吞吐量：100 MB/s，如果是 SSD 则高几倍</li><li>同机房网络时延：1 毫秒</li><li>异地网络时延：10 毫秒</li><li>国际网络时延：100 毫秒</li></ul><h4 id="单机吞吐量上限">单机吞吐量上限</h4><ul><li>Web 服务器的 QPS：1000</li><li>RDB 单机 QPS：1000</li><li>NoSQL DB 磁盘单机 QPS：10K</li><li>内存访问单机 QPS：1M</li></ul><h2 id="系统设计常用算法">系统设计常用算法</h2><p><a href="https://github.com/resumejob/system-design-algorithms">参考</a></p><ul><li>Bloom filter</li><li>count-min sketch bloom filter基础上增加计数，以最小那个hash计数为值</li><li>Frugal Streaming<ul><li>Frugal Streaming uses only one unit of memory per group to compute a quantile for each group</li></ul></li><li>Geohash / S2 Geometry 地理位置</li><li>Leaky bucket / Token bucket 限流器</li><li>Lossy Counting ，top k频繁 hashmap不停轮换清counter为0的</li><li><a href="https://github.com/Aaaaash/blog/issues/10">Operational transformation</a> 操作转换，类似于google doc多人编辑时</li><li>Quadtree / Rtree ☑️<ul><li>四叉树是一种数据结构，每一个节点有四个孩子。一般需要用到四叉树的情况往往是二位平面，通过把区域分成四个区块来定义。</li><li>应用：比如确定并显示一条曲线的具体位置时</li></ul></li><li>Ray casting ☑️</li><li>Reverse index ✅</li><li>Rsync algorithm ✅</li><li>Trie algorithm ✅</li></ul><h3 id="bloom-filter">Bloom filter</h3><p>Bloom Filter 是由一个长度为 m 的比特位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。位数组均初始化为 0，所有哈希函数都可以分别把输入数据尽量均匀地散列。</p><p>当要插入一个元素时，将其数据分别输入 k 个哈希函数，产生 k 个哈希值。以哈希值作为位数组中的下标，将所有 k 个对应的比特置为 1。</p><p>当要查询（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的 k 个比特。如果有任意一个比特为 0，表明该元素一定不在集合中。如果所有比特均为 1，表明该元素有（较大的）可能性在集合中。为什么不是一定在集合中呢？因为一个比特被置为 1 有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在 Bloom Filter 中是绝不会出现的。</p><p><strong>优点：</strong></p><ul><li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li><li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li><li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li></ul><p><strong>缺点：</strong></p><ul><li>存在假阳性的概率，不适用于任何要求 100% 准确率的场景；</li><li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。我们可以简单地想到通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li></ul><p>所以，Bloom Filter 在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适，本文第一句话提到的用途即属于此类。另外，由于它不存在 <strong>假阴性</strong> 问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为 <strong>缓存系统（如Redis）的缓冲，防止缓存穿透</strong>。</p><h3 id="lossy-counting-method">Lossy Counting Method</h3><p>算法本身的作用是<strong>找出长度为 N 的数据流中出现频率超过 s % 的元素，保证误差小于 a %。</strong>其中 s 与 a 是传入的参数，a 一般设定为 s 的十分之一。此算法从数学上保证：</p><ol><li>在<a href="https://www.zhihu.com/search?q=数据流&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1030890806}">数据流</a>中，出现频率高于 s * N 的元素最后都会输出。</li><li>在数据流中，如果出现频率低于 ( s - a ) * N 的元素不会被输出。</li><li>估算的出现次数与实际次数的差距不会高于 a * N。</li></ol><p>算法实现起来也相对简单，只有三步：</p><ol><li>把现有的数据分成 N 个窗口，每个窗口的大小为 1 / a。</li><li>按顺序统计每一个窗口里面元素出现的个数并减去 1。</li><li>把剩下的值加起来并且返回所有大于 (s-a) * N 的值。</li></ol><p>优点：</p><ul><li>容易实现以及修改，能够控制元素频率以及误差。</li><li>快速高效，建立哈希表 V 只需要遍历一遍数据即可。</li><li>这个算法也适用于“如何设计一个显示最热门的 100个 标签的系统“这类场景。</li></ul><p>缺点：</p><ul><li>这个算法适用于玩家分布比较集中的情况，也就是说有很多玩家的分数是相同的。如果玩家的分数都不同，或者分布零散的话，哈希表 V 需要内存维护大量元素，会退化成桶排序。</li><li>FindRank需要在哈希表 V 中遍历所有比该分数大的桶。</li></ul><h3 id="frugal-streaming">Frugal Streaming</h3><h3 id="geohash--s2-geometry--地理位置">Geohash / S2 Geometry 地理位置</h3><h3 id="leaky-bucket--token-bucket--限流器">Leaky bucket / Token bucket 限流器</h3><p>Lossy Counting ，tok频繁 hashmap不停轮换请counter为0的</p><p><a href="https://github.com/Aaaaash/blog/issues/10">Operational transformation</a> 操作转换，类似于google doc多人编辑时</p><p>Quadtree / Rtree ☑️</p><ul><li>四叉树是一种数据结构，每一个节点有四个孩子。一般需要用到四叉树的情况往往是二位平面，通过把区域分成四个区块来定义。</li><li><p>应用：比如确定并显示一条曲线的具体位置时</p></li><li><p>Ray casting ☑️</p></li><li><p>Reverse index ✅</p></li><li><p>Rsync algorithm ✅</p></li><li>Trie algorithm ✅</li></ul><h2 id="常见题目">常见题目</h2><blockquote><p><a href="https://soulmachine.gitbooks.io/system-design/content/cn/tinyurl.html">系统设计参考1</a> Done</p><p><a href="https://wizardforcel.gitbooks.io/system-design-primer/content/solutions/system_design/pastebin/">系统设计参考2</a> 差不多，图片都失效了。</p></blockquote><h3 id="分布式id生成器">分布式ID生成器</h3><p>发号器产生的 ID 一般都是 64 位整数，这样对数据库比较友好，容量也能满足业务需求</p><p>核心需求</p><ul><li>全局唯一(unique)</li><li>按照时间粗略有序(sortable by time)</li><li>尽可能短</li></ul><p>雪花算法:</p><ul><li>4个字节表示的Unix timestamp,</li><li>3个字节表示的机器的ID</li><li>2个字节表示的进程ID</li><li>3个字节表示的计数器</li></ul><p>时间在前面可保证有序</p><p>使用mysql自增id, 比如8台机器，每个机器每次+8。</p><p>不用进程ID就可以保证单调递增，但依赖时间。 <strong>雪花算法几乎可以是非常完美了，但它有一个致命的缺点 —— 强依赖机器时间。</strong> 如果机器上的系统时间回拨，即时间较正常的时间慢，那么就可能会出现发号重复的情况。对于这种情况，我们可以在本地维护一个文件，写入上次的时间戳，随后与当前时间戳比较。如果当前时间戳小于上次时间戳，说明系统时间出了问题，应该及时处理。</p><ul><li>比如 让程序等待一段时间（如等待到 <code class="language-plaintext highlighter-rouge">last_timestamp</code> 对应的时间后），保证生成的 ID 是单调递增的。</li><li>维护一个逻辑时间（<code class="language-plaintext highlighter-rouge">logical_timestamp</code>），如果检测到时间回拨，则使用 <code class="language-plaintext highlighter-rouge">last_timestamp + 1</code> 作为时间戳，以避免回拨带来的影响。</li></ul><p>前面加namespace, appId这样区分，分业务。</p><p>其它实现: mysql自增主键， redis自增。</p><h3 id="短网址系统">短网址系统</h3><p>需求</p><ul><li>足够短</li></ul><p>网上链接大概45亿，长度7的字符串足够了，每个元素是大小写字母+数字</p><p>用分布式id生成器生成短链，用Nosql kv来存， 短网址-&gt; 长网址</p><p>使用302临时重定向</p><h3 id="信息流">信息流</h3><p><a href="https://mafulong.github.io/2020/12/28/Feed%E6%B5%81/">专门blog</a></p><h3 id="定时任务调度器">定时任务调度器</h3><p><a href="https://mafulong.github.io/2021/04/06/%E5%AE%9A%E6%97%B6%E5%99%A8/">参考个人blog</a></p><h3 id="api限速">API限速</h3><p><a href="https://mafulong.github.io/2021/04/12/%E9%99%90%E6%B5%81%E5%99%A8/">参考个人blog: 限流器</a></p><h3 id="设计线程安全的hashmap">设计线程安全的hashmap</h3><p>hashmap可以拉链法，也可以java8一样，不是拉链，而是个红黑树，解决了hash冲突后的问题。</p><p>可以像concurrentHashMap一样采用分段锁保护。</p><h3 id="实时输出最近一个小时内访问频率最高的10个ip">实时输出最近一个小时内访问频率最高的10个IP</h3><ol><li><p>3600s，3600个hashmap，存储每一秒的每个ip的访问次数。</p></li><li><p>同时还要新建一个固定大小为10的小根堆，用于存放当前出现次数最大的10个IP。堆顶是10个IP里频率最小的IP。</p></li><li><p>每次来一个请求，就把该秒对应的HashMap里对应的IP计数器增1，并查询该IP是否已经在堆中存在，</p></li></ol><ul><li>如果不存在，则把该IP在3600个HashMap的计数器加起来，与堆顶IP的出现次数进行比较，如果大于堆顶元素，则替换掉堆顶元素，如果小于，则什么也不做</li><li>如果已经存在，则把堆中该IP的计数器也增1，并调整堆</li></ul><ol><li><p>需要有一个后台常驻线程，每过一秒，把最旧的那个HashMap销毁，并为当前这一秒新建一个HashMap，这样维持一个一小时的窗口。</p></li><li><p>每次查询top 10的IP地址时，把堆里10个IP地址返回来即可。</p></li></ol><p>如果内部存不下，可以使用redis等，同时时间跨度长的话还可以桶塌缩，近似统计。</p><h3 id="设计一个负载均衡">设计一个负载均衡</h3><p>负载均衡策略需要将请求均匀分配到各个服务节点，避免出现请求集中在某一点上的情况。有时会考虑节点权重，会话粘连等需求</p><blockquote><p><a href="https://juejin.cn/post/6844903648460292109">参考</a></p></blockquote><p>服务端节点列表存储下来，定时探活。</p><ul><li><p>随机：数组存储列表，随机数字。</p></li><li><p>无权重轮询：移动cursor，数组</p></li><li><p>有权重轮询：移动cursor，数组。<strong>权重分别为1,2,3的3该节点A,B,C，会先请求A一次，再请求B两次，再请求C三次</strong></p></li><li><p>有权重的平滑权重轮询</p><ul><li><p>所谓平滑, 即在一定的时间内, 不仅服务器被选择的次数分布和权重一致，满足权重要求，且调度算法还能比较均匀的选择节点分配请求</p></li><li><p>totalWeight：保存所有节点的权重和，该值在后续流程中保持不变</p><p>nodeOriginWeight：保持每个节点的原始权重，在后续流程中也保持不变</p><p>nodeCurWeights：保存每个节点的当前权重，该数组在后续每次计算请求应该分配到哪个节点时都会发生变化，初始化为每个节点的权重</p><p>每次选择节点，都会执行以下3步</p><ul><li>选出当前权重中，值最大节点a</li><li>将a的当前权重值减去<strong>totalWeight</strong></li><li>将每个当前权重加上每个节点的原始权重</li></ul></li><li><p>原理：<strong>若某个节点增长越快，则越有概率被选中，而增长的速度和权重大小成正比，因此节点权重越大，越有概率被选中。相反或节点权重越小，增长成为最大当前权重节点的速度越慢，被选中的概率较低，从而达到按权重分配请求的效果</strong></p><p>当每个节点被选中后，减去的值都相等，由于减去了一个较大的值（所有节点原始权重总和），<strong>使得该节点在下几次请求中，被选中的概率较低，因为恢复成为最大值需要时间。从而达到平滑的效果</strong></p></li></ul></li><li><p>最小活跃数：按活跃数排序，可以是avl树、跳表等。每次请求+1</p></li><li><p>一致性hash：参考个人blog，如数组二分查找、红黑树等，虚拟节点，hash个数字。</p></li></ul><h3 id="配置中心">配置中心</h3><p>配置中心的核心作用是 <strong>存储和管理系统的配置信息</strong>，并 <strong>确保所有服务获取到的配置数据是正确的</strong>。如果配置数据不一致，可能会导致 <strong>系统故障、服务异常、甚至宕机</strong>，因此 <strong>一致性比可用性更重要</strong>。 如果选择 AP，可能在分区期间读取到旧数据，导致配置回滚或者错误行为。</p><p>配置信息存储之后，需要考虑如何将配置的变更推送给服务端，这样就可以实现配置的动态变更，也就是说不需要重启服务器就能让配置生效了。</p><p>一般会有两种思路来实现变更推送：一种是轮询查询的方式；一种是长连推送的方式。</p><p>比较是否变化，可以比较MD5值，来降低全部拉取的带宽压力。 由于配置中心里存储的配置项变化的几率不大，所以使用这种方式后，每次轮询请求就只是返回一个MD5值，可以大大地减少配置中心服务器的带宽。</p><p>另一种长连的方式，它的逻辑是在配置中心服务端保存每个连接关注的配置项列表。这样，当配置中心感知到配置变化后，就可以通过这个连接，把变更的配置推送给客户端。这种方式需要保持长连，也需要保存连接和配置的对应关系，实现上要比轮询的方式复杂一些，但是相比轮询方式来说，能够更加实时地获取配置变更的消息。</p><p>配置服务中存储的配置变更频率不高，所以对于实时性要求不高，但是期望实现上能够足够简单，所以如果选择自研配置中心的话，可以考虑使用轮询的方式。</p><p>可用性：</p><ul><li>配置存储是分级的，有公共配置，有个性的配置，一般个性配置会覆盖公共配置，这样可以减少存储配置项的数量；</li><li>配置中心可以提供配置变更通知的功能，可以实现配置的热更新；</li><li>配置中心关注的性能指标中，可用性的优先级是高于性能的，一般我们会要求配置中心的可用性达到99.999%，甚至会是99.9999%。</li><li>在配置中心的客户端上，增加两级缓存：第一级缓存是内存的缓存；另外一级缓存是文件的缓存。</li></ul><h3 id="设计key-value存储引擎">设计Key-Value存储引擎</h3><p><a href="https://mafulong.github.io/2021/01/11/leveldb%E5%92%8CRocksDB/">参考个人blog: leveldb设计及实现</a></p><h3 id="网络爬虫">网络爬虫</h3><p><a href="https://mafulong.github.io/2021/01/01/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">参考个人blog: 搜索引擎</a></p><h3 id="分布式pagerank">分布式PageRank</h3><p><a href="https://mafulong.github.io/2021/01/01/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">参考个人blog: 搜索引擎</a></p><h3 id="大数据">大数据</h3><p><a href="https://mafulong.github.io/2018/07/11/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/">参考个人blog算法系列大数据问题</a></p><h3 id="排行榜">排行榜</h3><p><a href="https://mafulong.github.io/2022/01/24/%E6%8E%92%E8%A1%8C%E6%A6%9C/">参考个人博客</a></p></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
