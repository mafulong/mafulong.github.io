<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>golang锁及并发安全结构 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2020/12/27/golang%E9%94%81%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%BB%93%E6%9E%84/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="golang锁及并发安全结构"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="前提知识"><meta name="og:description" content="前提知识"><meta property="og:url" content="https://mafulong.github.io/2020/12/27/golang%E9%94%81%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-12-27"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="golang锁及并发安全结构"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">golang锁及并发安全结构</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/12/27 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Go" title="Go">Go</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 7438 字，约 22 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="前提知识">前提知识</h2><h3 id="悲观锁和乐观锁">悲观锁和乐观锁</h3><p>悲观锁是一种悲观思想，它总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，不管读还是写，悲观锁在执行操作之前都先上锁。</p><p>对读对写都需要加锁导致性能低，适合写多读少。</p><p>乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案主要包含CAS和版本号机制。乐观锁适用于多读的场景，可以提高吞吐量。</p><p>CAS即Compare And Swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。CAS涉及三个关系：指向内存一块区域的指针V、旧值A和将要写入的新值B。CAS实现的乐观锁会带来ABA问题，同时整个乐观锁在遇到数据不一致的情况下会触发等待、重试机制，这对性能的影响较大。</p><p>版本号机制是通过一个版本号version来实现版本控制。</p><h3 id="自旋锁">自旋锁</h3><p>之前介绍的CAS就是自旋锁的一种。同一时刻只能有一个线程获取到锁，没有获取到锁的线程通常有两种处理方式：</p><ul><li>一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；</li><li>把自己阻塞起来，等待重新调度请求，这种是互斥锁。</li></ul><p>自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p><p>但是如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被OS调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。</p><p>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。</p><h3 id="信号量和锁">信号量和锁</h3><p>信号量和锁虽然看起来很相似，比如当信号量为1时就实现了互斥锁，但实际上他们表示的含义不同<a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7#fn-1">1</a>。锁是用来保护临界资源的，比如读写不可以同时进行等；信号量是为了保证进程（或线程或goroutine）调度的，比如三个进程共同计算c=a+b，首先计算a+b和赋值操作不能同时进行，其次还要保证a+b先执行，对c的赋值后执行，因此这个地方需要采用信号量的方式来进行。</p><p>更进一步的，锁可以由信号量实现，那么goroutine可以遵循规定的被阻塞和唤醒，也可以由自旋锁实现，那么goroutine一直占用CPU直到解锁。他们这两种方式的区别在于是否需要goroutine调度，但本质上锁的实现都是为了保证临界资源不会被错误的访问。</p><h2 id="syncmutex">Sync.Mutex</h2><blockquote><p><a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7">golang的Mutex实现</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">go设计与原理</a></p></blockquote><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">a</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}</span>
	<span class="n">a</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">a</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
</code></pre></div></div><p>Golang Mutex其实是不断改进的，截止到目前为至主要改进了4版：</p><ul><li>V1: 简单实现，按照FIFO的方式来加锁、解锁的，cpu切换效率低</li><li>V2: 新goroutine参与锁的竞争，取队头时，如果有新来的goroutine, 新来的有cpu资源，给它。</li><li>V3: 再多给新goroutine一些机会：有cpu资源的goroutine多自旋一会，如果自旋期间可以得到锁，给它。</li><li>V4: 解决老goroutine饥饿问题， 老的goroutine可能一直拿不到锁，等待超过阈值(1ms)进入饥饿模式，直接到fifo队头，并关闭其他自旋。与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</li></ul><p>每一次的改进都是为了提高系统的整体性能，这个升级是逐步的连贯的，所以需要从V1版本慢慢开始看Mutex的演化进程。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Mutex</span> <span class="kt">struct</span> <span class="o">{</span>
  <span class="kt">state</span> <span class="kt">int32</span>
  <span class="kt">sema</span> <span class="kt">int32</span>
<span class="o">}</span>

</code></pre></div></div><p>sema是信号量，这是真正的导致goroutine被阻塞和唤醒的原因。</p><p>基于atomic CAS来操作state</p><p>在默认情况下，互斥锁的所有状态位都是 0，<code class="language-plaintext highlighter-rouge">int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><p><code class="language-plaintext highlighter-rouge">mutexLocked</code> — 表示互斥锁的锁定状态；</p></li><li><p><code class="language-plaintext highlighter-rouge">mutexWoken</code> — 表示从正常模式被从唤醒；</p></li><li><p><code class="language-plaintext highlighter-rouge">mutexStarving</code> — 当前的互斥锁进入饥饿状态；</p></li><li><p><code class="language-plaintext highlighter-rouge">waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</p></li></ul><p>获取锁的过程：</p><ol><li>判断当前 Goroutine 能否进入自旋；</li><li>通过自旋等待互斥锁的释放；</li><li>计算互斥锁的最新状态；</li><li>更新互斥锁的状态并获取锁；</li></ol><p>Goroutine 进入自旋的条件非常苛刻：</p><ol><li>互斥锁只有在普通模式才能进入自旋；</li><li>runtime_canSpin需要返回 <code class="language-plaintext highlighter-rouge">true</code>：<ol><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ol></li></ol><p>一旦当前 Goroutine 能够进入自旋就会调用<a href="https://draveness.me/golang/tree/runtime.sync_runtime_doSpin"><code class="language-plaintext highlighter-rouge">runtime.sync_runtime_doSpin</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.procyield"><code class="language-plaintext highlighter-rouge">runtime.procyield</code></a> 并执行 30 次的 <code class="language-plaintext highlighter-rouge">PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间</p><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code class="language-plaintext highlighter-rouge">mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code class="language-plaintext highlighter-rouge">mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code class="language-plaintext highlighter-rouge">PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过 <a href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code class="language-plaintext highlighter-rouge">runtime.sync_runtime_SemacquireMutex</code></a> 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p><ul><li>当互斥锁已经被解锁时，调用 <a href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code class="language-plaintext highlighter-rouge">sync.Mutex.Unlock</code></a> 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code class="language-plaintext highlighter-rouge">mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 <a href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code class="language-plaintext highlighter-rouge">sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li></ul><h2 id="syncrwmutex">Sync.RWMutex</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">b</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span><span class="p">{}</span>
	<span class="n">b</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">b</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="n">b</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
	<span class="n">b</span><span class="o">.</span><span class="n">RUnlock</span><span class="p">()</span>
</code></pre></div></div><p><a href="https://draveness.me/golang/tree/sync.RWMutex"><code class="language-plaintext highlighter-rouge">sync.RWMutex</code></a> 中总共包含以下 5 个字段：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RWMutex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">w</span>           <span class="n">Mutex</span>
	<span class="n">writerSem</span>   <span class="kt">uint32</span>
	<span class="n">readerSem</span>   <span class="kt">uint32</span>
	<span class="n">readerCount</span> <span class="kt">int32</span>
	<span class="n">readerWait</span>  <span class="kt">int32</span>
<span class="p">}</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">w</code> — 复用互斥锁提供的能力；</li><li><code class="language-plaintext highlighter-rouge">writerSem</code> 和 <code class="language-plaintext highlighter-rouge">readerSem</code> — 分别用于写等待读和读等待写：</li><li><code class="language-plaintext highlighter-rouge">readerCount</code> 存储了当前正在执行的读操作数量；</li><li><code class="language-plaintext highlighter-rouge">readerWait</code> 表示当写操作被阻塞时等待的读操作个数；</li></ul><p><strong>mutex就是个写锁，当读多写少，最好还是RWMutex</strong></p><ul><li>写操作使用 <a href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.Lock</code></a> 和 <a href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.Unlock</code></a> 方法；</li><li>读操作使用 <a href="https://draveness.me/golang/tree/sync.RWMutex.RLock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.RLock</code></a> 和 <a href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.RUnlock</code></a> 方法；</li></ul><p><strong>写锁-Lock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// mutex获取， 其他goroutine只能自旋或者休眠</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> 
  <span class="c">// readercount 变成负数，阻塞后续读操作。让读写公平！！</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="n">rwmutexMaxReaders</span> 
  <span class="c">// 如果仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 runtime.sync_runtime_SemacquireMutex 进入休眠状态等待所有读锁所有者执行结束后释放 writerSem 信号量将当前协程唤醒；</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>写锁-Unlock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 恢复readCount,释放读锁</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="n">rwmutexMaxReaders</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="n">throw</span><span class="p">(</span><span class="s">"sync: Unlock of unlocked RWMutex"</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c">// 通过 for 循环释放所有因为获取读锁而陷入等待的 Goroutine：</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c">// 释放写锁</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>读锁-Rlock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RLock</span><span class="p">()</span> <span class="p">{</span>
  
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><ol><li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code class="language-plaintext highlighter-rouge">runtime.sync_runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li><li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法会成功返回；</li></ol><p><strong>读锁-Runlock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RUnlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">);</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">rw</span><span class="o">.</span><span class="n">rUnlockSlow</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>该方法会先减少正在读资源的 <code class="language-plaintext highlighter-rouge">readerCount</code> 整数，根据 <a href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code class="language-plaintext highlighter-rouge">sync/atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p><ul><li>如果返回值大于等于零 — 读锁直接解锁成功；</li><li>如果返回值小于零 — 有一个正在执行的写操作，在这时会调用<a href="https://draveness.me/golang/tree/sync.RWMutex.rUnlockSlow"><code class="language-plaintext highlighter-rouge">sync.RWMutex.rUnlockSlow</code></a> 方法；<ul><li><a href="https://draveness.me/golang/tree/sync.RWMutex.rUnlockSlow"><code class="language-plaintext highlighter-rouge">sync.RWMutex.rUnlockSlow</code></a> 会减少获取锁的写操作等待的读操作数 <code class="language-plaintext highlighter-rouge">readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code class="language-plaintext highlighter-rouge">writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</li></ul></li></ul><p><strong>小结：</strong></p><ul><li>尝试获取写锁时；<ul><li>每次 <a href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.RUnlock</code></a> 都会将 <code class="language-plaintext highlighter-rouge">readerCount</code> 其减一，当它归零时该 Goroutine 会获得写锁；</li><li>将 <code class="language-plaintext highlighter-rouge">readerCount</code> 减少 <code class="language-plaintext highlighter-rouge">rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li></ul></li><li>释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li></ul><h2 id="syncwaitgroup">Sync.WaitGroup</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"end"</span><span class="p">)</span>
</code></pre></div></div><ul><li><a href="https://draveness.me/golang/tree/sync.WaitGroup"><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code></a> 必须在 <a href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li><li><a href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Done</code></a> 只是对 <a href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；<ul><li>可以同时有多个 Goroutine 等待当前 <a href="https://draveness.me/golang/tree/sync.WaitGroup"><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li></ul></li></ul><p>源码：</p><p><code class="language-plaintext highlighter-rouge">WaitGroup</code> 在逻辑上包含：</p><ol><li>worker 计数器：main协程调用 <code class="language-plaintext highlighter-rouge">wg.Add(delta int)</code> 时增加 <code class="language-plaintext highlighter-rouge">delta</code>，调用 <code class="language-plaintext highlighter-rouge">wg.Done</code>时减一。</li><li>waiter 计数器：调用 <code class="language-plaintext highlighter-rouge">wg.Wait</code> 时，计数器加一; <strong>worker计数器降低到0时，重置waiter计数器</strong>。</li><li>信号量：用于阻塞 main协程。调用 <code class="language-plaintext highlighter-rouge">wg.Wait</code> 时，通过 <code class="language-plaintext highlighter-rouge">runtime_Semacquire</code> 获取信号量；降低 waiter 计数器时，通过 <code class="language-plaintext highlighter-rouge">runtime_Semrelease</code> 释放信号量。</li></ol><h2 id="syncmap">Sync.Map</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">a</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">Map</span><span class="p">{}</span>
	<span class="n">a</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="s">"key"</span><span class="p">,</span> <span class="s">"value"</span><span class="p">)</span>
	<span class="n">val</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s">"key"</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">ok</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">))</span>
</code></pre></div></div><p>sync.Map的原理很简单，使用了空间换时间策略，通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</p><p>通过引入两个map将读写分离到不同的map，其中read map提供并发读和已存元素原子写，而dirty map则负责读写。</p><p>这样read map就可以在不加锁的情况下进行并发读取,当read map中没有读取到值时,再加锁进行后续读取,并累加未命中数。</p><p>当未命中数大于等于dirty map长度,将dirty map上升为read map。 从结构体的定义可以发现，虽然引入了两个map，但是底层数据存储的是指针，指向的是同一份值。</p><p><strong>注意read map实际上是个atomic value，所以它可以并发读，然后读的entry又和ditry的entry共用。</strong></p><p><code class="language-plaintext highlighter-rouge">sync.Map</code> 的实现原理可概括为：</p><ul><li>通过 read 和 dirty 两个字段将读写分离，读的数据存在只读字段 read 上，将最新写入的数据则存在 dirty 字段上</li><li>读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty</li><li>读取 read 并不需要加锁，而读或写 dirty 都需要加锁<ul><li>另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上</li></ul></li><li>对于删除数据则直接通过标记来延迟删除</li></ul><p><code class="language-plaintext highlighter-rouge">Map</code> 的数据结构如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Map struct {
    // 加锁作用，保护 dirty 字段
    mu Mutex
    // 只读的数据，实际数据类型为 readOnly
    read atomic.Value
    // 最新写入的数据
    dirty map[interface{}]*entry
    // 计数器，每次需要读 dirty 则 +1
    misses int
}
复制代码
</code></pre></div></div><p>其中 readOnly 的数据结构为：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type readOnly struct {
    // 内建 map
    m  map[interface{}]*entry
    // 表示 dirty 里存在 read 里没有的 key，通过该字段决定是否加锁读 dirty
    amended bool
}
复制代码
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">entry</code> 数据结构则用于存储值的指针：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type entry struct {
    p unsafe.Pointer  // 等同于 *interface{}
}
</code></pre></div></div><p>Load函数</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    // 首先尝试从 read 中读取 readOnly 对象
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]

    // 如果不存在则尝试从 dirty 中获取
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        // 由于上面 read 获取没有加锁，为了安全再检查一次
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]

        // 确实不存在则从 dirty 获取
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            // 调用 miss 的逻辑
            m.missLocked()
        }
        m.mu.Unlock()
    }

    if !ok {
        return nil, false
    }
    // 从 entry.p 读取值
    return e.load()
}

</code></pre></div></div><h2 id="synconce">Sync.Once</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var (
    instance7 *singleton7
    once      sync.Once
)

type singleton7 struct{}

func GetInstance7() *singleton7 {
    once.Do(func() {
        instance7 = &amp;singleton7{}
    })
    return instance7
}
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">sync.Once</code>有点类似于<code class="language-plaintext highlighter-rouge">init()</code>函数，它们都执行且仅执行一次，区别在于<code class="language-plaintext highlighter-rouge">sync.Once</code>是在你需要的时候执行，而<code class="language-plaintext highlighter-rouge">init()</code>是在包第一次被加载的时候执行。那为什么<code class="language-plaintext highlighter-rouge">sync.Once</code>可以解决加锁的问题呢？这就跟<code class="language-plaintext highlighter-rouge">sync.Once</code>的内部实现有关了。</p><p>以下是<code class="language-plaintext highlighter-rouge">sync.Once</code>的源码，非常短，但是很有参考价值：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Once struct {
    done uint32
    m    Mutex
}

func (o *Once) Do(f func()) {
    if atomic.LoadUint32(&amp;o.done) == 0 {
        o.doSlow(f)
    }
}

func (o *Once) doSlow(f func()) {
    o.m.Lock()
    defer o.m.Unlock()
    if o.done == 0 {
        defer atomic.StoreUint32(&amp;o.done, 1)
        f()
    }
}
</code></pre></div></div><p>可以发现<code class="language-plaintext highlighter-rouge">Do()</code>函数中仅仅做了一次判断——如果传入的函数已经执行了（<code class="language-plaintext highlighter-rouge">done</code>的值为1），那么就不执行，直接返回；否则执行<code class="language-plaintext highlighter-rouge">doSlow()</code>方法。在<code class="language-plaintext highlighter-rouge">doSlow()</code>方法中进行了加锁并执行了传入的函数，在代码块运行结束后再把<code class="language-plaintext highlighter-rouge">done</code>修改为1，这样就实现了执行且仅执行一次的功能，并且只有第一次需要加锁，这样对于<code class="language-plaintext highlighter-rouge">GetInstance()</code>函数来说就不再需要判断<code class="language-plaintext highlighter-rouge">instance</code>是否为<code class="language-plaintext highlighter-rouge">nil</code>了，也不再需要手动进行加锁解锁操作了，可谓是非常棒的一种解决方案。</p><h2 id="reference">Reference</h2><ul><li><a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7">golang的Mutex实现</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">go设计与原理</a></li><li><a href="https://juejin.cn/post/6844904100287496206">源码解读 Golang 的 sync.Map 实现原理</a></li></ul></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
