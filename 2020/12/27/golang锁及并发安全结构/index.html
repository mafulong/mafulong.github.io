<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>golang锁及并发安全结构 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2020/12/27/golang%E9%94%81%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%BB%93%E6%9E%84/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="golang锁及并发安全结构"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="前提知识"><meta name="og:description" content="前提知识"><meta property="og:url" content="https://mafulong.github.io/2020/12/27/golang%E9%94%81%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-12-27"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="golang锁及并发安全结构"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">golang锁及并发安全结构</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/12/27 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Go" title="Go">Go</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 11809 字，约 34 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="前提知识">前提知识</h2><p>在 Go 中，标准库中有一些线程安全的数据类型或工具，它们设计时已经考虑到了并发场景的安全性，因此可以在多个 goroutine 间安全地使用。</p><hr /><h3 id="不是线程安全的数据类型"><strong>不是线程安全的数据类型</strong></h3><p>以下类型在并发环境下需要额外加锁保护，默认情况下不是线程安全的：</p><ol><li><strong>普通变量</strong>:<ul><li>如 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float64</code>, <code class="language-plaintext highlighter-rouge">string</code> 等基本类型。</li><li><strong>解决方式</strong>: 使用 <code class="language-plaintext highlighter-rouge">sync.Mutex</code> 或 <code class="language-plaintext highlighter-rouge">sync/atomic</code>。</li></ul></li><li><strong><code class="language-plaintext highlighter-rouge">map</code></strong>:<ul><li>Go 中的普通 <code class="language-plaintext highlighter-rouge">map</code> 在并发读写时会引发运行时错误。</li><li><strong>解决方式</strong>: 使用 <code class="language-plaintext highlighter-rouge">sync.Mutex</code> 或 <code class="language-plaintext highlighter-rouge">sync.Map</code>。</li></ul></li><li><strong>切片和数组</strong>:<ul><li>对切片的增删改查在并发环境中可能引发数据竞争。</li><li><strong>解决方式</strong>: 使用 <code class="language-plaintext highlighter-rouge">sync.Mutex</code> 或 <code class="language-plaintext highlighter-rouge">channel</code>。</li></ul></li><li><strong>结构体</strong>:<ul><li>自定义的结构体如果没有明确的同步逻辑，在并发访问时也可能出错。</li><li><strong>解决方式</strong>: 使用 <code class="language-plaintext highlighter-rouge">sync.Mutex</code> 或其他同步机制。</li></ul></li></ol><h3 id="为什么-int64-不是线程安全的"><strong>为什么 <code class="language-plaintext highlighter-rouge">int64</code> 不是线程安全的？</strong></h3><ol><li><strong>非原子性：</strong><ul><li>操作 <code class="language-plaintext highlighter-rouge">int64</code>（例如读或写）可能会被拆分为多条指令，例如从内存加载到寄存器，或者从寄存器写回内存。这些操作在执行期间可能被其他 goroutine 打断，导致数据不一致。</li></ul></li><li><strong>数据竞争：</strong><ul><li>如果一个 goroutine 正在写 <code class="language-plaintext highlighter-rouge">int64</code>，而另一个 goroutine 同时读取该值，读取到的数据可能是写操作未完成时的中间状态，导致不一致的结果。</li></ul></li></ol><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">counter</span> <span class="kt">int64</span>

	<span class="c">// 使用原子操作更新和读取</span>
	<span class="n">atomic</span><span class="o">.</span><span class="n">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// 原子增加</span>
	<span class="n">value</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">)</span> <span class="c">// 原子读取</span>
</code></pre></div></div><h3 id="悲观锁和乐观锁">悲观锁和乐观锁</h3><p>悲观锁是一种悲观思想，它总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，不管读还是写，悲观锁在执行操作之前都先上锁。</p><p>对读对写都需要加锁导致性能低，适合写多读少。</p><p>乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案主要包含CAS和版本号机制。乐观锁适用于多读的场景，可以提高吞吐量。</p><p>CAS即Compare And Swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。CAS涉及三个关系：指向内存一块区域的指针V、旧值A和将要写入的新值B。CAS实现的乐观锁会带来ABA问题，同时整个乐观锁在遇到数据不一致的情况下会触发等待、重试机制，这对性能的影响较大。</p><p>版本号机制是通过一个版本号version来实现版本控制。</p><h3 id="自旋锁">自旋锁</h3><p>之前介绍的CAS就是自旋锁的一种。同一时刻只能有一个线程获取到锁，没有获取到锁的线程通常有两种处理方式：</p><ul><li>一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；</li><li>把自己阻塞起来，等待重新调度请求，这种是互斥锁。</li></ul><p>自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p><p>但是如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被OS调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。</p><p>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。</p><h3 id="信号量和锁">信号量和锁</h3><p>信号量和锁虽然看起来很相似，比如当信号量为1时就实现了互斥锁，但实际上他们表示的含义不同<a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7#fn-1">1</a>。锁是用来保护临界资源的，比如读写不可以同时进行等；信号量是为了保证进程（或线程或goroutine）调度的，比如三个进程共同计算c=a+b，首先计算a+b和赋值操作不能同时进行，其次还要保证a+b先执行，对c的赋值后执行，因此这个地方需要采用信号量的方式来进行。</p><p>更进一步的，锁可以由信号量实现，那么goroutine可以遵循规定的被阻塞和唤醒，也可以由自旋锁实现，那么goroutine一直占用CPU直到解锁。他们这两种方式的区别在于是否需要goroutine调度，但本质上锁的实现都是为了保证临界资源不会被错误的访问。</p><h2 id="syncmutex">Sync.Mutex</h2><blockquote><p><a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7">golang的Mutex实现</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">go设计与原理</a></p></blockquote><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">a</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}</span>
	<span class="n">a</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">a</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
</code></pre></div></div><p>Golang Mutex其实是不断改进的，截止到目前为至主要改进了4版：</p><ul><li>V2: 新goroutine参与锁的竞争，取队头时，如果有新来的goroutine, 新来的有cpu资源，给它。</li><li>V3: 再多给新goroutine一些机会：有cpu资源的goroutine多自旋一会，如果自旋期间可以得到锁，给它。</li><li>V4: 解决老goroutine饥饿问题， 老的goroutine可能一直拿不到锁，等待超过阈值(1ms)进入饥饿模式，直接到fifo队头，并关闭其他自旋。与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</li></ul><p>每一次的改进都是为了提高系统的整体性能，这个升级是逐步的连贯的，所以需要从V1版本慢慢开始看Mutex的演化进程。</p><p>Mutex不是FIFO的，不是公平的，随机唤醒gorountine。这是为了效率保证，不用维护FIFO队列。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Mutex</span> <span class="kt">struct</span> <span class="o">{</span>
  <span class="kt">state</span> <span class="kt">int32</span>
  <span class="kt">sema</span> <span class="kt">int32</span>
<span class="o">}</span>

</code></pre></div></div><p>sema是信号量，这是真正的导致goroutine被阻塞和唤醒的原因。</p><p>基于atomic CAS来操作state</p><p>在默认情况下，互斥锁的所有状态位都是 0，<code class="language-plaintext highlighter-rouge">int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><p><code class="language-plaintext highlighter-rouge">mutexLocked</code> — 表示互斥锁的锁定状态；</p></li><li><p><code class="language-plaintext highlighter-rouge">mutexWoken</code> — 表示从正常模式被从唤醒；</p></li><li><p><code class="language-plaintext highlighter-rouge">mutexStarving</code> — 当前的互斥锁进入饥饿状态；</p></li><li><p><code class="language-plaintext highlighter-rouge">waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</p></li></ul><p>获取锁的过程：</p><ol><li>判断当前 Goroutine 能否进入自旋；</li><li>通过自旋等待互斥锁的释放；</li><li>计算互斥锁的最新状态；</li><li>更新互斥锁的状态并获取锁；</li></ol><p>Goroutine 进入自旋的条件非常苛刻：</p><ol><li>互斥锁只有在普通模式才能进入自旋；</li><li>runtime_canSpin需要返回 <code class="language-plaintext highlighter-rouge">true</code>：<ol><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ol></li></ol><p>一旦当前 Goroutine 能够进入自旋就会调用<a href="https://draveness.me/golang/tree/runtime.sync_runtime_doSpin"><code class="language-plaintext highlighter-rouge">runtime.sync_runtime_doSpin</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.procyield"><code class="language-plaintext highlighter-rouge">runtime.procyield</code></a> 并执行 30 次的 <code class="language-plaintext highlighter-rouge">PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间</p><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code class="language-plaintext highlighter-rouge">mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code class="language-plaintext highlighter-rouge">mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code class="language-plaintext highlighter-rouge">PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过 <a href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code class="language-plaintext highlighter-rouge">runtime.sync_runtime_SemacquireMutex</code></a> 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p><ul><li>当互斥锁已经被解锁时，调用 <a href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code class="language-plaintext highlighter-rouge">sync.Mutex.Unlock</code></a> 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code class="language-plaintext highlighter-rouge">mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 <a href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code class="language-plaintext highlighter-rouge">sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li></ul><h2 id="syncrwmutex">Sync.RWMutex</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">b</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span><span class="p">{}</span>
	<span class="n">b</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">b</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="n">b</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
	<span class="n">b</span><span class="o">.</span><span class="n">RUnlock</span><span class="p">()</span>
</code></pre></div></div><p><a href="https://draveness.me/golang/tree/sync.RWMutex"><code class="language-plaintext highlighter-rouge">sync.RWMutex</code></a> 中总共包含以下 5 个字段：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RWMutex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">w</span>           <span class="n">Mutex</span>  <span class="c">// 底层的互斥锁，用于控制写操作的排他性</span>
  <span class="n">writerSem</span>   <span class="kt">uint32</span> <span class="c">// 写锁的信号量，用于阻塞等待写锁的 Goroutine。 阻塞Lock(), RUnlock()时会唤醒。</span>
  <span class="n">readerSem</span>   <span class="kt">uint32</span> <span class="c">// 读锁的信号量，用于阻塞等待读锁的 Goroutine。 阻塞Rlock(), Unlock()时会唤醒。</span>
  <span class="n">readerCount</span> <span class="kt">int32</span>  <span class="c">// 活跃的读锁数量。RLock()时+1, RUnlock()时减一。Lock()变负数， Unlock()时还原。                                                                                                                                                 </span>
  <span class="n">readerWait</span>  <span class="kt">int32</span>  <span class="c">// 等待释放写信号量的的在读 Goroutine 数量。否则RUnlockk不知道何时release唤醒Lock(). 在Lock()时把readerCount暂存到readerWait 然后等待。每次RUnlock都会减一，减到0，唤醒Lock()</span>
<span class="p">}</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">w</code> — 复用互斥锁提供的能力；</li><li><code class="language-plaintext highlighter-rouge">writerSem</code> 和 <code class="language-plaintext highlighter-rouge">readerSem</code> — 分别用于写等待读和读等待写：</li><li><code class="language-plaintext highlighter-rouge">readerCount</code> 存储了当前正在执行的读操作数量；记录当前持有读锁的 Goroutine 数量</li><li><code class="language-plaintext highlighter-rouge">readerWait</code> 表示当写操作被阻塞时等待的读操作个数；记录正在等待写锁的 Goroutine 数量</li></ul><p><strong>mutex就是个写锁，当读多写少，最好还是RWMutex</strong></p><ul><li>写操作使用 <a href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.Lock</code></a> 和 <a href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.Unlock</code></a> 方法；</li><li>读操作使用 <a href="https://draveness.me/golang/tree/sync.RWMutex.RLock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.RLock</code></a> 和 <a href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.RUnlock</code></a> 方法；</li></ul><p><strong>写锁-Lock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// mutex获取， 其他goroutine只能自旋或者休眠</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> 
  <span class="c">// readercount 变成负数，阻塞后续读操作。让读写公平！！</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="n">rwmutexMaxReaders</span> 
  <span class="c">// 如果仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 runtime.sync_runtime_SemacquireMutex 进入休眠状态等待所有读锁所有者执行结束后释放 writerSem 信号量将当前协程唤醒；</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>写锁-Unlock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 恢复readCount,释放读锁</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="n">rwmutexMaxReaders</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="n">throw</span><span class="p">(</span><span class="s">"sync: Unlock of unlocked RWMutex"</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c">// 通过 for 循环释放所有因为获取读锁而陷入等待的 Goroutine：</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c">// 释放写锁</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><ul><li><p><strong>读写锁的竞争和优先级</strong></p><ul><li><p><strong>读优先</strong>：</p><ul><li>多个读 Goroutine 可以同时持有读锁。</li><li>如果已有读锁，写锁请求会被阻塞。</li></ul></li><li><p><strong>写优先</strong>：</p><ul><li>写锁优先于后续的读锁。</li><li>如果有写锁等待，则后续的读锁请求也会被阻塞，直到写锁释放。</li></ul></li></ul></li></ul><p><strong>读锁-Rlock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RLock</span><span class="p">()</span> <span class="p">{</span>
  
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><ol><li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code class="language-plaintext highlighter-rouge">runtime.sync_runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li><li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法会成功返回；</li></ol><p><strong>读锁-Runlock</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RUnlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">);</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// The last reader unblocks the writer.</span>
        <span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
      <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>该方法会先减少正在读资源的 <code class="language-plaintext highlighter-rouge">readerCount</code> 整数，根据 <a href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code class="language-plaintext highlighter-rouge">sync/atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p><ul><li>如果返回值大于等于零 — 读锁直接解锁成功；</li><li>如果返回值小于零 — 有一个正在执行的写操作，在这时会 减少获取锁的写操作等待的读操作数 <code class="language-plaintext highlighter-rouge">readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code class="language-plaintext highlighter-rouge">writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</li></ul><p><strong>小结：</strong></p><ul><li>尝试获取写锁时；<ul><li>每次 <a href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code class="language-plaintext highlighter-rouge">sync.RWMutex.RUnlock</code></a> 都会将 <code class="language-plaintext highlighter-rouge">readerCount</code> 其减一，当它归零时该 Goroutine 会获得写锁；</li><li>将 <code class="language-plaintext highlighter-rouge">readerCount</code> 减少 <code class="language-plaintext highlighter-rouge">rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li></ul></li><li>释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li></ul><h2 id="syncwaitgroup">Sync.WaitGroup</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"end"</span><span class="p">)</span>
</code></pre></div></div><ul><li><a href="https://draveness.me/golang/tree/sync.WaitGroup"><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code></a> 必须在 <a href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li><li><a href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Done</code></a> 只是对 <a href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code class="language-plaintext highlighter-rouge">sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；<ul><li>可以同时有多个 Goroutine 等待当前 <a href="https://draveness.me/golang/tree/sync.WaitGroup"><code class="language-plaintext highlighter-rouge">sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li></ul></li></ul><p>源码：</p><p><code class="language-plaintext highlighter-rouge">WaitGroup</code> 在逻辑上包含：</p><ol><li>worker 计数器：main协程调用 <code class="language-plaintext highlighter-rouge">wg.Add(delta int)</code> 时增加 <code class="language-plaintext highlighter-rouge">delta</code>，调用 <code class="language-plaintext highlighter-rouge">wg.Done</code>时减一。</li><li>waiter 计数器：调用 <code class="language-plaintext highlighter-rouge">wg.Wait</code> 时，计数器加一; <strong>worker计数器降低到0时，重置waiter计数器</strong>。</li><li>信号量：用于阻塞 main协程。调用 <code class="language-plaintext highlighter-rouge">wg.Wait</code> 时，通过 <code class="language-plaintext highlighter-rouge">runtime_Semacquire</code> 获取信号量；降低 waiter 计数器时，通过 <code class="language-plaintext highlighter-rouge">runtime_Semrelease</code> 释放信号量。</li></ol><h2 id="syncmap">Sync.Map</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">a</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">Map</span><span class="p">{}</span>
	<span class="n">a</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span><span class="s">"key"</span><span class="p">,</span> <span class="s">"value"</span><span class="p">)</span>
	<span class="n">val</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s">"key"</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">ok</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">))</span>
</code></pre></div></div><p>sync.Map的原理很简单，使用了空间换时间策略，通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</p><p>通过引入两个map将读写分离到不同的map，其中read map提供并发读和已存元素原子写，而dirty map则负责读写。</p><p>这样read map就可以在不加锁的情况下进行并发读取,当read map中没有读取到值时,再加锁进行后续读取,并累加未命中数。</p><p>当未命中数大于等于dirty map长度,将dirty map上升为read map。 从结构体的定义可以发现，虽然引入了两个map，但是底层数据存储的是指针，指向的是同一份值。</p><p><strong>注意read map实际上是个atomic value，所以它可以并发读，然后读的entry又和ditry的entry共用。</strong></p><p><code class="language-plaintext highlighter-rouge">sync.Map</code> 的实现原理可概括为：</p><ul><li>通过 read 和 dirty 两个字段将读写分离，读的数据存在只读字段 read 上，将最新写入的数据则存在 dirty 字段上</li><li>读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty</li><li>读取 read 并不需要加锁，而读或写 dirty 都需要加锁<ul><li>另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上</li></ul></li><li>对于删除数据则直接通过标记来延迟删除</li></ul><p><code class="language-plaintext highlighter-rouge">Map</code> 的数据结构如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Map struct {
    // 加锁作用，保护 dirty 字段
    mu Mutex
    // 只读的数据，实际数据类型为 readOnly
    read atomic.Value
    // 最新写入的数据
    dirty map[interface{}]*entry
    // 计数器，每次需要读 dirty 则 +1
    misses int
}
复制代码
</code></pre></div></div><p>其中 readOnly 的数据结构为：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type readOnly struct {
    // 内建 map
    m  map[interface{}]*entry
    // 表示 dirty 里存在 read 里没有的 key，通过该字段决定是否加锁读 dirty
    amended bool
}
复制代码
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">entry</code> 数据结构则用于存储值的指针：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type entry struct {
    p unsafe.Pointer  // 等同于 *interface{}
}
</code></pre></div></div><p>Load函数</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    // 首先尝试从 read 中读取 readOnly 对象
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]

    // 如果不存在则尝试从 dirty 中获取
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        // 由于上面 read 获取没有加锁，为了安全再检查一次
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]

        // 确实不存在则从 dirty 获取
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            // 调用 miss 的逻辑
            m.missLocked()
        }
        m.mu.Unlock()
    }

    if !ok {
        return nil, false
    }
    // 从 entry.p 读取值
    return e.load()
}

</code></pre></div></div><h2 id="synconce">Sync.Once</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var (
    instance7 *singleton7
    once      sync.Once
)

type singleton7 struct{}

func GetInstance7() *singleton7 {
    once.Do(func() {
        instance7 = &amp;singleton7{}
    })
    return instance7
}
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">sync.Once</code>有点类似于<code class="language-plaintext highlighter-rouge">init()</code>函数，它们都执行且仅执行一次，区别在于<code class="language-plaintext highlighter-rouge">sync.Once</code>是在你需要的时候执行，而<code class="language-plaintext highlighter-rouge">init()</code>是在包第一次被加载的时候执行。那为什么<code class="language-plaintext highlighter-rouge">sync.Once</code>可以解决加锁的问题呢？这就跟<code class="language-plaintext highlighter-rouge">sync.Once</code>的内部实现有关了。</p><p>以下是<code class="language-plaintext highlighter-rouge">sync.Once</code>的源码，非常短，但是很有参考价值：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Once struct {
    done uint32
    m    Mutex
}

func (o *Once) Do(f func()) {
    if atomic.LoadUint32(&amp;o.done) == 0 {
        o.doSlow(f)
    }
}

func (o *Once) doSlow(f func()) {
    o.m.Lock()
    defer o.m.Unlock()
    if o.done == 0 {
        defer atomic.StoreUint32(&amp;o.done, 1)
        f()
    }
}
</code></pre></div></div><p>可以发现<code class="language-plaintext highlighter-rouge">Do()</code>函数中仅仅做了一次判断——如果传入的函数已经执行了（<code class="language-plaintext highlighter-rouge">done</code>的值为1），那么就不执行，直接返回；否则执行<code class="language-plaintext highlighter-rouge">doSlow()</code>方法。在<code class="language-plaintext highlighter-rouge">doSlow()</code>方法中进行了加锁并执行了传入的函数，在代码块运行结束后再把<code class="language-plaintext highlighter-rouge">done</code>修改为1，这样就实现了执行且仅执行一次的功能，并且只有第一次需要加锁，这样对于<code class="language-plaintext highlighter-rouge">GetInstance()</code>函数来说就不再需要判断<code class="language-plaintext highlighter-rouge">instance</code>是否为<code class="language-plaintext highlighter-rouge">nil</code>了，也不再需要手动进行加锁解锁操作了，可谓是非常棒的一种解决方案。</p><h2 id="synccond">Sync.Cond</h2><p><strong><code class="language-plaintext highlighter-rouge">sync.Cond</code>：</strong> 条件变量本质上是对 <code class="language-plaintext highlighter-rouge">sync.Mutex</code> 和信号机制的封装。</p><p><strong>关联的锁：</strong> <code class="language-plaintext highlighter-rouge">sync.Cond</code> 需要绑定一个 <code class="language-plaintext highlighter-rouge">sync.Locker</code> 接口（例如 <code class="language-plaintext highlighter-rouge">sync.Mutex</code> 或 <code class="language-plaintext highlighter-rouge">sync.RWMutex</code>），以确保对共享资源的并发访问是安全的。</p><p><code class="language-plaintext highlighter-rouge">sync.Cond</code> 是 Go 中的条件变量，用于让一个或多个 goroutine 等待某个条件满足，然后通过通知唤醒等待的 goroutine。它适用于需要基于条件协调多个 goroutine 的场景。</p><p>每个 Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁。</p><ul><li><p>Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护。</p></li><li><p>调用 Wait 会自动释放锁 c.L，并挂起调用者所在的 goroutine，因此当前协程会阻塞在 Wait 方法调用的地方。如果其他协程调用了 Signal 或 Broadcast 唤醒了该协程，那么 Wait 方法在结束阻塞时，会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。</p></li></ul><p>对条件的检查，使用了 <code class="language-plaintext highlighter-rouge">for !condition()</code> 而非 <code class="language-plaintext highlighter-rouge">if</code>，是因为当前协程被唤醒时，条件不一定符合要求，需要再次 Wait 等待下次被唤醒。为了保险起见，使用 <code class="language-plaintext highlighter-rouge">for</code> 能够确保条件符合要求后，再执行后续的代码。</p><ul><li>Wait方法是释放锁，等有信号来时再加锁。需要反复检查条件。其它Signal和Broadcast都不用提前加锁。</li></ul><p>接下来我们实现一个简单的例子，三个协程调用 <code class="language-plaintext highlighter-rouge">Wait()</code> 等待，另一个协程调用 <code class="language-plaintext highlighter-rouge">Broadcast()</code> 唤醒所有等待的协程。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">var</span> <span class="n">done</span> <span class="o">=</span> <span class="no">false</span>

<span class="k">func</span> <span class="n">read</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">for</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">"starts reading"</span><span class="p">)</span>
	<span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">write</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">"starts writing"</span><span class="p">)</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
	<span class="n">c</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">"wakes all"</span><span class="p">)</span>
	<span class="n">c</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cond</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{})</span>

	<span class="k">go</span> <span class="n">read</span><span class="p">(</span><span class="s">"reader1"</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">read</span><span class="p">(</span><span class="s">"reader2"</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">read</span><span class="p">(</span><span class="s">"reader3"</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
	<span class="n">write</span><span class="p">(</span><span class="s">"writer"</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">done</code> 即互斥锁需要保护的条件变量。</li><li><code class="language-plaintext highlighter-rouge">read()</code> 调用 <code class="language-plaintext highlighter-rouge">Wait()</code> 等待通知，直到 done 为 true。</li><li><code class="language-plaintext highlighter-rouge">write()</code> 接收数据，接收完成后，将 done 置为 true，调用 <code class="language-plaintext highlighter-rouge">Broadcast()</code> 通知所有等待的协程。</li><li><code class="language-plaintext highlighter-rouge">write()</code> 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 <code class="language-plaintext highlighter-rouge">Wait()</code>，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕。</li></ul><h2 id="atomic">Atomic</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。</p><p><strong>为什么 <code class="language-plaintext highlighter-rouge">atomic</code> 能保证原子性？</strong></p><p><strong>硬件支持</strong></p><p><code class="language-plaintext highlighter-rouge">sync/atomic</code> 包中的方法（如 <code class="language-plaintext highlighter-rouge">LoadInt64</code>, <code class="language-plaintext highlighter-rouge">StoreInt64</code>, <code class="language-plaintext highlighter-rouge">AddInt64</code>, <code class="language-plaintext highlighter-rouge">CompareAndSwapInt64</code> 等）依赖于底层硬件的指令集。例如，x86 架构中的以下指令可以实现原子操作：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">LOCK</code> 前缀</strong>: 确保 CPU 在执行指令时锁定总线或缓存行，禁止其他核访问同一内存地址。</li><li><strong>CAS（Compare-And-Swap）</strong>: 比较和交换操作，是实现原子性的重要基础。</li><li><strong>XADD</strong>: 原子地获取并增加某个值。</li></ul><p>Go 的 <code class="language-plaintext highlighter-rouge">atomic</code> 包通过调用这些底层原子指令，避免了加锁的开销，同时保证了操作的原子性。</p><p><strong>内存屏障</strong></p><p>原子操作通常会在执行时使用<strong>内存屏障</strong>（Memory Barrier，也叫 Memory Fence）。内存屏障确保：</p><ol><li>CPU 不会乱序执行操作。</li><li>其他核心能正确看到内存的最新状态。</li></ol><p>例如：</p><ul><li>在一个 <code class="language-plaintext highlighter-rouge">atomic.StoreInt64</code> 操作中，写入会立即对其他线程可见，而不会被 CPU 的乱序优化推迟。</li></ul><h2 id="syncpool">Sync.Pool</h2><p>一句话总结：保存和复用临时对象，减少内存分配，降低 GC 压力。</p><p>sync.Pool 是可伸缩的，同时也是并发安全的，其大小仅受限于内存的大小。sync.Pool 用于存储那些被分配了但是没有被使用，而未来可能会使用的值。这样就可以不用再次经过内存分配，可直接复用已有对象，减轻 GC 的压力，从而提升系统的性能。</p><p>sync.Pool 的大小是可伸缩的，高负载时会动态扩容，存放在池中的对象如果不活跃了会被自动清理。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">bufferPool</span> <span class="o">=</span> <span class="n">sync</span><span class="o">.</span><span class="n">Pool</span><span class="p">{</span>
  <span class="c">// 对象池中没有对象时，将会调用 New 函数创建。</span>
	<span class="n">New</span><span class="o">:</span> <span class="k">func</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span> <span class="p">{</span> 
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">{}</span>
	<span class="p">},</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">data</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="m">10000</span><span class="p">)</span>

<span class="k">func</span> <span class="n">BenchmarkBufferWithPool</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">:=</span> <span class="n">bufferPool</span><span class="o">.</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
		<span class="n">buf</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="n">buf</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>
		<span class="n">bufferPool</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 下面是不用Sync.Pool的代码</span>
<span class="k">func</span> <span class="n">BenchmarkBuffer</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">buf</span> <span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span>
		<span class="n">buf</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div><h2 id="select-结构的执行过程与实现原理">select 结构的执行过程与实现原理</h2><p><code class="language-plaintext highlighter-rouge">select</code> 关键字是 <strong>Go 语言特有</strong> 的控制结构，它的实现原理比较复杂，需要 <strong>编译器</strong> 和 <strong>运行时</strong> 函数的通力合作。其执行过程包括 <strong>编译期间的优化</strong> 和 <strong>运行时的调度机制</strong>，以确保 <code class="language-plaintext highlighter-rouge">select</code> 语句的高效执行。</p><h4 id="编译期间的优化">编译期间的优化</h4><p>在编译期间，Go 语言会对 <code class="language-plaintext highlighter-rouge">select</code> 语句进行优化，根据 <code class="language-plaintext highlighter-rouge">case</code> 的不同选择不同的优化路径：</p><ol><li><strong>空的 <code class="language-plaintext highlighter-rouge">select</code> 语句</strong></li></ol><ul><li>会被转换成调用 <code class="language-plaintext highlighter-rouge">runtime.block</code>，直接挂起当前 Goroutine。</li></ul><ol><li><p><strong>仅包含一个 <code class="language-plaintext highlighter-rouge">case</code> 的 <code class="language-plaintext highlighter-rouge">select</code> 语句</strong></p><ul><li>编译器会将其转换成：<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="n">block</span> <span class="p">};</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - 先判断 `Channel` 是否为空，再执行 `case` 结构中的内容。
</code></pre></div></div></li></ul></li><li><p><strong>包含两个 <code class="language-plaintext highlighter-rouge">case</code>，其中一个是 <code class="language-plaintext highlighter-rouge">default</code> 的 <code class="language-plaintext highlighter-rouge">select</code> 语句</strong></p></li></ol><ul><li>会使用 <code class="language-plaintext highlighter-rouge">runtime.selectnbrecv</code> 和 <code class="language-plaintext highlighter-rouge">runtime.selectnbsend</code>，非阻塞地执行收发操作。</li></ul><ol><li><p><strong>默认情况下（多个 <code class="language-plaintext highlighter-rouge">case</code>，无 <code class="language-plaintext highlighter-rouge">default</code>）</strong></p><ul><li>通过 <code class="language-plaintext highlighter-rouge">runtime.selectgo</code> 获取执行 <code class="language-plaintext highlighter-rouge">case</code> 的索引，并通过多个 <code class="language-plaintext highlighter-rouge">if</code> 语句执行对应 <code class="language-plaintext highlighter-rouge">case</code> 代码。</li></ul></li></ol><hr /><h4 id="运行时执行-runtimeselectgo-的流程">运行时执行 <code class="language-plaintext highlighter-rouge">runtime.selectgo</code> 的流程</h4><p>在编译器优化后，Go 语言在运行时执行 <code class="language-plaintext highlighter-rouge">runtime.selectgo</code>，具体流程如下：</p><ol><li><strong>生成遍历顺序</strong><ul><li>随机生成 <code class="language-plaintext highlighter-rouge">pollOrder</code> 轮询顺序。</li><li>根据 <code class="language-plaintext highlighter-rouge">Channel</code> 地址生成 <code class="language-plaintext highlighter-rouge">lockOrder</code> 锁定顺序。</li></ul></li><li><strong>轮询 <code class="language-plaintext highlighter-rouge">case</code>，查找可立即执行的 Channel</strong><ul><li>遍历 <code class="language-plaintext highlighter-rouge">pollOrder</code>，检查是否有可以立刻处理的 <code class="language-plaintext highlighter-rouge">Channel</code>：<ul><li><strong>如果存在</strong>：直接获取 <code class="language-plaintext highlighter-rouge">case</code> 对应的索引并返回。</li><li><strong>如果不存在</strong>：<ul><li>创建 <code class="language-plaintext highlighter-rouge">runtime.sudog</code> 结构体，将当前 Goroutine 加入所有相关 <code class="language-plaintext highlighter-rouge">Channel</code> 的收发队列。</li><li>调用 <code class="language-plaintext highlighter-rouge">runtime.gopark</code> 挂起当前 Goroutine，等待调度器的唤醒。</li></ul></li></ul></li></ul></li><li><strong>Goroutine 被调度器唤醒后</strong><ul><li>按照 <code class="language-plaintext highlighter-rouge">lockOrder</code> 再次遍历所有 <code class="language-plaintext highlighter-rouge">case</code>，查找需要处理的 <code class="language-plaintext highlighter-rouge">runtime.sudog</code> 对应索引。</li></ul></li></ol><h2 id="reference">Reference</h2><ul><li><a href="https://nxw.name/2021/golang-mutexde-shi-xian-yuan-li-1ef30cc7">golang的Mutex实现</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">go设计与原理</a></li><li><a href="https://juejin.cn/post/6844904100287496206">源码解读 Golang 的 sync.Map 实现原理</a></li></ul></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
