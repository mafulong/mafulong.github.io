<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>树状数组 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2020/11/03/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="树状数组"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="树状数组"><meta name="og:description" content="树状数组"><meta property="og:url" content="https://mafulong.github.io/2020/11/03/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-11-03"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="树状数组"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">树状数组</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/11/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Algorithms" title="Algorithms">Algorithms</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4584 字，约 14 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="树状数组">树状数组</h2><p><a href="https://zhuanlan.zhihu.com/p/25185969">理解入门</a></p><p><a href="https://www.cnblogs.com/dilthey/p/9366491.html">进阶, 必看！</a></p><p>树状数组（Binary Indexed Tree）, 该算法多用于高效计算数列的前缀和， 区间和动态单点值的修改</p><p>这里引入一种数据结构 - 树状数组 ( Binary Indexed Tree，BIT，二分索引树 )，它只有两种基本操作，并且都是操作线性表的数据的：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1、add( i, 1 )      (1&lt;=i&lt;=n)                       对第i个元素的值自增1           O(logn)
  2、sum( i )         (1&lt;=i&lt;=n)                       统计[1...i]元素值的和             O(logn)
</code></pre></div></div><p>试想一下，如果用HASH来实现这两个函数，那么1的复杂度是O(1)，而2的复杂度就是O(n)了，而树状数组实现的这两个函数可以让两者的复杂度都达到O(logn)</p><p>有了这两种操作，我们需要将它们转化成之前设计的数据结构的那三种操作，首先：</p><ol><li>插入(Insert)，对应的是 add(i, 1)，时间复杂度O( logn )</li><li>删除(Delete), 对应的是 add(i, -1), 时间复杂度O( logn )</li><li>询问(Query), 求区间和或者a[i]的值</li></ol><p>记住i要大于1， 因为lowbit(0) = 0会死循环</p><p><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/569759172fd2522ac82c89da8de0a332.jpeg" alt="树状数组详细讲解，不会算法也能看懂哦~" /></p><h3 id="基本操作">基本操作</h3><h4 id="lowbit">lowbit</h4><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def lowbit(self, x):
    return x &amp; (-x)
</code></pre></div></div><p>因此i+lowbit(i)其实代表是它父级对应的index，比如c4由c3和c2累加而成，c2和c3的+lowbit(i)就是c4的位置。</p><p>i-lowbit(i)其实是没有父子祖先关系平级的最大节点，比如c4、c6、c7、a8是平级的。index=8的lowbit(8) = 8，就回到了0.</p><p>index=7的lowbit(7) = 1, 回到了c6.</p><h4 id="更新add">更新add</h4><p>更新a[i]和包含a[i]的一系列c[i]的值</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//x代表位置，data带表要加上的值
void add (int x,int data)
{
    for (int i=x;i&lt;=n;i+=lowbit(i))
            tree[i]+=data;
}
</code></pre></div></div><h4 id="统计sum">统计sum</h4><p>求1到index为x的和</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//求1到x的和
int sum (int x)
{
    int ans=0;
    for (int i=x;i&gt;=1;i-=lowbit(i))
            ans+=tree[i];
    return ans;
}
</code></pre></div></div><h4 id="树状数组创建">树状数组创建</h4><p>对每个a[i] 依次add即可， n*o(n)</p><p>实际上可以o(n)</p><p>每一个节点的值是由所有与自己直接相连的儿子的值求和得到的。因此可以倒着考虑贡献，即每次确定完儿子的值后，用自己的值更新自己的直接父亲。</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// O(n)建树</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="场景">场景</h3><p>有以下场景分类：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>① 单点修改、区间查询 树状数组

② 区间查询、单点修改 树状数组

③ 区间查询、区间修改 树状数组

④ 二维树状数组

　　单点修改、区间查询 二维树状数组

　　区间修改、单点查询 二维树状数组

　　区间修改、区间查询 二维树状数组
</code></pre></div></div><h4 id="单点修改区间查询">单点修改、区间查询</h4><p>原始问题</p><h4 id="区间修改单点查询">区间修改、单点查询</h4><p>a[i]存的是a[i]-a[i-1]</p><p>其实这个的原理就是：通过差分把这个区间修改、单点查询的问题转化为①；</p><p>首先，假设我们要记录的数组是𝑎[1:𝑛]a[1:n]，那么我们假设有𝑑[𝑖]=𝑎[𝑖]−𝑎[𝑖−1]d[i]=a[i]−a[i−1]，且𝑑[1]=𝑎[1]d[1]=a[1]，</p><p>显然，就有𝑎[𝑖]=𝑑[1]+𝑑[2]+⋯+𝑑[𝑖]a[i]=d[1]+d[2]+⋯+d[i]，</p><p>我们在BIT中实际存储的是数组𝑑[1:𝑛]d[1:n]（准确的说是d数组的树状数组）；</p><p>先说<strong>修改</strong>：</p><p>　　我们目标是给𝑎[𝐿:𝑅]a[L:R]全部加上𝑥x，那么我们不难发现，其实𝑑[𝐿+1],𝑑[𝐿+2],⋯,𝑑[𝑅]d[L+1],d[L+2],⋯,d[R]都没有变化，</p><p>　　而变化的只有：𝑑[𝐿]d[L]增加了𝑥x，𝑑[𝑅+1]d[R+1]减少了𝑥x；</p><p>　　所以只需要add(L,x),add(R+1,-x)即可。</p><p>再说<strong>查询</strong>：</p><p>　　我们要单点查询𝑎[𝑝𝑜𝑠]a[pos]，由上可知𝑎[𝑝𝑜𝑠]=𝑑[1]+𝑑[2]+⋯+𝑑[𝑝𝑜𝑠]a[pos]=d[1]+d[2]+⋯+d[pos]，</p><p>　　那么原来的sum(pos)函数不用修改，就正好能返回𝑎[𝑝𝑜𝑠]a[pos]的值。</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//BIT - 区间修改，单点查询 - st</span>
<span class="k">struct</span> <span class="n">_BIT</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span><span class="n">C</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);}</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//初始化共有n个点</span>
    <span class="p">{</span>
        <span class="n">N</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pos</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">)</span> <span class="n">C</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">+=</span><span class="n">val</span><span class="p">,</span><span class="n">pos</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">range_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="c1">//区间[l,r]加x</span>
    <span class="p">{</span>
        <span class="n">add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="c1">//查询pos点的值</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pos</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ret</span><span class="o">+=</span><span class="n">C</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
            <span class="n">pos</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span><span class="n">BIT</span><span class="p">;</span>
<span class="c1">//BIT - 区间修改，单点查询 - ed</span>
</code></pre></div></div><h4 id="区间查询区间修改">区间查询、区间修改</h4><p>我们看到，对于区间修改由于我们目标记录的是数组a[1:n]，而实际存储的是d[1:n]，d就是差分</p><p>那么已经实现了区间修改，如何完成区间查询呢？显然，区间查询的基础是快速求数组a[1:n]的前缀和，</p><p>显然数组a[1:n]的前缀和：</p><p>　　𝑎[1]+𝑎[2]+⋯+𝑎[𝑖]=𝑑[1]×𝑖+𝑑[2]×(𝑖−1)+⋯+𝑑[𝑖]×1a[1]+a[2]+⋯+a[i]=d[1]×i+d[2]×(i−1)+⋯+d[i]×1</p><p>不难发现右侧可以化成：</p><p>　　𝑑[1]×𝑖+𝑑[2]×(𝑖−1)+⋯+𝑑[𝑖]×1=[𝑑[1]×(𝑖+1)+𝑑[2]×(𝑖+1)+⋯+𝑑[𝑖]×(𝑖+1)]−[𝑑[1]×1+𝑑[2]×2+⋯+𝑑[𝑖]×𝑖]=(𝑖+1)×(𝑑[1]+𝑑[2]+⋯+𝑑[𝑖])−(𝑑[1]×1+𝑑[2]×2+⋯+𝑑[𝑖]×𝑖)d[1]×i+d[2]×(i−1)+⋯+d[i]×1=[d[1]×(i+1)+d[2]×(i+1)+⋯+d[i]×(i+1)]−[d[1]×1+d[2]×2+⋯+d[i]×i]=(i+1)×(d[1]+d[2]+⋯+d[i])−(d[1]×1+d[2]×2+⋯+d[i]×i)</p><p>这样一来，我们就可以想到，在原来的数组𝐶[𝑖]记录𝑑[𝑖]的基础上，</p><p>再搞一个数组𝐶2[𝑖]记录𝑑[𝑖]×𝑖即可。（当然，实际写代码的时候要明确，C数组和C2数组都是树状数组，不是原数组）</p><p>也就是说，使用c1=d[1:n], c2=d[1:n]*i</p><p>单点add时: c1[i]+=val, c2[i]+=val*i</p><p>区间range_add时, l,r,val: add(l,val), add(r+1,-val)</p><p>单点sum时: <code class="language-plaintext highlighter-rouge">for(int i=pos;i&gt;0;i-=lowbit(i)) ret+=(pos+1)*C[i]-C2[i];</code></p><p>区间sum,range_ask时:sum(r)-sum(l-1)</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//BIT - 区间修改，区间查询 - st</span>
<span class="k">struct</span> <span class="n">_BIT</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
    <span class="n">ll</span> <span class="n">C</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span><span class="n">C2</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span> <span class="c1">//分别记录d[i]和d[i]*i</span>
    <span class="kt">int</span> <span class="n">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);}</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//初始化共有n个点</span>
    <span class="p">{</span>
        <span class="n">N</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">C2</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="n">ll</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">pos</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">val</span><span class="p">,</span><span class="n">C2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">val</span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">range_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">ll</span> <span class="n">x</span><span class="p">)</span> <span class="c1">//区间[l,r]加上x</span>
    <span class="p">{</span>
        <span class="n">add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ll</span> <span class="n">ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ll</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">pos</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="n">ret</span><span class="o">+=</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">C2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ll</span> <span class="n">range_ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="c1">//查询区间[l,r]的和</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">ask</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">ask</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span><span class="n">BIT</span><span class="p">;</span>
<span class="c1">//BIT - 区间修改，区间查询 - ed</span>
</code></pre></div></div><h3 id="应用">应用</h3><h3 id="敌兵布阵问题">敌兵布阵问题：</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166">题目链接</a></p><p>有N个军事基地，基地编号从0 到N-1，每个基地有不同数量的士兵，士兵数量可能发生增减，如何尽快的求出从第k个基地到第m个基地的士兵总数？</p><h3 id="求逆序对数量">求逆序对数量</h3><p>给一个1~n的排列，求满足i&lt;j且a[i]&gt;a[j]的二元组对数，比如[4,2,1,5,3]这个序列，满足条件的二元组为{&lt;4,2&gt;, &lt;4,1&gt;, &lt;4,3&gt;, &lt;2,1&gt;, &lt;5,3&gt;}，故逆序数是5</p><p>树状数组求逆序数的原理</p><p>首先明确树状数组在此问题中维护信息是某个区间中数字出现的个数，将源数据按其原本顺序插入树状数组，第i个数字插入的方式为将树状数组的第a[i]位设为1，同时更新覆盖到它的父区间，Query(a[i])可求得[1, a[i]]的区间和，这恰好代表第i个数字前小于等于它的个数，等于的只可能是自身，故小于它的有Query(a[i])-1个，那么大于它的显然就有i-1-(Query(a[i])-1) = i-Query(a[i])个</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Update</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ans</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">Query</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

</code></pre></div></div><h3 id="更多题目">更多题目</h3><p><a href="https://blog.csdn.net/weixin_45677913/article/details/102481587?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.pc_relevant_is_cache&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.pc_relevant_is_cache">更多题目</a></p><h2 id="只处理简单的复杂的交给线段树">只处理简单的，复杂的交给线段树。</h2><p>只处理简单的，单点更新，区间查询的add,sum树。复杂的都交给线段树。</p><h3 id="python3模板">python3模板</h3><p>即只能单点add，然后区间求和。</p><p>模板</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 树状数组模板
</span><span class="k">class</span> <span class="nc">BIT</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># 将下标 i 上的数加一
</span>    <span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span>

    <span class="c1"># 返回闭区间 [1, i] 的元素和
</span>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">&amp;=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># 返回闭区间 [left, right] 的元素和
</span>    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

</code></pre></div></div><p>使用</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestBIT</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_query</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">lt</span><span class="p">.</span><span class="n">BIT</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">t</span><span class="p">.</span><span class="n">inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">t</span><span class="p">.</span><span class="n">inc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">t</span><span class="p">.</span><span class="n">inc</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
        <span class="n">t</span><span class="p">.</span><span class="n">inc</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">t</span><span class="p">.</span><span class="n">inc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>

</code></pre></div></div></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
