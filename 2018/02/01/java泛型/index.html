<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>java泛型 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2018/02/01/java%E6%B3%9B%E5%9E%8B/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="java泛型"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="泛型"><meta name="og:description" content="泛型"><meta property="og:url" content="https://mafulong.github.io/2018/02/01/java%E6%B3%9B%E5%9E%8B/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2018-02-01"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="java泛型"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">java泛型</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2018/02/01 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 10199 字，约 30 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="泛型">泛型</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>其实就是一种编译检查的工具，类似某些注解一样, 如Override。</p><p>为什么说编译检查，例子</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="no">E</span> <span class="nf">f</span><span class="o">(</span><span class="no">E</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;().</span><span class="na">f</span><span class="o">(</span><span class="mi">123</span><span class="o">));</span> <span class="c1">// compile error</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="泛型的使用">泛型的使用</h2><h3 id="泛型方法">泛型方法</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span> <span class="no">E</span> <span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span> <span class="no">E</span><span class="o">[]</span> <span class="n">inputArray</span> <span class="o">)</span>
   <span class="o">{</span>
      <span class="c1">// 输出数组元素</span>
         <span class="k">for</span> <span class="o">(</span> <span class="no">E</span> <span class="n">element</span> <span class="o">:</span> <span class="n">inputArray</span> <span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span> <span class="s">"%s "</span><span class="o">,</span> <span class="n">element</span> <span class="o">);</span>
         <span class="o">}</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div><h3 id="泛型类">泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="no">T</span> <span class="n">t</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerBox</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
    <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringBox</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="泛型接口">泛型接口</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Generator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</p><h2 id="泛型的好处">泛型的好处</h2><p>① 类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作 java.lang.ClassCastException 展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。</p><p>② 消除了代码中许多的强制类型转换，增强了代码的可读性。</p><p>③ 为较大的优化带来了可能。</p><h2 id="类型通配符">类型通配符</h2><h3 id="为什么需要类型通配符">为什么需要类型通配符</h3><p>协变性：</p><ul><li>Java 数组是协变的：Integer[] 是 Number[] 的子类。 数组协变存在运行时风险：可能导致 ArrayStoreException</li><li>泛型是不可协变的：<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt; </code> 不是<code class="language-plaintext highlighter-rouge"> List&lt;Number&gt;</code> 的子类。 泛型为了安全，默认是不可协变的，需要通过通配符支持（? extends T）</li></ul><p>集合无协变性：</p><ul><li><p>给<code class="language-plaintext highlighter-rouge">totalArea(Collection&lt;Shape&gt; arr)</code>传递一个 <code class="language-plaintext highlighter-rouge">Collection&lt;Circle&gt;</code>类型的集合，这是不可以的。编译器就会报如下的错误：</p><ul><li><code class="language-plaintext highlighter-rouge">The method totalArea(Collection&lt;Shape&gt;) in the type Demo is not applicable for the arguments (Collection&lt;Circle&gt;)</code></li></ul></li><li><p>也就是说，形参是<code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>，你无法传入<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>,<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>,<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>等，在编译期间就出现错误，它们是不同的类型。</p></li></ul><p>有了类型通配符后，就可以约束泛型的父类或者子类，然后就可以让带有类型通配符泛型的 List 有数组一样的协变性，比如</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//假如B继承A</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="no">B</span><span class="o">&gt;</span><span class="n">可以赋值给List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">A</span><span class="o">&gt;</span>
<span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">B</span><span class="o">&gt;</span><span class="n">也可以赋值给List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">A</span><span class="o">&gt;</span>
</code></pre></div></div><p><strong>注意如下是不可以的</strong>。以最终的泛型支持为主</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The type List&lt;?extends A&gt;is assignable to List&lt;A&gt;.
</code></pre></div></div><h3 id="类型通配符-1">类型通配符</h3><p>类型通配符一般是使用?代替具体的类型参数。</p><p><strong><code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>的区别</strong></p><p>前者表示该通配符所代表的类型是 T 类型的子类。</p><p>后者表示该通配符所代表的类型是 T 类型的父类。</p><p>&lt;?&gt; 是无界通配符。</p><p>注意不能能对<code class="language-plaintext highlighter-rouge">List&lt;? extends Fruit&gt;</code>的List进行Add. 会报错。 对于这个问题我们不妨从编译器的角度去考虑。<code class="language-plaintext highlighter-rouge">List&lt;? extends Fruit&gt;</code> 可能有多种含义，比如是<code class="language-plaintext highlighter-rouge">ArrayList&lt;Apple&gt;</code> 编译器无法识别所以会报错。 所以对于实现了<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>的集合类只能将它视为<code class="language-plaintext highlighter-rouge">Producer</code>向外提供（<code class="language-plaintext highlighter-rouge">get</code>）元素，而不能作为<code class="language-plaintext highlighter-rouge">Consumer</code>来对外获取（<code class="language-plaintext highlighter-rouge">add</code>）元素。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Fruit</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Apple</span> <span class="kd">extends</span> <span class="nc">Fruit</span> <span class="o">{</span>
<span class="o">}</span>
<span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Fruit</span><span class="o">&gt;</span> <span class="n">flist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;();</span>
<span class="n">flist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Fruit</span><span class="o">());</span> <span class="c1">// compile error: capture of ? extends Fruit</span>
</code></pre></div></div><h4 id="pecs-原则">PECS 原则</h4><p>规律</p><ul><li><p>“Producer Extends” – 如果你需要一个只读 List，用它来 produce T，那么使用? extends 。 如果写会编译错误</p></li><li>“Consumer Super” – 如果你需要一个只写 List，用它来 consume T，那么使用? super 。只允许写T，可读。</li><li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li></ul><p>如果阅读过一些 Java 集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>记法： 子类赋值给父类。</p><p>泛型限定符有一描述：上界不存下界不取。</p><p>上界不存的原因：例如 List，编译器只知道容器内是 Father 及其子类，具体是什么类型并不知道，编译器在看到 extends 后面的 Father 类，只是标上一个 <code class="language-plaintext highlighter-rouge">CAP#1</code> 作为占位符，无论往里面插什么，编译器都不知道能不能和 <code class="language-plaintext highlighter-rouge">CAP#1</code> 匹配，所以就不允许插入。</p><p>extends的作用：可以在初始化的时候存入一个值，并且能保证数据的稳定性，只能取不能存。读取出来的数据可以存在父类或者基类里。</p><p>下界不取的原因：下界限定了元素的最小粒度，实际上是放松了容器元素的类型控制。例如 List， 元素是 Father 的基类，可以存入 Father 及其子类。但编译器并不知道哪个是 Father 的超类，如 Human。读取的时候，自然不知道是什么类型，只能返回 Object，这样元素信息就全部丢失了。</p><h3 id="list">List&lt;?&gt;</h3><blockquote><p><a href="https://stackoverflow.com/questions/1844770/what-does-list-mean-in-java-generics">参考</a></p></blockquote><p>The <code class="language-plaintext highlighter-rouge">?</code>, or unbounded wildcard, means that the type of the object is not specified. It could be unknown, could be meant for multiple possible values or might be just plain irrelevant. <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>, is pronounced “List of unknown.”</p><p>Unbounded Wildcards ?</p><blockquote><p>The unbounded wildcard type is specified using the wildcard character (<code class="language-plaintext highlighter-rouge">?</code>), for example, <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>. This is called a list of unknown type. There are two scenarios where an unbounded wildcard is a useful approach:</p><ul><li>If you are writing a method that can be implemented using functionality provided in the Object class.</li><li>When the code is using methods in the generic class that don’t depend on the type parameter. For example, <code class="language-plaintext highlighter-rouge">List.size</code> or <code class="language-plaintext highlighter-rouge">List.clear</code>. In fact, <code class="language-plaintext highlighter-rouge">Class&lt;?&gt;</code> is so often used because most of the methods in <code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code> do not depend on <code class="language-plaintext highlighter-rouge">T</code>.</li></ul></blockquote><p>? 表示一种特定的未知类型，所以 List&lt;?&gt; 不能 add 因为会类型绑定错误而出现错误 capture xx of ?之类的。</p><ul><li><code class="language-plaintext highlighter-rouge">List</code>: There is no type restriction and assignment restriction at all.</li><li><code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>: It seems to be used the same as <code class="language-plaintext highlighter-rouge">List</code>, but a compilation error will occur when accepting other generic assignments. 不能<code class="language-plaintext highlighter-rouge">List&lt;Object&gt; list = a, where a is List&lt;Integer&gt;</code></li><li><code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>: It is a generic type. Before assignment, it means that it can accept any type of set assignment, but after assignment, you can’t <code class="language-plaintext highlighter-rouge">add</code> elements to it, but you can <code class="language-plaintext highlighter-rouge">remove</code> and <code class="language-plaintext highlighter-rouge">clear</code>, not an <code class="language-plaintext highlighter-rouge">immutable set</code>. <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code> is generally used as a parameter to receive an external collection, or return a collection of specific element types, also known as a <code class="language-plaintext highlighter-rouge">wildcard collection</code>.</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">The</span> <span class="n">type</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">A</span><span class="o">&gt;</span><span class="n">is</span> <span class="n">assignable</span> <span class="n">to</span> <span class="nc">List</span><span class="o">.</span>
<span class="nc">The</span> <span class="n">type</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span><span class="n">is</span> <span class="n">assignable</span> <span class="n">to</span> <span class="nc">List</span><span class="o">&lt;?&gt;.</span>
</code></pre></div></div><p>注意，<strong>优先使用带?的泛型</strong>，这样做的好处是告诉编译器，我们是确实是采用任意类型的泛型，而非忘记使用泛型约束，并且<strong>在编译器检查时不会产生警告信息。</strong></p><h2 id="类型擦除">类型擦除</h2><p>Java 的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息。到了运行时，是看不到泛型的。Java的设计者在JDK 1.5时才引入了泛型，但为了照顾以前设计上的缺陷，同时兼容非泛型的代码，不得不做出了一个折中的策略：编译时对泛型要求严格，运行时却把泛型擦除了——要兼容以前的版本，还要升级扩展新的功能，真的很不容易！</p><p>泛型擦除到底是什么意思呢？我们先来看一下下面这个简单的例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Object</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>这意味着不管我们声明<code class="language-plaintext highlighter-rouge">Node&lt;String&gt;</code>还是<code class="language-plaintext highlighter-rouge">Node&lt;Integer&gt;</code>，到了运行期间，<code class="language-plaintext highlighter-rouge">JVM</code>统统视为<code class="language-plaintext highlighter-rouge">Node&lt;Object&gt;</code>。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置<code class="language-plaintext highlighter-rouge">bounds</code>了，将上面的代码修改成下面这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>这样编译器就会将<code class="language-plaintext highlighter-rouge">T</code>出现的地方替换成<code class="language-plaintext highlighter-rouge">Comparable</code>而不再是默认的<code class="language-plaintext highlighter-rouge">Object</code>了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Comparable</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Comparable</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Comparable</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>因此可能会带来一些问题，比如如下代码运行到最后一行时会产生异常 ClassCastException</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="n">intList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">intList</span><span class="o">;</span>

        <span class="c1">//just warnning: Type safety: Unchecked cast from Object to ArrayList&lt;String&gt;</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="n">obj</span><span class="o">;</span>

        <span class="c1">// 这里会ClassCastException，因为类型擦除</span>
        <span class="c1">//Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</code></pre></div></div><p>类型参数后</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">public</span> <span class="n">static</span> <span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">void</span> <span class="nf">doX</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nv">System</span><span class="o">.</span><span class="py">out</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">args</span> <span class="n">instanceof</span> <span class="nc">List</span><span class="o">&lt;?&gt;);</span> <span class="c1">// true</span>
        <span class="nv">System</span><span class="o">.</span><span class="py">out</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">args</span> <span class="n">instanceof</span> <span class="nc">List</span><span class="o">);</span> <span class="c1">// true</span>
    <span class="o">}</span>

        <span class="nv">System</span><span class="o">.</span><span class="py">out</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;().</span><span class="py">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;().</span><span class="py">getClass</span><span class="o">()));</span> <span class="c1">// true</span>
</code></pre></div></div><h2 id="泛型的约束和限制">泛型的约束和限制</h2><h3 id="类型检查不可使用泛型">类型检查不可使用泛型</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">aaa</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;){}</span><span class="c1">//compile error: Illegal generic type for instanceof</span>

<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="n">a</span><span class="o">;</span><span class="c1">//warn</span>

<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">i</span><span class="o">;</span>
<span class="n">i</span><span class="o">.</span><span class="na">getClass</span><span class="o">()==</span><span class="n">p</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span><span class="c1">//true</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">rtti</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="k">instanceof</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;)</span> <span class="o">{</span>  <span class="c1">// compile-time error</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>可以这样使用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rtti</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
<span class="err">    </span><span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="k">instanceof</span> <span class="nc">ArrayList</span><span class="o">&lt;?&gt;)</span> <span class="o">{</span><span class="err"> </span> <span class="c1">// OK; instanceof requires a reifiable type</span>
<span class="err">        </span><span class="c1">// ...</span>
<span class="err">    </span><span class="o">}</span>
<span class="o">}</span>



</code></pre></div></div><h3 id="不能创建泛型对象数组">不能创建泛型对象数组</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GenericMethod</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;[]</span> <span class="n">o</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span><span class="c1">//ok</span>
<span class="n">o</span><span class="o">=</span><span class="k">new</span> <span class="nc">GenericMethod</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;[</span><span class="mi">10</span><span class="o">];</span><span class="c1">//error</span>
</code></pre></div></div><p>可以定义泛型类对象的数组变量，不能创建及初始化。</p><p>注，可以创建通配类型数组，然后进行强制类型转换。不过这是类型不安全的。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">o</span><span class="o">=(</span><span class="nc">GenericMethod</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">GenericMethod</span><span class="o">&lt;?&gt;[</span><span class="mi">10</span><span class="o">];</span>
</code></pre></div></div><p>不可以创建的原因是：因为类型擦除的原因无法在为元素赋值时类型检查，因此 jdk 强制不允许。java对数组是有类型检查的，不论是写还是读。</p><h3 id="不能实例化泛型对象">不能实例化泛型对象</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">T</span> <span class="n">t</span><span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span><span class="c1">//error</span>
<span class="no">T</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span><span class="c1">//error</span>
<span class="no">T</span><span class="o">.</span><span class="na">class</span><span class="o">;</span><span class="c1">//error</span>
</code></pre></div></div><p>但可以这样创建</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">append</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="no">E</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>   <span class="c1">// OK</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">append</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

</code></pre></div></div><h3 id="不能在泛型类的静态域中使用类泛型类型">不能在泛型类的静态域中使用类泛型类型</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="no">T</span> <span class="n">singleton</span><span class="o">;</span> <span class="c1">//error</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="no">T</span> <span class="nf">getInstance</span><span class="o">(){}</span> <span class="c1">//error</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">){}</span> <span class="c1">//error</span>
<span class="o">}</span>
</code></pre></div></div><p>但是，静态的泛型方法可以使用泛型类型:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">getInstance</span><span class="o">(){</span><span class="k">return</span> <span class="kc">null</span><span class="o">;}</span> <span class="c1">//ok</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">){}</span> <span class="c1">//ok</span>
</code></pre></div></div><p>这个原因很多资料中都没说的太明白，说一下个人理解，仅供参考：</p><ol><li>泛型类中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>称为类型变量,实际上就相当于在类中隐形的定义了一个不可见的成员变量：<code class="language-plaintext highlighter-rouge">private T t;</code>，这是对象级别的，对于泛型类型变量来说是在对象初始化时才知道其具体类型的。而在静态域中，不需要对象初始化就可以调用，这是矛盾的。</li><li>静态的泛型方法，是在方法层面定义的，就是说在调用方法时，T 所指的具体类型已经明确了。</li></ol><h3 id="继承泛型类时自动重写override">继承泛型类时自动重写override</h3><p>对于泛型代码，Java 编译器实际上还会偷偷帮我们实现一个 Bridge method。</p><p>在继承一个泛型类时，会自动加对泛型类的方法的调用时的类型强制转换。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Node.setData"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">MyNode</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="kd">super</span><span class="o">(</span><span class="n">data</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyNode.setData"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>类型擦除后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="nc">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Node.setData"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">// Bridge method generated by the compiler</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="nc">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span><span class="err">、</span>
        <span class="c1">// 这个是关键！！！！，有个强制类型转化。</span>
        <span class="n">setData</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyNode.setData"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="泛型实现原理">泛型实现原理</h2><h3 id="java泛型">java泛型</h3><p>基本问题：</p><ul><li><p>定义一个泛型类最后到底会生成几个类，比如<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>到底有几个类</p><ul><li>只会生成<strong>一个</strong> <code class="language-plaintext highlighter-rouge">ArrayList.class</code>，不会为每个不同的 <code class="language-plaintext highlighter-rouge">T</code> 生成单独的类。泛型参数 <code class="language-plaintext highlighter-rouge">T</code> 会在编译后被擦除，替换为它的<strong>擦除类型</strong>（通常是 <code class="language-plaintext highlighter-rouge">Object</code>，或者是泛型上界）。</li></ul></li><li><p>定义一个泛型方法最终会有几个方法在class文件中</p><ul><li>编译后，字节码中仍然<strong>只有一个方法</strong> <code class="language-plaintext highlighter-rouge">print(Object)</code>，因为 <code class="language-plaintext highlighter-rouge">T</code> 会被擦除为 <code class="language-plaintext highlighter-rouge">Object</code>。</li></ul></li><li><p>为什么泛型参数不能是基本类型呢</p><ul><li>泛型参数会被替换为 <code class="language-plaintext highlighter-rouge">Object</code>，而基本类型（<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">double</code>）不是 <code class="language-plaintext highlighter-rouge">Object</code>，无法直接替换</li></ul></li><li><p>```sh</p><ul><li><p>ArrayList<Integer>是一个类吗</Integer></p><ul><li><p><strong>不是</strong>。<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code> 只是 <code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code> 的一个<strong>实例化</strong>（泛型的应用）。</p><p>由于<strong>类型擦除</strong>，<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code> 和 <code class="language-plaintext highlighter-rouge">ArrayList&lt;String&gt;</code> 在运行时是<strong>同一个类</strong>，都是 <code class="language-plaintext highlighter-rouge">ArrayList.class</code>。</p></li></ul></li><li><p>` ArrayList<Integer>和List<Integer>和ArrayList<Number>和List<Number>`是什么关系呢，这几个类型的引用能相互赋值吗</Number></Number></Integer></Integer></p><ul><li><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code> <strong>可以</strong> 赋值给 <code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>，因为 <code class="language-plaintext highlighter-rouge">ArrayList</code> 是 <code class="language-plaintext highlighter-rouge">List</code> 的子类。</li><li><code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code> <strong>不能</strong> 赋值给 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>，因为 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code> 不是 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code> 的子类，泛型不支持协变。</li><li><code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code> <strong>不能</strong> 赋值给 <code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>，泛型是<strong>不变的（Invariant）</strong>。</li></ul></li></ul><p>```</p></li></ul><p>泛型本质是将数据类型参数化，它通过擦除的方式来实现。声明了泛型的 .java 源代码，在编译生成 .class 文件之后，泛型相关的信息就消失了。可以认为，源代码中泛型相关的信息，就是提供给编译器用的。泛型信息对 Java 编译器可以见，对 Java 虚拟机不可见。</p><p>Java 编译器通过如下方式实现擦除：</p><ul><li>用 Object 或者界定类型替代泛型，产生的字节码中只包含了原始的类，接口和方法；</li><li>在恰当的位置插入强制转换代码来确保类型安全；</li><li>在继承了泛型类或接口的类中插入桥接方法来保留多态性。</li></ul><p>java 编译后不同类型的模板类编译出的是同一份代码。然后在使用时编译器会帮助进行类型转换.</p><p>所以 java 泛型的实现是在运行时去进行判断和类型转换的，这样会对运行时的效率有一定影响，但编译出来的泛型类的代码只需要一份.</p><p>Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀（C++模板令人困扰的难题）的问题，但是也引起了许多新的问题。所以，Sun对这些问题作出了许多限制，避免我们犯各种错误。</p><p><strong>首先第一个是泛型所宣称的类型安全，既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，在进行编译的。</strong></p><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p><ul><li>编译器生成的class文件中会在你调用泛型方法完成之后返回调用点之前加上类型转换的操作，比如上文的get函数，就是在get方法完成后，jump回原本的赋值操作的指令位置之前加入了强制转换，转换的类型由编译器推导。</li></ul><h3 id="c泛型">C++泛型</h3><p>c++ 的泛型实现机制很简单，就是在实际编译时，类似于宏一样，把实际的类型代入模板，并针对不同的类型生成不同的代码，所以编译后代码体积会变大，但执行时就不需要额外的判断了，运行时效率会较高. 所以 c++ 的泛型可以说是以空间换时间.</p><p>例如 std::list 容器，如果你将 int 类型的数据存进去，C++ 编译器就为你生成一个专门用来存 int 类型数据的列表数据结构。也就是说，你向 std::list 容器中存放什么类型，C++ 编译器就为你生成相应的列表数据结构。理论上，数据的类型是无限的，因此 C++ 要生成的列表数据结构也是无限的。如果你的程序中有大量的数据类型要存到 std::list 容器，那么代码就会高度膨胀，这种膨胀是 C++ 编译器在目标文件连接阶段无法优化的。</p><h2 id="参考">参考</h2><ul><li><a href="https://github.com/SigalHu/MyBlog/blob/master/Java/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3%5B%E8%BD%AC%5D.md">参考1</a></li></ul></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
