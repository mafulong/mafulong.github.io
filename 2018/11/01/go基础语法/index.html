<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="wVZecs0Awis41AZhX45RBAUlyk3nnpoOkebdIemwhxQ" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>go基础语法 &mdash; Fulongのblog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mafulong.github.io/2018/11/01/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><link rel="alternate" type="application/atom+xml" title="Fulongのblog" href="https://mafulong.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/favicon.ico"><meta property="og:title" content="go基础语法"><meta name="keywords" content="logbook, mafulong"><meta name="og:keywords" content="logbook, mafulong"><meta name="description" content="```gopackage main"><meta name="og:description" content="```gopackage main"><meta property="og:url" content="https://mafulong.github.io/2018/11/01/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><meta property="og:site_name" content="Fulongのblog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2018-11-01"> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://mafulong.github.io/" title="Fulongのblog"><span class="octicon octicon-mark-github"></span> Fulongのblog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://mafulong.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://mafulong.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://mafulong.github.io/archives/" class=" site-header-nav-item" target="" title="Achieves">Achieves</a> <a href="https://mafulong.github.io/open-source" class=" site-header-nav-item" target="" title="Open-Source">Open-Source</a> <a href="https://mafulong.github.io/bookmark" class=" site-header-nav-item" target="" title="Bookmark">Bookmark</a> <a href="https://mafulong.github.io/about" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="go基础语法"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">go基础语法</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2018/11/01 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mafulong.github.io/categories/#Go" title="Go">Go</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 16502 字，约 48 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>
</code></pre></div></div><h2 id="go基本知识">go基本知识</h2><p><strong>GoRoot</strong> 是 Go 的安装路径。mac 或 unix 是在 <code class="language-plaintext highlighter-rouge">/usr/local/go</code> 路径上</p><p><strong>GoPath</strong> 的作用在于提供一个可以寻找 <code class="language-plaintext highlighter-rouge">.go</code> 源码的路径，它是一个工作空间的概念，可以设置多个目录。Go 官方要求，GoPath 下面需要包含三个文件夹：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>srcpkgbin
</code></pre></div></div><p>src 存放源文件，pkg 存放源文件编译后的库文件，后缀为 <code class="language-plaintext highlighter-rouge">.a</code>；bin 则存放可执行文件。</p><h3 id="基本命令">基本命令</h3><p><code class="language-plaintext highlighter-rouge">go build</code> 用来编译指定 packages 里的源码文件以及它们的依赖包，编译的时候会到 <code class="language-plaintext highlighter-rouge">$GoPath/src/package</code> 路径下寻找源码文件。<code class="language-plaintext highlighter-rouge">go build</code> 还可以直接编译指定的源码文件，并且可以同时指定多个。</p><p><code class="language-plaintext highlighter-rouge">go install</code> 用于编译并安装指定的代码包及它们的依赖包。相比 <code class="language-plaintext highlighter-rouge">go build</code>，它只是多了一个“安装编译后的结果文件到指定目录”的步骤。go install命令会安装程序，在工作区的bin目录下创建二进制执行文件。</p><p><code class="language-plaintext highlighter-rouge">go run</code> 用于编译并运行命令源码文件。</p><h3 id="printf">Printf</h3><p>在 Printf 方法中，使用 %T 格式说明符（Format Specifier）</p><table><thead><tr><th>占位符</th><th>功能</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">%v</code></td><td>按值的默认格式输出</td></tr><tr><td><code class="language-plaintext highlighter-rouge">%+v</code></td><td>包括字段名和值（适用于结构体）</td></tr><tr><td><code class="language-plaintext highlighter-rouge">%#v</code></td><td>输出 Go 语法表示的值</td></tr><tr><td><code class="language-plaintext highlighter-rouge">%T</code></td><td>输出值的类型</td></tr><tr><td><code class="language-plaintext highlighter-rouge">%%</code></td><td>输出 <code class="language-plaintext highlighter-rouge">%</code> 字符</td></tr></tbody></table><ul><li>宽度控制：<ul><li><code class="language-plaintext highlighter-rouge">%5d</code>：整数最小宽度为 5（右对齐）。</li><li><code class="language-plaintext highlighter-rouge">%5s</code>：字符串最小宽度为 5（右对齐）。</li></ul></li><li>精度控制：<ul><li><code class="language-plaintext highlighter-rouge">%.2f</code>：保留两位小数。</li><li><code class="language-plaintext highlighter-rouge">%6.2f</code>：总宽度为 6，保留两位小数。</li></ul></li><li>结合使用：<ul><li><code class="language-plaintext highlighter-rouge">%5.2f</code>：宽度为 5，保留两位小数。</li></ul></li><li>左对齐：<ul><li><code class="language-plaintext highlighter-rouge">%-5d</code>：整数宽度为 5，左对齐。</li></ul></li></ul><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"整数：%d\n"</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>            <span class="c1">// 整数：123</span>
    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"二进制：%b\n"</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>         <span class="c1">// 二进制：1111011</span>
    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"浮点数：%.2f\n"</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>       <span class="c1">// 浮点数：123.46</span>
    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"字符串：%s\n"</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>         <span class="c1">// 字符串：hello</span>
    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"带引号字符串：%q\n"</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>    <span class="c1">// 带引号字符串："hello"</span>
    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"指针：%p\n"</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">)</span>          <span class="c1">// 指针：0x...</span>
    <span class="nv">fmt</span><span class="o">.</span><span class="py">Printf</span><span class="o">(</span><span class="s">"类型：%T\n"</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>           <span class="c1">// 类型：float64</span>
</code></pre></div></div><h3 id="包管理">包管理</h3><p>所有可执行的 Go 程序都必须包含一个 main 函数。这个函数是程序运行的入口。main 函数应该放置于 main 包中。</p><p>在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。</p><p>首字母大写表示Public，否则private，对包来说</p><p>导入了包，却不在代码中使用它，这在 Go 中是非法的。当这么做时，编译器是会报错的。其原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"geometry/rectangle"</span> 
<span class="p">)</span>

<span class="k">var</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rectangle</span><span class="o">.</span><span class="n">Area</span> <span class="c">// 错误屏蔽器</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div><p>var _ = rectangle.Area 这一行屏蔽了错误。我们应该了解这些错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们，包括那些还没有使用过的包。由此建议在 import 语句下面的包级别范围中写上错误屏蔽器。</p><p>有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。例如，我们或许需要确保调用了 rectangle 包的 init 函数，而不需要在代码中使用它。这种情况也可以使用空白标识符，如下所示。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span> 

<span class="k">import</span> <span class="p">(</span>
    <span class="n">_</span> <span class="s">"geometry/rectangle"</span> 
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div><h3 id="init-函数">init 函数</h3><p>所有包都可以包含一个 init 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。</p><p>包的初始化顺序如下：</p><ol><li>首先初始化被导入的包。因此，首先初始化了 rectangle 包。</li><li>接着初始化了包级别的变量 rectLen 和 rectWidth。</li><li>调用 init 函数。</li><li>最后调用 main 函数。</li></ol><h2 id="变量常量及初始化">变量、常量及初始化</h2><p>golang是用C实现的，并且被称为下一代的C语言，但是golang跟C的差别还是很大的。它定义了一套很丰富的数据类型及数据结构，这些类型和结构或者是直接映射为C的数据类型，或者是用C struct来实现。</p><p>下面是 Go 支持的基本类型：</p><ul><li><p>bool</p></li><li><p>数字类型</p><p>int8, int16, int32, int64, int uint8, uint16, uint32, uint64, uint float32, float64 complex64, complex128</p></li><li>byte byte 是 uint8 的别名。</li><li>rune rune 是 int32 的别名。</li><li>string</li></ul><p>int：根据不同的底层平台（Underlying Platform），表示 32 或 64 位整型。除非对整型的大小有特定的需求，否则你通常应该使用 int 表示整型。</p><p>Go 有着非常严格的强类型特征。Go 没有自动类型提升或默认类型转换。只能强制转换</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
变量
 */</span>

<span class="k">func</span> <span class="n">variable</span><span class="p">()</span>  <span class="p">{</span>

  <span class="c">//集体定义</span>
  <span class="k">var</span><span class="p">{</span>
    <span class="n">a</span><span class="o">=</span><span class="m">3</span>
    <span class="n">b</span><span class="o">=</span><span class="m">4</span>
  <span class="p">}</span>
	<span class="c">//1. 指定类型</span>
	<span class="c">// 有默认值</span>
	<span class="k">var</span> <span class="n">a</span> <span class="kt">int</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="c">//也可以同时赋值</span>
	<span class="k">var</span> <span class="n">a1</span> <span class="kt">bool</span><span class="o">=</span><span class="no">true</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

	<span class="c">//2. 自动判断类型</span>
	<span class="k">var</span> <span class="n">b</span><span class="o">=</span><span class="m">3</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="c">//3. 省略var 就有:了</span>
	<span class="n">c</span><span class="o">:=</span><span class="m">3</span>
	<span class="nb">println</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">/*
常量
 */</span>
 <span class="k">func</span> <span class="n">constVariable</span><span class="p">(){</span>
 	 <span class="k">const</span> <span class="n">a</span> <span class="kt">int</span><span class="o">=</span><span class="m">3</span><span class="p">;</span>
	 <span class="c">//多类型简写</span>
	 <span class="k">const</span> <span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="no">false</span><span class="p">,</span><span class="m">4</span>
	 <span class="c">//可以做枚举</span>
	 <span class="k">const</span><span class="p">(</span>
		<span class="n">h</span><span class="o">=</span><span class="m">1</span>
		<span class="n">i</span><span class="o">=</span><span class="m">2</span>
		<span class="n">j</span><span class="o">=</span><span class="m">3</span>
		<span class="c">//如果不赋值，就是上一行的值</span>
	 <span class="p">)</span>


	 <span class="c">//itoa</span>
	 <span class="c">//iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，</span>
	 <span class="c">// const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</span>
	 <span class="k">const</span> <span class="p">(</span>
		 <span class="n">a1</span> <span class="o">=</span> <span class="no">iota</span>
		 <span class="n">b</span> <span class="o">=</span> <span class="no">iota</span>
		 <span class="n">c1</span> <span class="o">=</span> <span class="no">iota</span>
	 <span class="p">)</span>
	 <span class="c">//a1是0</span>
 <span class="p">}</span>
</code></pre></div></div><h2 id="字符串和rune">字符串和rune</h2><p>字符串是一个字节切片，所以我们可以获取字符串的每一个字节。</p><p>但是 字符串是不可变的。 Go 中的字符串是不可变的。一旦一个字符串被创建，那么它将无法被修改。</p><p>len(s) 返回字符串中字节的数量</p><p>go底层实现</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">String</span>
<span class="p">{</span>
        <span class="n">byte</span><span class="o">*</span>   <span class="n">str</span><span class="p">;</span>
        <span class="n">intgo</span>   <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>一个汉字3个字节，这是因为在UTF-8编码规则中，一个中文占3个字节</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">printBytes</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%x "</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>rune 是 Go 语言的内建类型，<strong>它也是 int32 的别称</strong>。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。让我们修改一下上面的程序，用 rune 来打印字符。</p><p>rune对应了一个Unicode 码点，是定长的。UTF8是变长的。</p><p><strong>rune是固定的4个字节，utf是变长的，但都在4个字节的范围内。因此某字符串的字节长度是小于等于rune数组表示的字节长度的</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">printChars</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">runes</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">runes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%c "</span><span class="p">,</span><span class="n">runes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>


    <span class="k">var</span> <span class="n">r</span> <span class="kt">rune</span> <span class="o">=</span> <span class="sc">'你'</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"rune 值: %U</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c">// Unicode 码点</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"rune 占用字节数: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

    <span class="n">str</span> <span class="o">:=</span> <span class="s">"你"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"UTF-8 编码占用字节数: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>


<span class="n">输出是</span>

<span class="kt">rune</span> <span class="n">值</span><span class="o">:</span> <span class="n">U</span><span class="o">+</span><span class="m">4</span><span class="n">F60</span>
<span class="kt">rune</span> <span class="n">占用字节数</span><span class="o">:</span> <span class="m">4</span>
<span class="n">UTF</span><span class="o">-</span><span class="m">8</span> <span class="n">编码占用字节数</span><span class="o">:</span> <span class="m">3</span>

</code></pre></div></div><p><strong>用字节切片构造字符串</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">byteSlice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="m">67</span><span class="p">,</span> <span class="m">97</span><span class="p">,</span> <span class="m">102</span><span class="p">,</span> <span class="m">195</span><span class="p">,</span> <span class="m">169</span><span class="p">}</span><span class="c">//decimal equivalent of {'\x43', '\x61', '\x66', '\xC3', '\xA9'}</span>
    <span class="n">str</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">byteSlice</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</code></pre></div></div><p><strong>用 rune 切片构造字符串</strong></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">runeSlice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">{</span><span class="m">0x0053</span><span class="p">,</span> <span class="m">0x0065</span><span class="p">,</span> <span class="m">0x00f1</span><span class="p">,</span> <span class="m">0x006f</span><span class="p">,</span> <span class="m">0x0072</span><span class="p">}</span>
    <span class="n">str</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">runeSlice</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>字符串的长度</strong></p><p>utf8 package 包中的 func RuneCountInString(s string) (n int) 方法用来获取字符串的长度。这个方法传入一个字符串参数然后返回字符串中的 rune 的数量。</p><h2 id="条件语句循环语句">条件语句、循环语句</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
运算符
 */</span>

<span class="k">func</span> <span class="n">operator</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/*
	运算符没有三目运算符
	有赋值运算法及&amp;&amp; || ！
	有指针操作， &amp; 及 *
	 */</span>
<span class="p">}</span>

<span class="c">/*
条件语句
 */</span>
<span class="k">func</span> <span class="n">ifStatement</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">//if</span>
	<span class="k">if</span> <span class="m">3</span><span class="o">&lt;</span><span class="m">4</span><span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">"3&lt;4"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="m">3</span><span class="o">&lt;</span><span class="m">4</span><span class="p">){</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">"3&lt;4"</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="m">3</span><span class="o">&lt;</span><span class="m">4</span><span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">"3&lt;4"</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="m">4</span><span class="o">==</span><span class="m">4</span><span class="p">){</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">"4==4"</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">"Jdd"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">//switch</span>
	<span class="c">/*
	switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，
	从上直下逐一测试，直到匹配为止。。

	switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break
	 */</span>


	<span class="k">var</span> <span class="n">grade</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"B"</span>
	<span class="k">var</span> <span class="n">marks</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">90</span>

	<span class="k">switch</span> <span class="n">marks</span> <span class="p">{</span>
	<span class="k">case</span> <span class="m">90</span><span class="o">:</span> <span class="n">grade</span> <span class="o">=</span> <span class="s">"A"</span>
	<span class="k">case</span> <span class="m">80</span><span class="o">:</span> <span class="n">grade</span> <span class="o">=</span> <span class="s">"B"</span>
	<span class="k">case</span> <span class="m">50</span><span class="p">,</span><span class="m">60</span><span class="p">,</span><span class="m">70</span> <span class="o">:</span> <span class="n">grade</span> <span class="o">=</span> <span class="s">"C"</span>
	<span class="k">default</span><span class="o">:</span> <span class="n">grade</span> <span class="o">=</span> <span class="s">"D"</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">grade</span> <span class="o">==</span> <span class="s">"A"</span> <span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"优秀!</span><span class="se">\n</span><span class="s">"</span> <span class="p">)</span>
	<span class="k">case</span> <span class="n">grade</span> <span class="o">==</span> <span class="s">"B"</span><span class="p">,</span> <span class="n">grade</span> <span class="o">==</span> <span class="s">"C"</span> <span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"良好</span><span class="se">\n</span><span class="s">"</span> <span class="p">)</span>
	<span class="k">case</span> <span class="n">grade</span> <span class="o">==</span> <span class="s">"D"</span> <span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"及格</span><span class="se">\n</span><span class="s">"</span> <span class="p">)</span>
	<span class="k">case</span> <span class="n">grade</span> <span class="o">==</span> <span class="s">"F"</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"不及格</span><span class="se">\n</span><span class="s">"</span> <span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"差</span><span class="se">\n</span><span class="s">"</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="c">//</span>
	<span class="c">//switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</span>
	<span class="c">//</span>
	<span class="c">//Type Switch 语法格式如下：</span>

	<span class="c">//switch x.(type){</span>
	<span class="c">//	case type:</span>
	<span class="c">//	statement(s);</span>
	<span class="c">//	case type:</span>
	<span class="c">//	statement(s);</span>
	<span class="c">//	/* 你可以定义任意个数的case */</span>
	<span class="c">//	default: /* 可选 */</span>
	<span class="c">//	statement(s);</span>
	<span class="c">//}</span>

	<span class="c">//select</span>
	<span class="c">/*
	select是Go中的一个控制结构，
	类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。

	select随机执行一个可运行的case。如果没有case可运行，它将阻塞，
	直到有case可运行。一个默认的子句应该总是可运行的。
	 */</span>

	<span class="k">var</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span> <span class="k">chan</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="kt">int</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">i1</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="n">c1</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"received "</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="s">" from c1</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">c2</span> <span class="o">&lt;-</span> <span class="n">i2</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"sent "</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="s">" to c2</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
	<span class="k">case</span> <span class="n">i3</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="p">(</span><span class="o">&lt;-</span><span class="n">c3</span><span class="p">)</span><span class="o">:</span>  <span class="c">// same as: i3, ok := &lt;-c3</span>
		<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"received "</span><span class="p">,</span> <span class="n">i3</span><span class="p">,</span> <span class="s">" from c3</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"c3 is closed</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"no communication</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
	<span class="p">}</span><span class="c">//out: no communication</span>

<span class="p">}</span>

<span class="c">/*
循环语句
 */</span>

<span class="k">func</span> <span class="n">forStatement</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">/*
	Go语言的For循环有3中形式，只有其中的一种使用分号。

	和 C 语言的 for 一样：

	for init; condition; post { }
	和 C 的 while 一样：

	for condition { }
	和 C 的 for(;;) 一样：

	for { }
	 */</span>

	<span class="c">//for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="s">"abc"</span>
    <span class="c">// 忽略 2nd value，支持 string/array/slice/map。</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="c">// 忽略 index。</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 忽略全部返回值，仅迭代。</span>
    <span class="k">for</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"a"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"b"</span><span class="o">:</span> <span class="m">2</span><span class="p">}</span>
    <span class="c">// 返回 (key, value)。</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">m</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
  

	<span class="c">//for循环里的变量属于局部变量，与外界不冲突。。。就是for条件的那个位置</span>


	<span class="c">/*
	和 C 的 while 一样：

	for condition { }
	 */</span>
<span class="p">}</span>

</code></pre></div></div><ul><li>range一个变量时如果不是引用 会拷贝整个变量</li><li></li></ul><h2 id="函数">函数</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
函数
 */</span>

<span class="k">func</span> <span class="n">function</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/*
	func function_name( [parameter list] ) [return_types] {
   		函数体
	}
	 */</span>


	<span class="c">/*
	func swap(x, y string) (string, string) {
		return y, x
	}
	 */</span>

	<span class="c">/*
   函数可作为变量
	*/</span>
	<span class="c">//func f7(){</span>
	<span class="c">//	/* 声明函数变量 */</span>
	<span class="c">//	getSquareRoot := func(x float64) float64 {</span>
	<span class="c">//		return math.Sqrt(x)</span>
	<span class="c">//	}</span>
	<span class="c">//</span>
	<span class="c">//	/* 使用函数 */</span>
	<span class="c">//	fmt.Println(getSquareRoot(9))</span>
	<span class="c">//}</span>

	<span class="c">/*
	闭包
	 */</span>
	<span class="c">//func getSequence() func() int { // return值是func() int</span>
	<span class="c">//	i:=0</span>
	<span class="c">//	return func() int {</span>
	<span class="c">//		i+=1</span>
	<span class="c">//		return i</span>
	<span class="c">//	}</span>
	<span class="c">//}</span>
	<span class="c">///* nextNumber 为一个函数，函数 i 为 0 */</span>
	<span class="c">//nextNumber := getSequence()</span>
	<span class="c">//</span>
	<span class="c">///* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span>
	<span class="c">//fmt.Println(nextNumber())</span>
	<span class="c">//fmt.Println(nextNumber())</span>
	<span class="c">//fmt.Println(nextNumber())</span>

	<span class="c">/*
	方法
	 */</span>
	<span class="c">///* 定义结构体 */</span>
	<span class="c">//type Circle struct {</span>
	<span class="c">//	radius float64</span>
	<span class="c">//}</span>
	<span class="c">////该 method 属于 Circle 类型对象中的方法</span>
	<span class="c">//func (c Circle) getArea() float64 {</span>
	<span class="c">//	//c.radius 即为 Circle 类型对象中的属性</span>
	<span class="c">//	return 3.14 * c.radius * c.radius</span>
	<span class="c">//}</span>

<span class="p">}</span>
</code></pre></div></div><h2 id="数组和指针">数组和指针</h2><p>Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，则不会影响原始数组。</p><p>通过将数组作为参数传递给 len 函数，可以得到数组的长度。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
数组
 */</span>
<span class="k">func</span> <span class="n">array</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/*
	var balance [10] float32
	var balance1 = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
	//如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：
	var balance2 = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//直接[]也行
	//多维数组
	var threedim [5][10][4]int
	var a = [3][4]int{
		{0, 1, 2, 3} ,
		{4, 5, 6, 7} ,
		{8, 9, 10, 11},
	}

	*/</span>
	<span class="c">/* 未定义长度的数组只能传给不限制数组长度的函数 */</span>
	<span class="c">/* 定义了长度的数组只能传给限制了相同数组长度的函数 */</span>

<span class="p">}</span>
</code></pre></div></div><p>指针的零值是 nil。</p><p><strong>不要向函数传递数组的指针，而应该使用切片</strong> 因为数组是数组拷贝。</p><p>假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">modify</span><span class="p">(</span><span class="n">sls</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">sls</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">90</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">a</span> <span class="o">:=</span> <span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">89</span><span class="p">,</span> <span class="m">90</span><span class="p">,</span> <span class="m">91</span><span class="p">}</span>
    <span class="n">modify</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="p">])</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>指针</strong></p><p>Go 并不支持其他语言（例如 C）中的指针运算。</p><p>Go 语言允许我们在访问 firstName 字段时，可以使用 <code class="language-plaintext highlighter-rouge">emp8.firstName</code> 来代替显式的解引用 <code class="language-plaintext highlighter-rouge">(*emp8).firstName</code></p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
指针
 */</span>

<span class="k">func</span> <span class="n">pointer</span><span class="p">()</span>  <span class="p">{</span>
	<span class="k">var</span> <span class="n">a</span> <span class="kt">int</span><span class="o">=</span> <span class="m">20</span>   <span class="c">/* 声明实际变量 */</span>
	<span class="k">var</span> <span class="n">ip</span> <span class="o">*</span><span class="kt">int</span>        <span class="c">/* 声明指针变量 */</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span>  <span class="c">/* 指针变量的存储地址 */</span>
	<span class="nb">println</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">)</span>
	<span class="c">/*
	nil 指针也称为空指针。
	nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
	 */</span>


	 <span class="c">//指针数组</span>
	<span class="c">//var ptr [MAX]*int;</span>

	<span class="c">//指向指针的指针</span>
	<span class="c">//var pptr **int</span>

	<span class="c">//指针作为函数参数</span>
	<span class="c">/* 调用函数用于交换值
	* &amp;a 指向 a 变量的地址
	* &amp;b 指向 b 变量的地址
	*/</span>
	<span class="c">//swap(&amp;a, &amp;b);</span>
	<span class="c">//func swap(x *int, y *int) {}</span>


<span class="p">}</span>
</code></pre></div></div><h2 id="结构体">结构体</h2><p>结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的。</p><p>如果结构体包含不可比较的字段，则结构体变量也不可比较。比如map</p><p>匿名结构体</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">emp3</span> <span class="o">:=</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">firstName</span><span class="p">,</span> <span class="n">lastName</span> <span class="kt">string</span>
        <span class="n">age</span><span class="p">,</span> <span class="n">salary</span>         <span class="kt">int</span>
    <span class="p">}{</span>
        <span class="n">firstName</span><span class="o">:</span> <span class="s">"Andreah"</span><span class="p">,</span>
        <span class="n">lastName</span><span class="o">:</span>  <span class="s">"Nikola"</span><span class="p">,</span>
        <span class="n">age</span><span class="o">:</span>       <span class="m">31</span><span class="p">,</span>
        <span class="n">salary</span><span class="o">:</span>    <span class="m">5000</span><span class="p">,</span>
    <span class="p">}</span>

</code></pre></div></div><p>匿名字段</p><p>当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="kt">string</span>
    <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">p</span> <span class="o">:=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Naveen"</span><span class="p">,</span> <span class="m">50</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>提升字段（Promoted Fields）</strong></p><p>如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Address</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">city</span><span class="p">,</span> <span class="n">state</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span> <span class="kt">string</span>
    <span class="n">age</span>  <span class="kt">int</span>
    <span class="n">Address</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">p</span> <span class="n">Person</span>
    <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"Naveen"</span>
    <span class="n">p</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="m">50</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Address</span> <span class="o">=</span> <span class="n">Address</span><span class="p">{</span>
        <span class="n">city</span><span class="o">:</span>  <span class="s">"Chicago"</span><span class="p">,</span>
        <span class="n">state</span><span class="o">:</span> <span class="s">"Illinois"</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Name:"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Age:"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"City:"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">city</span><span class="p">)</span> <span class="c">//city is promoted field</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"State:"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span><span class="p">)</span> <span class="c">//state is promoted field</span>
<span class="p">}</span>
</code></pre></div></div><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
结构体
 */</span>

<span class="k">func</span> <span class="n">structStatement</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/*
	type struct_variable_type struct {
	   member definition;
	   member definition;
	   ...
	   member definition;
	}
	 */</span>

	<span class="c">//variable_name := structure_variable_type {value1, value2...valuen}</span>
	<span class="c">//或</span>
	<span class="c">//variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}</span>

	<span class="c">//// 创建一个新的结构体</span>
	<span class="c">//fmt.Println(Books{"Go 语言", "www.runoob.com", "Go 语言教程", 6495407})</span>
	<span class="c">//</span>
	<span class="c">//// 也可以使用 key =&gt; value 格式</span>
	<span class="c">//fmt.Println(Books{title: "Go 语言", author: "www.runoob.com", subject: "Go 语言教程", book_id: 6495407})</span>
	<span class="c">//</span>
	<span class="c">//// 忽略的字段为 0 或 空</span>
	<span class="c">//fmt.Println(Books{title: "Go 语言", author: "www.runoob.com"})</span>

	<span class="c">//结构体作为函数参数</span>
	<span class="c">//func printBook( book Books )</span>

	<span class="c">//结构体指针</span>
	<span class="k">var</span> <span class="n">struct_pointer</span> <span class="o">*</span><span class="n">Books</span>
	<span class="c">//使用结构体指针访问结构体成员，使用 "." 操作符：</span>
	<span class="n">struct_pointer</span><span class="o">.</span><span class="n">title</span><span class="p">;</span>


<span class="p">}</span>
</code></pre></div></div><h2 id="方法">方法</h2><p>在调用方法的时候，值类型既可以调用<code class="language-plaintext highlighter-rouge">值接收者</code>的方法，也可以调用<code class="language-plaintext highlighter-rouge">指针接收者</code>的方法；指针类型既可以调用<code class="language-plaintext highlighter-rouge">指针接收者</code>的方法，也可以调用<code class="language-plaintext highlighter-rouge">值接收者</code>的方法。</p><p>也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><p>一般来说，指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。</p><p>指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。</p><p>在其他的所有情况，值接收器都可以被使用。</p><p><strong>注意给值接收器传递指针，那也是更改不可见的，只有指针接收器才可以更改可见</strong>。能不能更改可见以接收器类型为准。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span>     <span class="kt">string</span>
    <span class="n">salary</span>   <span class="kt">int</span>
    <span class="n">currency</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">/*
  displaySalary() 方法将 Employee 做为接收器类型
*/</span>
<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">Employee</span><span class="p">)</span> <span class="n">displaySalary</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Salary of %s is %s%d"</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">currency</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">salary</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">emp1</span> <span class="o">:=</span> <span class="n">Employee</span> <span class="p">{</span>
        <span class="n">name</span><span class="o">:</span>     <span class="s">"Sam Adolf"</span><span class="p">,</span>
        <span class="n">salary</span><span class="o">:</span>   <span class="m">5000</span><span class="p">,</span>
        <span class="n">currency</span><span class="o">:</span> <span class="s">"$"</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">emp1</span><span class="o">.</span><span class="n">displaySalary</span><span class="p">()</span> <span class="c">// 调用 Employee 类型的 displaySalary() 方法</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="可变参数">可变参数</h2><p>如果函数最后一个参数被记作 …T ，这时函数可以接受任意个 T 类型参数作为最后一个参数。</p><p>请注意只有函数的最后一个参数才允许是可变的。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="nb">append</span><span class="p">(</span><span class="n">slice</span> <span class="p">[]</span><span class="n">Type</span><span class="p">,</span> <span class="n">elems</span> <span class="o">...</span><span class="n">Type</span><span class="p">)</span> <span class="p">[]</span><span class="n">Type</span>
</code></pre></div></div><p>传入后，当成一个数组，range访问就好了</p><h2 id="切片slice">切片slice</h2><p>slice类型的底层同样是一个C struct。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct	Slice
{				// must not move anything
	byte*	array;		// actual data
	uintgo	len;		// number of elements
	uintgo	cap;		// allocated number of elements
};


</code></pre></div></div><p>append 函数的定义是<code class="language-plaintext highlighter-rouge"> func append（s[]T，x ... T）[]T</code>。</p><p>我们可以认为，切片在内部可由一个结构体类型表示。这是它的表现形式，</p><p><strong>是引用传递，要同步内容修改的</strong></p><p>当新的元素被添加到切片时，如果容量不够，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">slice</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">Length</span>        <span class="kt">int</span>
    <span class="n">Capacity</span>      <span class="kt">int</span>
    <span class="n">ZerothElement</span> <span class="o">*</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div></div><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
切片
 */</span>
<span class="k">func</span> <span class="n">slice</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">//使用结构体指针访问结构体成员，使用 "." 操作符：</span>
	<span class="c">//struct_pointer.title;</span>

	<span class="c">//var slice1 []type = make([]type, len)</span>
	<span class="c">//</span>
	<span class="c">//也可以简写为</span>
	<span class="c">//</span>
	<span class="c">//slice1 := make([]type, len)</span>

	<span class="c">//make([]T, length, capacity)</span>
	<span class="c">//s := arr[startIndex:endIndex]</span>

	<span class="c">// var numbers = make([]int,3,5)</span>

	<span class="c">//一个切片在未初始化之前默认为 nil，长度为 0，</span>
	<span class="c">//var numbers []int</span>

	<span class="n">numbers</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="p">,</span><span class="m">8</span><span class="p">}</span>
	<span class="c">/* 打印原始切片 */</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"numbers =="</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>

	<span class="c">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"numbers[1:4] =="</span><span class="p">,</span> <span class="n">numbers</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">])</span>

	<span class="c">//append() 和 copy() 函数</span>

	<span class="c">/* 同时添加多个元素 */</span>
	<span class="n">numbers</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">)</span>

	<span class="c">/* 创建切片 numbers1 是之前切片的两倍容量*/</span>
	<span class="n">numbers1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">),</span> <span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span><span class="o">*</span><span class="m">2</span><span class="p">)</span>

	<span class="c">/* 拷贝 numbers 的内容到 numbers1 */</span>
	<span class="nb">copy</span><span class="p">(</span><span class="n">numbers1</span><span class="p">,</span><span class="n">numbers</span><span class="p">)</span>
  
  <span class="n">make函数参数分别是len和cap</span><span class="p">,</span> <span class="n">当只有一个时</span><span class="err">，</span><span class="n">是len</span><span class="p">,</span><span class="nb">cap</span><span class="o">=</span><span class="nb">len</span><span class="err">。</span>
  
  <span class="n">数组引用切片后</span><span class="err">，</span><span class="n">对切片读写是操作底层数组</span><span class="p">,</span> <span class="n">如果超过cap就会重新分配</span><span class="err">，</span><span class="n">地址不一样了</span><span class="err">。</span><span class="n">直接创建切片会自动分配底层数组</span><span class="err">。</span>
  
  
  <span class="n">go切片不像python那样有步长和负索引</span><span class="err">，</span><span class="n">但支持切片容量定制</span><span class="err">。</span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="n">z</span><span class="p">]</span> <span class="n">切片内容</span> <span class="p">[</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">]</span> <span class="n">切片长度</span><span class="o">:</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span> <span class="n">切片容量</span><span class="o">:</span><span class="n">z</span><span class="o">-</span><span class="n">x</span>
<span class="p">}</span>

<span class="c">/*
遍历 range
 */</span>

<span class="k">func</span> <span class="n">rangeStatement</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/*
	 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。
	在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key及value 值。
	 */</span>

	<span class="c">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span>
	<span class="n">nums</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
	<span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
  <span class="c">// only value</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span>
	<span class="p">}</span>

  <span class="c">// index, value  </span>
  <span class="n">nums</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">}</span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span><span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="c">// index, value</span>
	<span class="p">}</span>
  <span class="c">// only index</span>
	<span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span><span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="c">// only index</span>
	<span class="p">}</span>
  

<span class="p">}</span>
</code></pre></div></div><h2 id="指针">指针</h2><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>new是一个内置的函数，它的函数签名如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    func new(Type) *Type
</code></pre></div></div><p>其中，</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1.Type表示类型，new函数只接受一个参数，这个参数是一个类型
    2.*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。
</code></pre></div></div><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</p><h2 id="map">map</h2><p>map 的零值是 nil。如果你想添加元素到 nil map 中，会触发运行时 panic。因此 map 必须使用 make 函数初始化。</p><p>也就是说必须使用<code class="language-plaintext highlighter-rouge">make</code></p><p>获取 map 的长度使用 len 函数。</p><p>和 slices 类似，map 也是引用类型。当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，改变其中一个变量，就会影响到另一变量。</p><p>map 之间不能使用 == 操作符判断，== 只能用来检查 map 是否为 nil。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
map
 */</span>
<span class="k">func</span> <span class="n">mapStatement</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/* 声明变量，默认 map 是 nil */</span>
	<span class="c">//var map_variable map[key_data_type]value_data_type</span>
	<span class="c">//nil map 不能用来存放键值对，会panic</span>

	<span class="c">/* 使用 make 函数 */</span>
	<span class="c">//map_variable := make(map[key_data_type]value_data_type)</span>

	<span class="c">/* 创建map */</span>
	<span class="c">//countryCapitalMap := map[string]string{"France": "Paris",</span>
	<span class="c">// "Italy": "Rome", "Japan": "Tokyo", "India": "New delhi"}</span>


	<span class="k">var</span> <span class="n">countryCapitalMap</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="c">/*创建集合 */</span>
	<span class="n">countryCapitalMap</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>

	<span class="c">/* map插入key - value对,各个国家对应的首都 */</span>
	<span class="n">countryCapitalMap</span> <span class="p">[</span> <span class="s">"France"</span> <span class="p">]</span> <span class="o">=</span> <span class="s">"Paris"</span>
	<span class="n">countryCapitalMap</span> <span class="p">[</span> <span class="s">"Italy"</span> <span class="p">]</span> <span class="o">=</span> <span class="s">"罗马"</span>

	<span class="c">/*查看元素在集合中是否存在 */</span>
	<span class="n">captial</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">countryCapitalMap</span> <span class="p">[</span> <span class="s">"美国"</span> <span class="p">]</span> <span class="c">/*如果确定是真实的,则存在,否则不存在 */</span>
	<span class="c">/*fmt.Println(captial) */</span>
	<span class="c">/*fmt.Println(ok) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"美国的首都是"</span><span class="p">,</span> <span class="n">captial</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"美国的首都不存在"</span><span class="p">)</span>
	<span class="p">}</span>
  
  <span class="n">如果key不在map里</span><span class="err">，</span><span class="n">取出来的是默认值</span><span class="err">，</span><span class="n">比如string类型取出来的是</span><span class="s">""</span><span class="o">.</span>

	<span class="c">/*删除元素*/</span>
	<span class="nb">delete</span><span class="p">(</span><span class="n">countryCapitalMap</span><span class="p">,</span> <span class="s">"France"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="错误处理">错误处理</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
错误处理
 */</span>

<span class="k">func</span> <span class="n">errorHandle</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c">/*
	error类型是一个接口类型，这是它的定义：

		type error interface {
			Error() string
		}
	 */</span>

<span class="c">/*
	// 定义一个 DivideError 结构
	type DivideError struct {
		dividee int
		divider int
	}

	// 实现 `error` 接口
	func (de *DivideError) Error() string {
		strFormat := `
		Cannot proceed, the divider is zero.
		dividee: %d
		divider: 0
	`
		return fmt.Sprintf(strFormat, de.dividee)
	}

	// 定义 `int` 类型除法运算的函数
	func Divide(varDividee int, varDivider int) (result int, errorMsg string) {
		if varDivider == 0 {
			dData := DivideError{
				dividee: varDividee,
				divider: varDivider,
			}
			errorMsg = dData.Error()
			return
		} else {
			return varDividee / varDivider, ""
		}

	}

 */</span>
<span class="p">}</span>

</code></pre></div></div><h2 id="defer">defer</h2><p>defer特性：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1. 关键字 defer 用于注册延迟调用。
    2. 这些调用直到 return 前才被执。因此，可以用来做资源清理。
    3. 多个defer语句，按先进后出的方式执行。
    4. defer语句中的变量，在defer声明时就决定了。
</code></pre></div></div><p>defer用途：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1. 关闭文件句柄
    2. 锁资源释放
    3. 数据库连接释放
</code></pre></div></div><p>defer 是先进后出</p><h2 id="defer的陷阱">defer的陷阱</h2><p><strong>陷阱:</strong> **声明defer时，defer函数的实参就会赋值，注意赋值的是不是引用，如果是引用, 引用是可以在变化的，但引用重新赋值也是不会传递到defer执行时的。 **</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"errors"</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"first defer err %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"second defer err %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="p">}(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"third defer err %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"divided by zero!"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>输出结果：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    third defer err divided by zero! 是变量的引用。
    second defer err &lt;nil&gt; 这里err是声明时就赋值了，所以是nil
    first defer err &lt;nil&gt; 直接调用函数的话是声明时参数就进行求值。所以为nil。
</code></pre></div></div><p>更多，<a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8defer.html">请参考</a></p><ul><li><strong><code class="language-plaintext highlighter-rouge">defer</code> 的非 <code class="language-plaintext highlighter-rouge">recover</code> 语句一定会执行</strong>，无论是否发生 <code class="language-plaintext highlighter-rouge">panic</code>。</li><li><code class="language-plaintext highlighter-rouge">defer</code> 中是否包含 <code class="language-plaintext highlighter-rouge">recover</code> 不会影响其他 <code class="language-plaintext highlighter-rouge">defer</code> 的执行，只会影响 <code class="language-plaintext highlighter-rouge">panic</code> 的传播。</li><li>使用 <code class="language-plaintext highlighter-rouge">defer</code> 的资源清理代码（如关闭文件、释放锁）在 <code class="language-plaintext highlighter-rouge">panic</code> 时仍然是安全的，因为它们会被执行。</li></ul><p><strong>defer参数求值时机</strong></p><ul><li><p>defer声明时求值。 在声明 <code class="language-plaintext highlighter-rouge">defer</code> 时，函数参数会立即求值。这里的 <code class="language-plaintext highlighter-rouge">someVar</code> 会在 <code class="language-plaintext highlighter-rouge">defer</code> 声明时求值，而不是在实际执行时。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"直接调用："</span><span class="p">,</span> <span class="n">someVar</span><span class="p">)</span>
  
<span class="n">或</span>
  
<span class="k">defer</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span> <span class="n">P</span><span class="p">)</span> <span class="p">{}(</span><span class="n">x</span><span class="p">)</span>  <span class="n">这个时候x已经赋值给p了</span>
  
  
<span class="n">或</span>
  
<span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">field</span><span class="p">{</span>
  <span class="p">{</span><span class="s">"one"</span><span class="p">},</span> <span class="p">{</span><span class="s">"two"</span><span class="p">},</span> <span class="p">{</span><span class="s">"three"</span><span class="p">}</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>    <span class="c">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span>
  <span class="k">go</span> <span class="n">v</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div></li><li><p>defer执行时求值</p></li></ul><p>在 <code class="language-plaintext highlighter-rouge">defer</code> 包裹匿名函数时，参数的求值会延迟到真正执行 <code class="language-plaintext highlighter-rouge">defer</code> 时。</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"匿名函数："</span><span class="p">,</span> <span class="n">someVar</span><span class="p">)</span>
  <span class="p">}()</span>
</code></pre></div></div><p>这里的 <code class="language-plaintext highlighter-rouge">someVar</code> 的值会在 <code class="language-plaintext highlighter-rouge">defer</code> 执行时才计算。</p><p>另外注意: defer语句会延迟到函数返回时执行。因此，在循环中的defer调用不会在每轮结束时执行</p><p><strong>return变量</strong></p><p>return代码出现时，就会return的变量进行赋值，它早于defer。</p><ul><li>如果return的值是常量，那就是值复制到了单独的一个returnValue。defer里对要return的变量进行赋值或者修改，不影响returnValue。</li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">c</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">i</span> <span class="kt">int</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer1:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"return:"</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">()))</span>
<span class="p">}</span>

<span class="n">return非引用</span><span class="err">，</span><span class="n">修改不生效</span>

<span class="n">defer1</span><span class="o">:</span> <span class="m">1</span>
<span class="k">return</span><span class="o">:</span> <span class="m">0</span>


</code></pre></div></div><ul><li>如果是引用，return的变量和returnValue可同步变化。赋值和修改皆同步生效 。</li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">c</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">i</span> <span class="kt">int</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="n">i</span> <span class="o">=</span> <span class="m">10</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer2:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer1:"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"return:"</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">()))</span>
<span class="p">}</span>

<span class="n">返回引用</span><span class="err">，</span><span class="n">defer修改return变量生效</span><span class="err">。</span>

<span class="n">defer1</span><span class="o">:</span> <span class="m">1</span>
<span class="n">defer2</span><span class="o">:</span> <span class="m">10</span>
<span class="k">return</span><span class="o">:</span> <span class="m">10</span>

</code></pre></div></div><ul><li>如果声明了返回的变量，则defer里赋值是生效的，不论是不是引用。比如</li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">abc</span><span class="p">()</span> <span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="m">3</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="m">5</span>
<span class="p">}</span>

<span class="n">以上是返回3</span>
</code></pre></div></div><h2 id="继承-方法集">继承 方法集</h2><p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E9%9B%86.html">Golang方法集</a> ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p><p>匿名字段情况下的方法集不受下面影响，编译器总是查找全部方法，并自动转换 receiver 实参。但接口有影响</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    • 类型 T 方法集包含全部 receiver T 方法。
    • 类型 *T 方法集包含全部 receiver T + *T 方法。
    • 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 
    • 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 
    • 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。
</code></pre></div></div><p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p><p><strong>主旨是Go有一个语法糖: 对指针类型变量可自动求值，因此指针的方法集更大</strong></p><p>任何类型的方法集中只要拥有该接口’对应的全部方法签名。就表示它 “实现” 了该接口，无须在该类型上显式声明实现了哪个接口。</p><h2 id="接口interface">接口interface</h2><p>请牢记接口（interface）是一种类型。接口是一个或多个方法签名的集合。</p><ul><li><strong>interface{}是值传递！。 比如error Error做参数，就是值传递。struct默认也是值传递。</strong></li><li><strong>interface{}如果赋值的是指针类型（如 <code class="language-plaintext highlighter-rouge">\*int</code>, <code class="language-plaintext highlighter-rouge">\*struct</code>）</strong>，<code class="language-plaintext highlighter-rouge">interface{}</code> <strong>存储的是指针</strong>，可以通过该指针修改原始数据。</li><li>对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。</li><li><p>接口的零值是 nil。对于值为 nil 的接口，其底层值（Underlying Value）和具体类型（Concrete Type）都为 nil。</p></li><li>接口同样支持匿名字段方法。</li><li>接口也可实现类似OOP中的多态。</li><li>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。空接口类型的变量可以存储任意类型的变量。</li><li>一个类型可实现多个接口。</li><li>接口命名习惯以 er 结尾。</li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">writer</span> <span class="k">interface</span><span class="p">{</span>
    <span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div></div><p>类型断言</p><ul><li><p>类型断言用于提取接口的底层值（Underlying Value）。</p></li><li><p>在语法 i.(T) 中，接口 i 的具体类型是 T，该语法用于获得接口的底层值。</p></li></ul><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>  
    <span class="n">s</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c">//get the underlying int value from i</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>接口支持嵌套和匿名方法</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Walker</span> <span class="kt">interface</span> <span class="o">{</span>
    <span class="kt">Walk</span><span class="o">()</span>
<span class="o">}</span>

<span class="k">type</span> <span class="kt">Speaker</span> <span class="kt">interface</span> <span class="o">{</span>
    <span class="kt">Speak</span><span class="o">()</span>
<span class="o">}</span>

<span class="k">type</span> <span class="kt">Human</span> <span class="kt">interface</span> <span class="o">{</span>
    <span class="kt">Walker</span>
    <span class="kt">Speaker</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="多态">多态</h2><p><strong>是否能够将一个类型赋值给接口变量，取决于该类型是否实现了接口的所有方法</strong>。这里有两个关键点：</p><ol><li><strong>如果方法使用</strong> <strong>值接收者</strong>（<code class="language-plaintext highlighter-rouge">func (t T) Method()</code>）：<ul><li><strong>该方法既可以通过值类型变量调用，也可以通过指针类型变量调用</strong>。</li><li>这样，无论 <code class="language-plaintext highlighter-rouge">T</code> 还是 <code class="language-plaintext highlighter-rouge">*T</code>，都可以赋值给接口变量。</li></ul></li><li><strong>如果方法使用</strong> <strong>指针接收者</strong>（<code class="language-plaintext highlighter-rouge">func (t *T) Method()</code>）：<ul><li><strong>该方法只能通过指针类型变量调用</strong>，不能通过值类型调用。</li><li><strong>值类型 <code class="language-plaintext highlighter-rouge">T</code> 不满足接口约定，因此 <code class="language-plaintext highlighter-rouge">T</code> 不能赋值给接口变量</strong>。</li></ul></li></ol><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Describer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Describe</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Person</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// 值接收者</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Person</span><span class="p">)</span> <span class="n">Describe</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Person:"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Address</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">city</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// 指针接收者</span>
<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">Address</span><span class="p">)</span> <span class="n">Describe</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Address:"</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">city</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">d1</span> <span class="n">Describer</span> <span class="o">=</span> <span class="n">Person</span><span class="p">{</span><span class="s">"Alice"</span><span class="p">}</span>  <span class="c">// ✅ 正确：值接收者允许 `T{}` 赋值</span>
    <span class="k">var</span> <span class="n">d2</span> <span class="n">Describer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Person</span><span class="p">{</span><span class="s">"Bob"</span><span class="p">}</span>   <span class="c">// ✅ 正确：值接收者允许 `&amp;T{}` 赋值</span>
    <span class="n">d1</span><span class="o">.</span><span class="n">Describe</span><span class="p">()</span>
    <span class="n">d2</span><span class="o">.</span><span class="n">Describe</span><span class="p">()</span>

    <span class="k">var</span> <span class="n">d3</span> <span class="n">Describer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Address</span><span class="p">{</span><span class="s">"New York"</span><span class="p">}</span> <span class="c">// ✅ 正确：指针接收者要求 `&amp;T{}` 赋值</span>
    <span class="n">d3</span><span class="o">.</span><span class="n">Describe</span><span class="p">()</span>

  <span class="k">var</span> <span class="n">d4</span> <span class="n">Describer</span> <span class="o">=</span> <span class="n">Address</span><span class="p">{</span><span class="s">"Paris"</span><span class="p">}</span> <span class="c">// ❌ 编译错误：指针接收者 `*T` 不能用 `T{}` 赋值给接口</span>
    <span class="n">d4</span><span class="o">.</span><span class="n">Describe</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div></article><div class="share mobile-hidden"><div class="share-component"></div></div><div class="comment mobile-hidden"></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width: 96%" type="text" id="search_box" placeholder="Search" /></div><ul id="search_results" style=" font-size: 14px; list-style-type: none; padding-top: 10px; padding-left: 10px; " ></ul><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 20, fuzzy: false, exclude: ['Welcome'] }); window.onload = function(){ var query_text = window.location.search.substring(1); var vars = query_text.split("&"); for (var i=0;i<vars.length;i++) { var pair = vars[i].split("="); if(pair[0] == "search_text"){ var query = pair[1]; query = decodeURI(query); var search = document.getElementById('search_box'); search.value = query; var event = new InputEvent('keyup'); search.dispatchEvent(event); break } } } </script><h3 class="post-directory-title">Table of Contents</h3><div id="post-directory-module"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/jquery.toc.js"></script><div class="mobile-hidden"><h3>Popular Posts</h3><ul><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/12/01/typescript%E7%AC%94%E8%AE%B0/">2022-12 typescript笔记</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2022/08/16/scala%E8%AF%AD%E6%B3%95/">2022-08 scala语法</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/12/26/etcd%E5%92%8Craft/">2021-12 etcd和raft</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/09/08/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/">2021-09 状态压缩</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/25/%E5%8D%9A%E5%BC%88%E8%AE%BA/">2021-01 博弈论</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE/">2021-01 分布式算法和协议</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/Kafka%E5%8E%9F%E7%90%861-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">2020-12 kafka原理1-基础架构</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/12/08/ElasticSearch/">2020-12 ElasticSearch(ES)原理</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/">2020-11 动态规划总结</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2020/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/">2020-11 线段树</a></h6><h6 class="repo-list-name font16px"> <a href="https://mafulong.github.io/2017/12/03/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2017-12 javascript笔记</a></h6></ul></div></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Fulong Ma">Fulong Ma</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="https://www.privacypolicygenerator.info/live.php?token=cnfKULv1VpqenfUs021YVA90fPiK75Cw">Privacy Policy</a></li><li> <a href="https://www.termsfeed.com/live/9dccd944-1b18-436d-bd12-3dd799b1282a">Terms </a></li><li> <a href="javascript:window.scrollTo(0,0)">TOP</a></li></ul><a href="https://github.com/mafulong/mafulong.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://mafulong.github.io/" title="Home" target="">Home</a></li><li> <a href="https://mafulong.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://mafulong.github.io/archives/" title="Achieves" target="">Achieves</a></li><li> <a href="https://mafulong.github.io/open-source" title="Open-Source" target="">Open-Source</a></li><li> <a href="https://mafulong.github.io/bookmark" title="Bookmark" target="">Bookmark</a></li><li> <a href="https://mafulong.github.io/about" title="About" target="">About</a></li></ul><script async src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script> <script> $(document).ready(function() { $("td img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); $("p img").each(function() { var strA = "<a href='" + this.src + "' itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" itemprop=\"url\" data-fancybox=\"default\" rel=\"default\"></a>"; $(this).wrapAll(strA); }); }); </script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mafulong/mafulong.github.io@built/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function ($) { $('.geopattern').each(function () { $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS4VDLWLNC"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() {dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SS4VDLWLNC'); </script></div></body></html>
