---
layout: post
category: leetcode
title: 1235. 规划兼职工作
tags: leetcode
---

## title
[problem link](https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/)


你打算利用空闲时间来做兼职工作赚些零花钱。

这里有 `n` 份兼职工作，每份工作预计从 `startTime[i]` 开始到 `endTime[i]` 结束，报酬为 `profit[i]`。

给你一份兼职工作表，包含开始时间 `startTime`，结束时间 `endTime` 和预计报酬 `profit` 三个数组，请你计算并返回可以获得的最大报酬。

注意，时间上出现重叠的 2 份工作不能同时进行。

如果你选择的工作在时间 `X` 结束，那么你可以立刻进行在时间 `X` 开始的下一份工作。

## solution

动态规划
dp(i)表示前i个，最大值，然后i可以选择参加d[i] = d[idx]+vi, idx是前面最后一个满足条件的
选择不参加，dp[i] = max(dp[i],dp[i-1])



```python
class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        n = len(startTime)
        events = [[startTime[i], endTime[i], profit[i]] for i in range(n)]
        events = sorted(events, key=lambda x: x[1])
        ets = [x[1] for x in events]
        dp = [0 for _ in range(n + 1)]
        for i in range(1, n + 1):
            idx = 0
            st, et, vi = events[i - 1]
            # 参加
            idx = bisect.bisect_left(ets, st+1, 0, i - 1) - 1
            if idx < 0:
                dp[i] = max(dp[i], vi)
            else:
                dp[i] = max(dp[i], dp[idx + 1] + vi)
            # 不参加
            dp[i] = max(dp[i], dp[i - 1])
        return dp[n]
```

