---
layout: post
category: Algorithms
title: 七种排序算法的比较
tags: Algorithms
---

## 复杂度
- 若待排序的记录的关键字在一个明显有限范围内时,且空间允许时用桶排序。
- 当n较大时，关键字元素比较随机，对稳定性没要求宜用快速排序。
- 当n较大时，关键字元素可能出现本身是有序的，对稳定性有要求时，空间允许的情况下宜用归并排序。
- 当n较大时，关键字元素可能出现本身是有序的，对稳定性没有要求时宜用堆排序

### 排序算法的比较

| 算法 | 稳定性 | 时间复杂度 | 空间复杂度 | 备注 |
| :---: | :---: |:---: | :---: | :---: |
| 选择排序 | × | N<sup>2</sup> | 1 | |
| 冒泡排序 | √ |  N<sup>2</sup> | 1 | |
| 插入排序 | √ |  N \~ N<sup>2</sup> | 1 | 时间复杂度和初始顺序有关 |
| 希尔排序 | ×  |  N 的若干倍乘于递增序列的长度 | 1 | |
| 快速排序 | ×  | NlogN | logN | |
| 三向切分快速排序 | ×  |  N \~ NlogN | logN | 适用于有大量重复主键|
| 归并排序 | √ |  NlogN | N | |
| 堆排序 | ×  |  NlogN | 1 | |
| 桶排序 | √  | N | N | |

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 \~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

## 归并排序

以size()==1作为出栈的时间

![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/0fb12ef1a799ee8034ea4e4344cf6e57.png)

```c++

int mergesort1(vector<int> &v);
int mergesort(vector<int> &v) {
	if (v.size() == 0) {
		for (int i = 0; i < 14; i++) {
			v.push_back(22-i);
		}
	}
	mergesort1(v);
	return 0;
}
int mergesort1(vector<int> &v) {
	if (v.size() > 1) {
		int mid = v.size() / 2;
		vector<int> v1(v.begin(), v.begin() + mid);
		vector<int> v2(v.begin() + mid, v.end());
		mergesort1(v1);
		mergesort1(v2);
		int i1 = 0, i2 = 0, i = 0;
		while (i1 < v1.size() && i2 < v2.size()) {
			if (v1[i1] < v2[i2]) {
				v[i++] = v1[i1];
				i1++;
			}
			else {
				v[i++] = v2[i2];
				i2++;
			}
		}
		if (i1 == v1.size()) {
			while (i2 < v2.size()) {
				v[i++] = v2[i2];
				i2++;
			}
		}
		else {
			while (i1 < v1.size()) {
				v[i++] = v1[i1];
				i1++;
			}
		}
	}
	return 0;
}
int main() {
	//cout << fibonacci2(8) << endl;
	//cout << fibonacci1(8) << endl;
	vector<int> v;
	mergesort(v);
	for (int i = 0; i < v.size(); i++) {
		cout << v[i] << endl;
	}
}

```


## 快速排序

以l==r作为出栈入口


![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/c0d12584a464f8614841dfa4e51b065b.png)

```c++

int partition(vector<int> &v, int left, int right) {
	int p = v[left];
	while (left < right) {
		while (left<right&&v[right]>p) right--;
		if (left < right) {
			v[left] = v[right];
			left++;
		}
		while (left < right&&v[left] < p) left++;
		if (left < right) {
			v[right] = v[left];
			right--;
		}
	}
	v[left] = p;
	return left;
}
void quicksort1(vector<int> &v, int left, int right) {
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << endl;

	if (left < right) {
		int r = partition(v, left,right);
		quicksort1(v, left, r-1);
		quicksort1(v, r + 1, right);
	}
	return;

}
void quicksort(vector<int> &v) {
	quicksort1(v, 0, v.size() - 1);
}
int main() {
	//cout << fibonacci2(8) << endl;
	//cout << fibonacci1(8) << endl;
	//vector<int> v;
	//mergesort(v);
	//for (int i = 0; i < v.size(); i++) {
	//	cout << v[i] << endl;
	//}
	vector<int> v = { 2,3,6,9,1,4,5 };
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << endl;

	//cout << partition(v,0,v.size()-1) << endl;
	quicksort(v);
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}

}

```

```c++
int partition(vector<int> &v, int left, int right) {
	int p = v[left];
	while (left < right) {
		while (left<right&&v[right]>p) right--;
		if(left<right) v[left++] = v[right];
		while (left < right&&v[left] < p) left++;
		if (left < right) v[right--] = v[left];
	}
	v[left] = p;
	return left;
}
int quicksort(vector<int>&v, int left, int right) {
	if (left < right) {
		int r = partition(v, left, right);
		quicksort(v, left, r - 1);
		quicksort(v, r + 1, right);
	}
	return 0;
}
```

### 算法改进
（一）切换到插入排序

因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。

（二）三数取中

最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。

（三）三向切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序。
```c++
public class ThreeWayQuickSort<T extends Comparable<T>> extends QuickSort<T> {
    @Override
    protected void sort(T[] nums, int l, int h) {
        if (h <= l)
            return;
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i <= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp < 0)
                swap(nums, lt++, i++);
            else if (cmp > 0)
                swap(nums, i, gt--);
            else
                i++;
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}
```

### 快速排序找第k小

#### 自己写的
改造于快排，记得是if(left<right)

```c++
#include<iostream>
#include<vector>
using namespace std;

int partition(vector<int> &v, int left, int right) {
	int p = v[left];
	while (left < right) {
		while (left<right&&v[right]>p) right--;
		if (left < right) {
			v[left] = v[right];
			left++;
		}
		while (left < right&&v[left] < p) left++;
		if (left < right) {
			v[right] = v[left];
			right--;
		}
	}
	v[left] = p;
	return left;
}
//第k小
int k, res;

void quicksort1(vector<int> &v, int left, int right) {
	//for (int i = 0; i < v.size(); i++) {
	//	cout << " " << v[i];
	//}
	//cout << endl;

	//if (left < right) {
	//	int r = partition(v, left, right);
	//	quicksort1(v, left, r - 1);
	//	quicksort1(v, r + 1, right);
	//}

	//mfl modefied
	//求第k小
	if (left <= right) {
		int r = partition(v, left, right);
		cout << "KKKK" << "   " << r << endl;
		if (r == k) {
			
			res = v[k];
			return;
		}
		if (r < k) {
			quicksort1(v, r + 1, right);
		}
		else {
			quicksort1(v, left, r - 1);
		}
	}
	return;

}
void quicksort(vector<int> &v) {
	quicksort1(v, 0, v.size() - 1);
}
int main() {
	//cout << fibonacci2(8) << endl;
	//cout << fibonacci1(8) << endl;
	//vector<int> v;
	//mergesort(v);
	//for (int i = 0; i < v.size(); i++) {
	//	cout << v[i] << endl;
	//}
	vector<int> v = { 2,3,6,9,1,4,5 };
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << endl;
	cin >> k;

	//cout << partition(v,0,v.size()-1) << endl;
	quicksort(v);
	for (int i = 0; i < v.size(); i++) {
		cout << " " << v[i];
	}
	cout << res << endl;
}
```

#### 网上参考
```c++
#include<stdio.h>
#include<stdlib.h>
/* 如何查找第k小的数，或者第k大的数*/
partition(int data[],size_t left ,size_t right)
{
     int i = left;
     int j = right;
     int p = (left + right) / 2;
     int pivot = data[p];
     while(i < j){
         for(; i < p && data[i] <= pivot;++i);
         if(i < p) {
             data[p] = data[i];
             p = i;
         }
         for(; j > p && data[j] >= pivot; --j);
         if( j > p){
             data[p] = data[j];
             p = j;
         }
     }
       data[p] = pivot;
       return p;

}
int quick_sort(int data[],size_t left, size_t right)
{
    if(left < right){
        int index = partition(data,left,right);
        if(index - left > 1 )  
            quick_sort(data,left, index-1);
        if(right - index > 1)
            quick_sort(data,index + 1, right);
    
    }

}
int findK(int data[], size_t left, size_t right, size_t k){
   if(left < right){
       int mid = partition(data,left, right);
       if(mid - left + 1 >= k)
           findK(data,left, mid, k );
       else 
           findK(data, mid + 1, right, k- (mid - left +1));
   }
   
}
int main()
{
    int data[] = {12,2,1 ,0 ,4,11,-1, 9 ,6};
    int len = sizeof(data)/sizeof(data[0]);
  //  quick_sort(data,0,len - 1);
    int i =0;
  /* 打印原始序列 */
    for( i = 0; i < len ; ++i)
    {
        printf(" %d ",data[i]);
    }
     findK(data,0,len - 1, 5);
    printf("x = %d\n", data[5] );
   /* 找到第k个大的数后，序列的变化为：---快排之前*/
    for( i = 0; i < len ; ++i)
    {
        printf(" %d ",data[i]);
    }
    printf("\n");
  /* 快排之后的序列*/
    quick_sort(data,0,len - 1);
    for( i = 0; i < len ; ++i)
    {
        printf(" %d ",data[i]);
    }
    printf("\n");

}
```

https://mafulong.top/offer/2018/05/21/347.-Top-K-Frequent-Elements.html)

## 选择排序

```java
public class Selection<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++)
                if (less(nums[j], nums[min]))
                    min = j;
            swap(nums, i, min);
        }
    }
}
```

## 插入排序

```c++
void insertSort(vector<int> &v) {
	int n = v.size();
	for (int i = 0; i < n; i++) {
		int t = v[i],j=i-1;
		for (j = i - 1; j >= 0 && v[j] > t; j--) {
			v[j + 1] = v[j];
		}
		v[j + 1] = t;
	}
}

void insertsort(vector<int> &d) {
	int n = d.size();
	for (int i = 1; i < n; i++) {
		for (int j = i; j > 0 && d[j] < d[j - 1]; j--) {
			swap(d[j], d[j - 1]);
		}
	}
}


int main()
{
	vector<int> v = { 3,2,1,4,5,8,3,5,5 };
	insertSort(v);
	for (auto it : v) {
		cout << it << " ";
	}
	return 0;
}
```


## 希尔排序
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

第二个for循环是插入排序

插入排序中就有外边的总的遍历，也就是第二个for循环，然后第三个for循环实现插入排序的找插入位置

```c++
void shellsort(vector<int> &v) {
	for (int d = v.size() / 2; d > 0; d /= 2) {
		for (int i = d; i < v.size(); i++) {
			for (int j = i - d; j >= 0 && v[j] > v[j + d]; j -= d) {
				swap(v[j], v[j + d]);
			}
		}
	}
}

int main() {
	vector<int> v = { 3,1,3,2,4,8,5,6,9 };
	shellsort(v);
	for (auto it : v) {
		cout << it << endl;
	}
	return 0;
}
```

```java
    public static void sort(Comparable[] a){
        int n=a.length;
        for(int gap=n/2;gap>0;gap/=2){
            for(int i=gap;i<n;i++){
                for(int j=i;j>=gap&&less(a[j],a[j-gap]);j-=gap){
                    swap(a,j,j-gap);
                }
            }
        }
    }
```


```c++
void shellsort3(int a[], int n)
{
	int i, j, gap;
 
	for (gap = n / 2; gap > 0; gap /= 2)
		for (i = gap; i < n; i++)
			for (j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap)
				Swap(a[j], a[j + gap]);
}
```

## 堆排序
#### 时间复杂度
建堆：O(n); 更新堆： O(nlogn)

#### 由于是完全二叉树, 故有:
```
PARENT(i)
  return i / 2
LEFT(i)
  return 2 * i
RIGHT(i)
  2 * i + 1
```

### 建堆
##### 对非叶子节点形成堆，伪代码：
```
//
MAX-HEAPIFY(A, i)

l = LIFT(i)
r = RIGHT(i)
if l <= A.heapsize and A[l] > A[i]
  largest = l
else largest = i
if r <= A.heapsize and A[r] > A[largest]
  largest = r
if largest != i
  exchage A[i] with A[largest]
  MAX-HEAPIFY(A, largest)
```

#### Build Heap 

以最大堆为例，伪代码：
```

BUILD-MAX-HEAP(A)：

A.heap-size = A.length
for A.length / 2 downto 1
  MAX-HEAPIFY(A, i)
```

### 堆排序
以最大堆为例，伪代码：
```

HEAPSORT(A) ：
BUILD-MAX-HEAP(A)

for i = A.length downto 2
  exchange A[1] with A[i]
  A.heap-size = A.heap-size - 1
  MAX-HEAPIFY(A, 1)
```

#### c++代码
```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

void adjust(int arr[], int len, int index)
{
    int left = 2*index + 1;
    int right = 2*index + 2;
    int maxIdx = index;
    if(left<len && arr[left] > arr[maxIdx]) maxIdx = left;
    if(right<len && arr[right] > arr[maxIdx]) maxIdx = right;  // maxIdx是3个数中最大数的下标
    if(maxIdx != index)                 // 如果maxIdx的值有更新
    {
        swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);       // 递归调整其他不满足堆性质的部分
    }

}
void heapSort(int arr[], int size)
{
    for(int i=size/2 - 1; i >= 0; i--)  // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)
    {
        adjust(arr, size, i);
    }
    for(int i = size - 1; i >= 1; i--)
    {
        swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
        adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序
    }
}

int main()
{
    int array[8] = {8, 1, 14, 3, 21, 5, 7, 10};
    heapSort(array, 8);
    for(auto it: array)
    {
        cout<<it<<endl;
    }
    return 0;
}
```

```python
def maxHeap(data: List[int], length, i):
    left = 2 * i + 1
    right = 2 * i + 2
    largest = i
    if left < length and data[left] > data[largest]:
        largest = left
    if right < length and data[right] > data[largest]:
        largest = right
    if largest != i:
        data[largest], data[i] = data[i], data[largest]
        maxHeap(data, length, largest)


def headTest(data):
    # 建堆
    for i in range(len(data) // 2 - 1, -1, -1):
        maxHeap(data, len(data), i)
    for i in range(len(data)-1, 0, -1):
        # 最大的放在末尾
        data[i], data[0] = data[0], data[i]
        maxHeap(data, i, 0)
    print(data)
```

### 堆的插入

堆是完全二叉树，索引是按2i, 2i+1索引的，一层一层存的，因此新插入元素一定在最后一个。

然后将这个值与父元素比较，如果不满足大顶堆小顶堆规则，则与父元素替换（如下图所示）。

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/20210129130827.png)

也就是上浮

```java
private void swim(int k) {
    while (k > 1 && less(k / 2, k)) {
        swap(k / 2, k);
        k = k / 2;
    }
}
```

将新元素放到数组末尾，然后上浮到合适的位置。

```
public void insert(Comparable v) {
    heap[++N] = v;
    swim(N);
}
```

## 冒泡排序

```c++
void bubbleSort(vector<int>& d) {
	for (int i = 0; i < d.size(); i++) {
		bool isT = true;
		for (int j = 0; j < d.size() - i - 1; j++) {
			if (d[j] > d[j + 1]) {
				swap(d[j], d[j + 1]);
				isT = false;
			}
		}
		if (isT) {
			return;
		}
	}
}
```

## 桶排序

桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。

就是利用数组的索引记录每个元素的出现次数，然后遍历数组就好了

衍生的，就是求出现次数高低的那种题目，就是倒过来，就是记录每个元素m的出现次数n,然后book[n].add(m)，然后再遍历book[]数组就是每个元素出现次数的高低啦，比如这道题目[347. Top K Frequent Elements](

## 计数排序vs基数排序vs桶排序

### 从计数排序说起

计数排序是一种非基于元素比较的排序算法，而是将待排序数组元素转化为计数数组的索引值，从而间接使待排序数组具有顺序性。

计数排序的实现一般有两种形式：基于辅助数组和基于桶排序。

#### 基于辅助数组

整个过程包含三个数组：待排序数组A、计数数组B和输出数组C。

简单来说，就是通过统计待排序数组A中元素不同值的分布直方图，生成计数数组B，然后计算计数数组B的前缀和(此步操作可以看成计算待排序数组A中每个元素的位置信息)，最后通过逆序循环将元素对应赋值到输出数组C中，输出数组C即是最终排序结果。


#### 基于桶排序

其实就是用桶排序来维护稳定性，因为在每个桶中的元素是以队列结构排序的，可以维护元素的顺序。

主要步骤：

    1. 按元素的最大健值与最小健值之差来创建指定数量的桶，并在每个桶中创建一个队列。
    2. 按顺序遍历待排序数组，将它们放到对应桶的队列中。
    3. 按桶编号顺序进行遍历，将每个桶中队列按顺序输出回原数组中。

#### 计数排序的不足

可以看到辅助数组的长度和桶的数量由最大值和最小值决定，假如两者之差很大，而待排序数组又很小，那么就会导致辅助数组或桶大量浪费。

### 基数排序

基数排序改善了计数排序，简单来说，基数排序算法就是将整数或字符串切分成不同的数字或字符，然后按对应位置的数或字符分别进行比较，这样就能将辅助数组或桶的数量降低到一个较小的值，经过多轮排序后得到最终的排序结果。

比如下面对于十进制的数值比较，只需要10个桶即可，但要保证每个桶能放得进所有元素。

第一阶段：针对个位数将元素放到对应的桶中。

第二阶段：针对十位数将元素放到对应的桶中。

第三阶段：针对百位数将元素放到对应的桶中。

最终按照桶顺序输出得到排序结果。

### 桶排序

桶排序是改善计数排序的方法之一，其基本思想是将待排序数组分配到若干个桶内，然后每个桶内再各自进行排序，桶内的排序可以使用不同的算法，比如插入排序或快速排序，属于分治法。每个桶执行完排序后，最后依次将每个桶内的有序序列拿出来，即得到完整的排序结果。

待排序数组的最大元素与最小元素分别为19和1，那么总的范围区间可定义为[0,19]，假设用4个桶，则桶的区间分别为`[0,4][5,9][10,14][15,19]`。可以看到桶的数量可以控制在很小的范围内，而且桶的容量大小可以动态扩充。

按照值将元素放到对应桶内。

按照桶顺序将元素依次输出得到排序结果。

### 总结

  * 基数排序和桶排序可以看成是计数排序的泛化版本，使用了某些措施优化排序过程。
  * 在桶排序中当桶的个数取最大值(max-min+1)的时候，就变成了计数排序，所以计数排序时桶排序的一种特例。
  * 基数排序可以看做是多轮桶排序，基数排序以有效位的角度，每个有效位都进行一轮桶排序。
  * 当用最大值作为基数时，基数排序就退化成了计数排序。