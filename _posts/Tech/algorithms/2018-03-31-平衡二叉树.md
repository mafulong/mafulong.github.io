---
layout: post
category: Algorithms
title: 平衡二叉树、红黑树、B、B+
tags: Algorithms
---

## 平衡二叉树
### 定义
平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

平衡因子(bf)：结点的左子树的深度减去右子树的深度，那么显然-1<=bf<=1

失去平衡的最小子树是指以离插入结点最近，且平衡因子绝对值大于1的结点作为根的子树。假设用A表示失去平衡的最小子树的根结点，则调整该子树的操作可归纳为下列四种情况。

当对一颗AVL树进行插入操作，可能会导致AVL树不平衡，此时，我们就需要做平衡处理，假设重新平衡的节点为Q，则不平衡会下列四种情况，并做出调整

在Q的左孩子的左子树插入 （LL）

在Q的左孩子的右子树插入 （LR）

在Q的右孩子的左子树插入  （RL）

在Q的右孩子的右子树插入  （RR）


#### 参考文章
[文章链接](https://blog.csdn.net/lpp0900320123/article/details/39367451#t4)

### 平衡处理

#### 左平衡
所谓左平衡处理，就是某一根结点的左子树比右子树过高，从而失去了平衡。在节点的左子树进行插入操作使此节点失去平衡，需要左平衡处理。

#### 右平衡
类似左平衡处理，所谓右平衡处理，就是某一根结点的右子树比左子树过高，从而失去了平衡。

#### LL
![](https://i.imgur.com/lZEiG6n.png)

思路：先把B的右子树变为A的左子树，在把A作为B的右子树

#### RR
![](https://i.imgur.com/lj3zIun.png)

思路：先把C的左子树作为A的右子树，在把A作为C的左子树。

#### LR
![](https://i.imgur.com/Fu6ROyB.png)

先将A结点的左孩子B的右子树的根结点D向左上旋转提升到B结点的位置，然后再把该D结点向右上旋转提升到A结点的位置。即先使之成为LL型，再按LL型处理。

如图中所示，先将圈圈的部分进行逆时针旋转（RR旋转），使之转换为LL型，再进行LL旋转；（双旋转）

#### RL
![](https://i.imgur.com/lbZGKBG.png)

如图中所示，先将圈圈的部分进行顺时针旋转（LL旋转），使之转换为RR型，再进行RR旋转；（双旋转）

### 代码
```c++
#include<algorithm>
#include<iostream>
#include<stdio.h>
#include<string>
#include<vector>
#include<queue>
using namespace std;


struct t
{
	int data;
	t *left, *right;
	int height;
	t() :data(0), left(NULL), right(NULL), height(0) {

	}
	t(int data1) :data(data1), left(NULL), right(NULL), height(0) {
	}
};
int nodeheight(t *node) {
	return node == NULL ? -1 : node->height;
}
int updateHeight(t *node) {
	//cout << "new height  " << node->data << "  " << max(nodeheight(node->left), nodeheight(node->right)) + 1 << endl;;
	return max(nodeheight(node->left), nodeheight(node->right)) + 1;
}
void LL(t *&node) {
	if (node) {
		t *p = node->left;
		node->left = p->right;
		updateHeight(node);
		p->right = node;
		updateHeight(p);
		node = p;
	}

}
void RR(t *&node) {
	if (node) {
		t *p = node->right;
		node->right = p->left;
		updateHeight(node);
		p->left = node;
		updateHeight(p);
		node = p;
	}
}
void LR(t *&node) {
	if (node) {
		RR(node->left);
		LL(node);
	}
}
void RL(t *&node) {
	if (node) {
		LL(node->right);
		RR(node);
	}
}
void LeftBalance(t *&node) {
	cout << "leftBalance  " << node->data << endl;
	t *p = node->left;
	if (nodeheight(p->left) < nodeheight(p->right)) {
		LR(node);
	}
	else {
		LL(node);
	}
}
void RightBalance(t *&node) {

	//cout << "rightBalance   " << node->data << endl;
	t *p = node->right;
	if (nodeheight(p->left) > nodeheight(p->right)) {
		RL(node);
	}
	else {
		RR(node);
	}
}
void insertNode(t *&node,int data) {

	if (!node) {
		node = new t(data);
	}
	else if (data < node->data) {
		//cout << node->data <<" left: "<<data<< endl;
		insertNode(node->left, data);
		if (nodeheight(node->left) - nodeheight(node->right) == 2) {
			LeftBalance(node);
		}
	}
	else if (data > node->data) {
		//cout << node->data << " right: " << data << endl;

		insertNode(node->right, data);
		if (nodeheight(node->left) - nodeheight(node->right) == -2) {
			RightBalance(node);
		}
	}
	else
		cout<<node->data << "重复插入" << endl;
	node->height=updateHeight(node);
}
void deleteNode(t *&node,int data) {
	if (!node) {
		return;
	}
	if (data > node->data) {
		deleteNode(node->right, data);
		if (nodeheight(node->left) - nodeheight(node->right) == 2) {
			LeftBalance(node);
		}
	}
	else if (data < node->data) {
		deleteNode(node->left, data);
		if (nodeheight(node->right) - nodeheight(node->left) == 2) {
			RightBalance(node);
		}
	}
	else {
		if (!node->left) {
			t *p = node;
			node = node->right;
			delete p;
		}
		else if (!node->right) {
			t *p = node;
			node = node->left;
			delete p;
		}
		else {
			t *p = node->left;
			while (p->right) {
				p = p->right;
			}
			node->data = p->data;
			deleteNode(node->left, p->data);
		}
	}
}
t* createTree(vector<int> v) {
	t *root = NULL;
	for (int i = 0; i < v.size(); i++) {
		insertNode(root,v[i]);
	}
	return root;
}
void visitlvr(t *root) {
	if (root != NULL) {
		visitlvr(root->left);
		cout << root->data << " ";
		visitlvr(root->right);
	}
}
void visitvlr(t *root) {
	if (root != NULL) {
		cout << root->data << " ";
		visitvlr(root->left);
		visitvlr(root->right);
	}
}
void visitlrv(t *root) {
	if (root != NULL) {
		visitlrv(root->left);
		visitlrv(root->right);
		cout << root->data << " ";
	}
}
void visitTree(t *tree) {
	visitlvr(tree);
	cout << endl;
	visitvlr(tree);
	cout << endl;
	visitlrv(tree);
	cout << endl;
}
int main() {
	freopen("D:/in.txt", "r", stdin);

	vector<int> v;
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int a;
		cin >> a;
		v.push_back(a);
	}
	t *tree = createTree(v);
	visitTree(tree);
	deleteNode(tree, 7);
	visitTree(tree);
	//visitTree(tree);
	return 0;
}
```

## 2-3查找树

#### 定义
一棵2-3查找树或为一颗空树，或由以下节点组成：

- 2-节点：含有一个键和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点。
- 3-节点：含有两个键和三条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点。

### 查找

对于查找操作和二叉查找树基本相同，递归比较要查找的键和树的根节点，小于就向左继续查找，大于就向右查找，相等就查找命中。不同的就是对于3节点，还要有中间节点的情况，在三节点两个键的大小之间的情况，要向中间子树递归。最后如果查找到叶节点的空连接就直接返回null。

### 插入

2-3树的插入相对来说是比较复杂的，因为它是保证树本身平衡性的关键。我们分几种情况来论述。

#### 向2节点插入

插入先是要查找，查找到了就直接更新，如果未命中就插入新元素，插入新元素一定是在叶节点的空连接上，如果叶节点是一个2节点，那么就直接插入，让特们合成一个3节点。显然这时树高没有变化。示意图如下  
![这里写图片描述](https://img-blog.csdn.net/20171026214342266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVvbmxpdTE5OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  

这就是向一个2节点插入的情况。

#### 向3节点插入

![这里写图片描述](https://img-blog.csdn.net/20171026214555076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVvbmxpdTE5OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  

假如向一个3节点中插入，我们首先可以做的是像2节点一样把他们暂时合在一起形成一个4节点（有三个元素），然后再对这个4节点进行分解，将中间的元素插入他们的父元素剩下两个元素变成两个2节点。注意：
**只能是中间的元素拿上去，因为这样才能保证树的有序性，即左边和右边的元素相对于根元素的大小关系**
，然后再考察父节点，如父节点原来是一个2节点，那么此时直接插入将其变成一个3节点，插入操作就完成了。如果原来父节点就是一个3节点，那么依然可以再重复这个过程，不断将中间元素加入父节点，如果这个过程持续到了根节点，那么我们就分裂形成的一个暂时的4节点的根节点，得到三个2节点，同时整个的树高增加1。

![这里写图片描述](https://img-blog.csdn.net/20171026220015987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVvbmxpdTE5OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 

**上图为根节点分裂的示意图**

这种插入相当于把元素插入这个会引起树的高度变化的不利因素放在3节点中储存起来，随着3节点的插入将这种不利因素不断传导至根节点，然后通过根节点的分裂将整个的树高加1，可以看出，3节点以及相关的插入方法是保证平衡性的关键，也可以看出2-3树的生长是从下往上通过根节点生长的。
**2-3树就可以实现在最坏条件下也有对数性能。**

#### 2. 性质
2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。

2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。

2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。

## 红黑树

参考下一篇blog哈

## B-tree B+-tree B*-tree

### B-tree
B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，B-tree就是指的B树。特此说明。

B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作

#### 用阶定义的B树

B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：

![](http://hi.csdn.net/attachment/201112/18/0_1324205685teT7.gif)

### B+-tree
B+-tree：是应文件系统所需而产生的一种B-tree的变形树。

一棵m阶的B+树和m阶的B树的异同点在于：

1. 有n棵子树的结点中含有n-1 个关键字
2. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

#### 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？

个人觉得这两个原因都不是主要原因。数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作

**1) B+-tree的磁盘读写代价更低**

B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

**2) B+-tree的查询效率更加稳定**

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### B*-tree

是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，树中非根和非叶子结点再增加指向兄弟的指针；定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示：

![](http://hi.csdn.net/attachment/201106/7/8394323_13074405869mSW.jpg)

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。

所以，B*树分配新结点的概率比B+树要低，空间使用率更高；

## 插入删除操作
![](http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif)

## R树：处理空间存储问题
R树在数据库等领域做出的功绩是非常显著的。它很好的解决了在高维空间搜索等问题。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌地图这种超大数据库中，这种方法便必定不可行了。

R树就很好的解决了这种高维空间搜索问题。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。

如上所述，R树是B树在高维空间的扩展，是一棵平衡树。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高

R树运用了空间分割的理念，这种理念是如何实现的呢？R树采用了一种称为MBR(Minimal Bounding Rectangle)的方法，在此我把它译作“最小边界矩形”。从叶子结点开始用矩形（rectangle）将空间框起来，结点越往上，框住的空间就越大，以此对空间进行分割。有点不懂？没关系，继续往下看。在这里我还想提一下，R树中的R应该代表的是Rectangle（此处参考wikipedia上关于R树的介绍），而不是大多数国内教材中所说的Region（很多书把R树称为区域树，这是有误的）。

先来探究一下叶子结点的结构。叶子结点所保存的数据形式为：(I, tuple-identifier)。

其中，tuple-identifier表示的是一个存放于数据库中的tuple，也就是一条记录，它是n维的。I是一个n维空间的矩形，并可以恰好框住这个叶子结点中所有记录代表的n维空间中的点。I=(I0,I1,…,In-1)。