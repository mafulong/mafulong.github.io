---
layout: post
category: Algorithms
title: 平衡二叉树
tags: Algorithms
---

## 平衡二叉树
### 定义
平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

平衡因子(bf)：结点的左子树的深度减去右子树的深度，那么显然-1<=bf<=1

失去平衡的最小子树是指以离插入结点最近，且平衡因子绝对值大于1的结点作为根的子树。假设用A表示失去平衡的最小子树的根结点，则调整该子树的操作可归纳为下列四种情况。

当对一颗AVL树进行插入操作，可能会导致AVL树不平衡，此时，我们就需要做平衡处理，假设重新平衡的节点为Q，则不平衡会下列四种情况，并做出调整

在Q的左孩子的左子树插入 （LL）

在Q的左孩子的右子树插入 （LR）

在Q的右孩子的左子树插入  （RL）

在Q的右孩子的右子树插入  （RR）


#### 参考文章
[文章链接](https://blog.csdn.net/lpp0900320123/article/details/39367451#t4)

### 平衡处理

#### 左平衡
所谓左平衡处理，就是某一根结点的左子树比右子树过高，从而失去了平衡。在节点的左子树进行插入操作使此节点失去平衡，需要左平衡处理。

#### 右平衡
类似左平衡处理，所谓右平衡处理，就是某一根结点的右子树比左子树过高，从而失去了平衡。

#### LL
![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/3fcdba83c5c99a34a0114cc1b8759229.png)

思路：先把B的右子树变为A的左子树，在把A作为B的右子树

#### RR
![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/874eca786970a45eab68ab3094a8ea1a.png)

思路：先把C的左子树作为A的右子树，在把A作为C的左子树。

#### LR
![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/44873ea4bc9bffe7dffaeb01864102ad.png)

先将A结点的左孩子B的右子树的根结点D向左上旋转提升到B结点的位置，然后再把该D结点向右上旋转提升到A结点的位置。即先使之成为LL型，再按LL型处理。

如图中所示，先将圈圈的部分进行逆时针旋转（RR旋转），使之转换为LL型，再进行LL旋转；（双旋转）

#### RL
![image-20210123112856952](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/typora/20210123112856.png)

如图中所示，先将圈圈的部分进行顺时针旋转（LL旋转），使之转换为RR型，再进行RR旋转；（双旋转）

### 代码
```c++
#include<algorithm>
#include<iostream>
#include<stdio.h>
#include<string>
#include<vector>
#include<queue>
using namespace std;


struct t
{
	int data;
	t *left, *right;
	int height;
	t() :data(0), left(NULL), right(NULL), height(0) {

	}
	t(int data1) :data(data1), left(NULL), right(NULL), height(0) {
	}
};
int nodeheight(t *node) {
	return node == NULL ? -1 : node->height;
}
int updateHeight(t *node) {
	//cout << "new height  " << node->data << "  " << max(nodeheight(node->left), nodeheight(node->right)) + 1 << endl;;
	return max(nodeheight(node->left), nodeheight(node->right)) + 1;
}
void LL(t *&node) {
	if (node) {
		t *p = node->left;
		node->left = p->right;
		updateHeight(node);
		p->right = node;
		updateHeight(p);
		node = p;
	}

}
void RR(t *&node) {
	if (node) {
		t *p = node->right;
		node->right = p->left;
		updateHeight(node);
		p->left = node;
		updateHeight(p);
		node = p;
	}
}
void LR(t *&node) {
	if (node) {
		RR(node->left);
		LL(node);
	}
}
void RL(t *&node) {
	if (node) {
		LL(node->right);
		RR(node);
	}
}
void LeftBalance(t *&node) {
	cout << "leftBalance  " << node->data << endl;
	t *p = node->left;
	if (nodeheight(p->left) < nodeheight(p->right)) {
		LR(node);
	}
	else {
		LL(node);
	}
}
void RightBalance(t *&node) {

	//cout << "rightBalance   " << node->data << endl;
	t *p = node->right;
	if (nodeheight(p->left) > nodeheight(p->right)) {
		RL(node);
	}
	else {
		RR(node);
	}
}
void insertNode(t *&node,int data) {

	if (!node) {
		node = new t(data);
	}
	else if (data < node->data) {
		//cout << node->data <<" left: "<<data<< endl;
		insertNode(node->left, data);
		if (nodeheight(node->left) - nodeheight(node->right) == 2) {
			LeftBalance(node);
		}
	}
	else if (data > node->data) {
		//cout << node->data << " right: " << data << endl;

		insertNode(node->right, data);
		if (nodeheight(node->left) - nodeheight(node->right) == -2) {
			RightBalance(node);
		}
	}
	else
		cout<<node->data << "重复插入" << endl;
	node->height=updateHeight(node);
}
void deleteNode(t *&node,int data) {
	if (!node) {
		return;
	}
	if (data > node->data) {
		deleteNode(node->right, data);
		if (nodeheight(node->left) - nodeheight(node->right) == 2) {
			LeftBalance(node);
		}
	}
	else if (data < node->data) {
		deleteNode(node->left, data);
		if (nodeheight(node->right) - nodeheight(node->left) == 2) {
			RightBalance(node);
		}
	}
	else {
		if (!node->left) {
			t *p = node;
			node = node->right;
			delete p;
		}
		else if (!node->right) {
			t *p = node;
			node = node->left;
			delete p;
		}
		else {
			t *p = node->left;
			while (p->right) {
				p = p->right;
			}
			node->data = p->data;
			deleteNode(node->left, p->data);
		}
	}
}
t* createTree(vector<int> v) {
	t *root = NULL;
	for (int i = 0; i < v.size(); i++) {
		insertNode(root,v[i]);
	}
	return root;
}
void visitlvr(t *root) {
	if (root != NULL) {
		visitlvr(root->left);
		cout << root->data << " ";
		visitlvr(root->right);
	}
}
void visitvlr(t *root) {
	if (root != NULL) {
		cout << root->data << " ";
		visitvlr(root->left);
		visitvlr(root->right);
	}
}
void visitlrv(t *root) {
	if (root != NULL) {
		visitlrv(root->left);
		visitlrv(root->right);
		cout << root->data << " ";
	}
}
void visitTree(t *tree) {
	visitlvr(tree);
	cout << endl;
	visitvlr(tree);
	cout << endl;
	visitlrv(tree);
	cout << endl;
}
int main() {
	freopen("D:/in.txt", "r", stdin);

	vector<int> v;
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int a;
		cin >> a;
		v.push_back(a);
	}
	t *tree = createTree(v);
	visitTree(tree);
	deleteNode(tree, 7);
	visitTree(tree);
	//visitTree(tree);
	return 0;
}
```

## 2-3查找树

#### 定义
一棵2-3查找树或为一颗空树，或由以下节点组成：

- 2-节点：含有一个键和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点。
- 3-节点：含有两个键和三条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点。

### 查找

对于查找操作和二叉查找树基本相同，递归比较要查找的键和树的根节点，小于就向左继续查找，大于就向右查找，相等就查找命中。不同的就是对于3节点，还要有中间节点的情况，在三节点两个键的大小之间的情况，要向中间子树递归。最后如果查找到叶节点的空连接就直接返回null。

### 插入

2-3树的插入相对来说是比较复杂的，因为它是保证树本身平衡性的关键。我们分几种情况来论述。

#### 向2节点插入

插入先是要查找，查找到了就直接更新，如果未命中就插入新元素，插入新元素一定是在叶节点的空连接上，如果叶节点是一个2节点，那么就直接插入，让特们合成一个3节点。显然这时树高没有变化。示意图如下  
![这里写图片描述](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/b3918c58e36e7cf2f88722c5148d819f.png)  

这就是向一个2节点插入的情况。

#### 向3节点插入

![这里写图片描述](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/1053f3b5830a3bd91b36c00a0775f86a.png)  

假如向一个3节点中插入，我们首先可以做的是像2节点一样把他们暂时合在一起形成一个4节点（有三个元素），然后再对这个4节点进行分解，将中间的元素插入他们的父元素剩下两个元素变成两个2节点。注意：
**只能是中间的元素拿上去，因为这样才能保证树的有序性，即左边和右边的元素相对于根元素的大小关系**
，然后再考察父节点，如父节点原来是一个2节点，那么此时直接插入将其变成一个3节点，插入操作就完成了。如果原来父节点就是一个3节点，那么依然可以再重复这个过程，不断将中间元素加入父节点，如果这个过程持续到了根节点，那么我们就分裂形成的一个暂时的4节点的根节点，得到三个2节点，同时整个的树高增加1。

![这里写图片描述](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/0b36d6a28af3bb81af89db4f36a5f577.png) 

**上图为根节点分裂的示意图**

这种插入相当于把元素插入这个会引起树的高度变化的不利因素放在3节点中储存起来，随着3节点的插入将这种不利因素不断传导至根节点，然后通过根节点的分裂将整个的树高加1，可以看出，3节点以及相关的插入方法是保证平衡性的关键，也可以看出2-3树的生长是从下往上通过根节点生长的。
**2-3树就可以实现在最坏条件下也有对数性能。**

#### 2. 性质
2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。

2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。

2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。



