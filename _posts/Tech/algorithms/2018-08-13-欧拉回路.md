---
layout: post
category: Algorithms
title: 欧拉回路
tags: Algorithms
---

## 欧拉回路定义及判断
如果能从图的某一顶点出发，每条边恰好经过一次，这样的路线称为欧拉道路(Eulerian Path)。

如果每条边恰好经过一次，且能回到起点，这样的路线称为欧拉回路(Eulerian Circuit)。

对于无向图G，当且仅当G 是连通的，且最多有两个奇点，则存在欧拉道路。

如果有两个奇点，则必须从其中一个奇点出发，到另一个奇点终止。

如果没有奇点，则一定存在一条欧拉回路。

对于有向图G，当且仅当G 是连通的，且每个点的入度等于出度，则存在欧拉回路。

如果有两个顶点的入度与出度不相等，且一个顶点的入度比出度小1，另一个顶点的入度比出度大1，此时，存在一条欧拉道路，以前一个顶点为起点，以后一个顶点为终点





- 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。
- 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。
- 具有欧拉回路的无向图称为欧拉图。
- 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。



判别这张图是否是欧拉图或者半欧拉图，具体地：

- 对于无向图 G*G*，G*G* 是欧拉图当且仅当 G*G* 是连通的且没有奇度顶点。
- 对于无向图 G*G*，G*G* 是半欧拉图当且仅当 G*G* 是连通的且 G*G* 中恰有 22 个奇度顶点。
- 对于有向图 G*G*，G*G* 是欧拉图当且仅当 G*G* 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。
- 对于有向图 G*G*，G*G* 是半欧拉图当且仅当 G*G* 的所有顶点属于同一个强连通分量且
  - 恰有一个顶点的出度与入度差为 11；
  - 恰有一个顶点的入度与出度差为 11；
  - 所有其他顶点的入度和出度相同。



参考： https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/

## OJ题目
[10054 - The Necklace](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=995)

题意：一根项链由小珠子连成，小珠子左部分是一个颜色，右半部分是一个颜色（两部分的颜色可同可不同），两个相连珠子的连接部分的颜色相同，现在项链散了，给出N个小珠子左右两部分的颜色，问这N个小珠子能否组成一条满足以上颜色要求的项链（5 <= N <= 1000）。

**解答**

把每个颜色看出一个点，每个珠子看出一个边，同级每个点的度，判断是否都是偶数

用dfs判断是否连通





Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：[参考](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/)

1. 从起点出发，进行深度优先搜索。
2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。
3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。

```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        def dfs(curr: str):
            while vec[curr]:
                tmp = heapq.heappop(vec[curr])
                dfs(tmp)
            stack.append(curr)

        vec = collections.defaultdict(list)
        for depart, arrive in tickets:
            vec[depart].append(arrive)
        for key in vec:
            heapq.heapify(vec[key])
        
        stack = list()
        dfs("JFK") # 从开始节点出发。
        return stack[::-1]
```

