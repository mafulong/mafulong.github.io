---
layout: post
category: Algorithms
title: 线段树
tags: Algorithms
---

# 定义

线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与[树状数组（binary indexed tree）](https://www.jianshu.com/p/5b209c029acd)相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。

对应于树状数组，线段树进行更新（update）的操作为`O(logn)`，进行区间查询（range query）的操作也为`O(logn)`。

# 实现原理

[参考](https://algo.itcharge.cn/07.Tree/03.Segment-Tree/01.Segment-Tree/)



# 模板

## python3 动态开点

默认是区间和，下面init时改成了取区间最大值。

- lazy_upate:  区间更新时更新了什么
- collect: 两个区间merge后的结果

```python
from typing import Callable, Any


# 线段树的节点类
class STNode:
    def __init__(self, left=-1, right=-1, val=0):
        self.left = left  # 区间左边界
        self.right = right  # 区间右边界
        self.mid = left + (right - left) // 2
        self.leftNode = None  # 区间左节点
        self.rightNode = None  # 区间右节点
        self.val = val  # 节点值（区间值）
        self.lazy_tag = None  # 区间问题的延迟更新标记


# 线段树类
class SegmentTree:
    def __init__(self, left=0, right=int(1e9), collect=lambda a, b: a + b, lazy_update=None):
        # collect 左区间和右区间的聚合方法；传入左区间和右区间，返回一个任意值作为两区间的聚合结果
        # 注意right不能小于查询边界，这里更新查询最大只能[left,right]
        self.root = STNode(left, right)
        self.__collect = collect  # function 是一个函数，左右区间的聚合方法

        def __default_lazy_update(node: STNode, lazy: Any):
            meta_size = (node.right - node.left + 1)  # (r - l + 1)为此区间的元线段数
            node.val += meta_size * lazy
            node.lazy_tag = node.lazy_tag + lazy if node.lazy_tag is not None else lazy

        # 用于加lazy标记的，实际上是当前val变下，然后加的标记影响子节点
        self.__lazy_update = lazy_update if lazy_update is not None else __default_lazy_update

    # collect区间合并
    def __merge(self, node):
        node.val = self.__collect(node.leftNode.val, node.rightNode.val)

    # 单点更新，将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.__update_point(i, val, self.root)

    # 单点更新，将 nums[i] 更改为 val。node 节点的区间为 [node.left, node.right]
    def __update_point(self, i, val, node):
        # 单点更新只改了个点的val，不需要考虑lazy flag
        if node.left == node.right:
            node.val = val  # 叶子节点，节点值修改为 val
            return
        self.__pushdown(node)
        if i <= node.mid:  # 在左子树中更新节点值
            self.__update_point(i, val, node.leftNode)
        else:  # 在右子树中更新节点值
            self.__update_point(i, val, node.rightNode)
        self.__merge(node)

    # 区间查询，查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, self.root)

    # 区间查询，在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if q_left <= node.left and node.right <= q_right:  # 区间就是想要的区间
            return node.val  # 直接返回节点值
        self.__pushdown(node)
        res_left = 0
        res_right = 0
        if q_left <= node.mid:  # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, node.leftNode)
        if q_right > node.mid:  # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, node.rightNode)
        return self.__collect(res_left, res_right)  # 返回左右子树元素值的聚合计算结果

    # 区间更新，将区间为 [q_left, q_right] 上的元素值修改为 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, self.root)

    # 区间更新
    def __update_interval(self, q_left, q_right, val, node):
        self.__pushdown(node)  # 向下更新节点所在区间的左右子节点的值和懒惰标记
        if q_left <= node.left and node.right <= q_right:  # 当前区间都是要更新的
            self.__lazy_update(node, val)
            return
        if q_left <= node.mid:  # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:  # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.rightNode)
        self.__merge(node)

    def __create_child_nodes(self, node: STNode):
        if not node.leftNode:
            node.leftNode = STNode(node.left, node.mid)
        if not node.rightNode:
            node.rightNode = STNode(node.mid + 1, node.right)

    # 向下更新 node 节点所在区间的左右子节点的值和懒惰标记
    # 实际是把当前节点的lazy flag去掉，转化并加到下面节点上去
    def __pushdown(self, node):
        self.__create_child_nodes(node)
        if node.lazy_tag is not None:
            if node.left != node.right:
                self.__lazy_update(node.leftNode, node.lazy_tag)
                self.__lazy_update(node.rightNode, node.lazy_tag)
            # 如果是叶子节点已经由父节点更新这个叶子节点值了
            node.lazy_tag = None  # 更新当前节点的懒惰标记


class RangeModule:

    def __init__(self):
        # 区间设置成val, 因此节点val是下面和
        def __default_lazy_update(node: STNode, lazy: Any):
            meta_size = (node.right - node.left + 1)  # (r - l + 1)为此区间的元线段数
            node.val = lazy * meta_size
            node.lazy_tag = lazy

        self.st = SegmentTree(right=int(1e6), lazy_update=__default_lazy_update)

    def addRange(self, left: int, right: int) -> None:
        self.st.update_interval(left, right - 1, 1)

    def queryRange(self, left: int, right: int) -> bool:
        r = self.st.query_interval(left, right - 1)
        return r == right - left

    def removeRange(self, left: int, right: int) -> None:
        self.st.update_interval(left, right - 1, 0)


# 区间最大值
class MyCalendarThree:

    def __init__(self):
        # 区间取最大值
        def __default_lazy_update(ch: STNode, lazy: Any):
            ch.val = ch.val + lazy
            # 可以叠加的，+val, max(val)都可以叠加, 但赋值=val就不能叠加了，以最后为准
            ch.lazy_tag = ch.lazy_tag + lazy if ch.lazy_tag is not None else lazy
        self.st = SegmentTree(collect=lambda a,b:max(a,b), lazy_update=__default_lazy_update)

    def book(self, start: int, end: int) -> bool:
        self.st.update_interval(start, end - 1, 1)
        r = self.st.query_interval(0, 1e9)
        return r
      
      


```



## python3 顺序存储



# 题目列表

- 区间最大值
  - [732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/)
  - [731. 我的日程安排表 II](https://leetcode.cn/problems/my-calendar-ii/)

- 区间和
  - 如果区间和的value是1的话，那sumRange就是求个数了，转变成求一个区间的个数问题 [参考](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/4chong-jie-fa-yi-wang-da-jin-pai-xu-shu-5vvds/)


