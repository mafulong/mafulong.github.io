---
layout: post
category: Algorithms
title: 动态规划总结
tags: Algorithms
---
[参考](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns)

Before starting the topic let me introduce myself. I am a Mobile Developer currently working in Warsaw and spending my free time for interview preparations. I started to prepare for interviews two years ago. At that time I should say I could not solve the two sum problem. Easy problems seemed to me like hard ones so most of the time I had to look at editorials and discuss section. Currently, I have solved ~800 problems and time to time participate in contests. I usually solve 3 problems in a contest and sometimes 4 problems. Ok, lets come back to the topic.


Recently I have concentrated my attention on Dynamic Programming cause its one of the hardest topics in an interview prep. After solving ~140 problems in DP I have noticed that there are few patterns that can be found in different problems. So I did a research on that and find the following topics. I will not give complete ways how to solve problems but these patterns may be helpful in solving DP.

# Patterns

[Minimum (Maximum) Path to Reach a Target](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Minimum-(Maximum)-Path-to-Reach-a-Target)

[Distinct Ways](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#distinct-ways)

[Merging Intervals](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Merging-Intervals)

[DP on Strings](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#DP-on-Strings)

[Decision Making](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Decision-Making)

# Minimum (Maximum) Path to Reach a Target

------


Generate problem statement for this pattern


### Statement

> Given a target find minimum (maximum) cost / path / sum to reach the target.
### Approach

> Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.
```
routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]
```

Generate optimal solutions for all values in the target and return the value for the target.
```
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;
       }
   }
}
 
return dp[target]
```
### Similar Problems

[746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/) `Easy`
```
for (int i = 2; i <= n; ++i) {
   dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]);
}
 
return dp[n]
```

[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/) `Medium`

```
for (int i = 1; i < n; ++i) {
   for (int j = 1; j < m; ++j) {
       grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];
   }
}
 
return grid[n-1][m-1]

也可以自上而下
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[sys.maxsize] * n for _ in range(m)]

        def f(i, j):
            if not (0 <= i < m and 0 <= j < n):
                return sys.maxsize
            if dp[i][j] < sys.maxsize:
                return dp[i][j]
            if i == 0 and j == 0:
                return grid[0][0]
            res = min(f(i - 1, j), f(i, j - 1)) + grid[i][j]
            dp[i][j] = res
            return res
        return f(m-1, n-1)
```

[322. Coin Change](https://leetcode.com/problems/coin-change/) `Medium`

```
for (int j = 1; j <= amount; ++j) {
   for (int i = 0; i < coins.size(); ++i) {
       if (coins[i] <= j) {
           dp[j] = min(dp[j], dp[j - coins[i]] + 1);
       }
   }
}
```

[931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/) `Medium`
```python
class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
        res = 0
        maxValue = sys.maxsize
        m, n = len(A), len(A[0])
        dp = [[maxValue for _ in range(n)] for _ in range(m)]
        dp[0] = A[0]
        for i in range(1, m):
            for j in range(0, n):
                for k in range(max(0, j - 1), min(n - 1, j + 1) + 1):
                    dp[i][j] = min(dp[i][j], A[i][j] + dp[i - 1][k])
        return min(dp[m - 1])
```
[983. Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/) `Medium`
```python
class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        n = len(days)
        maxValue = sys.maxsize
        dp = [maxValue for _ in range(n + 1)]
        duration = [1, 7, 30]
        dp[0] = 0
        for i in range(1, n + 1):
            for k in range(3):
                d = duration[k]
                last = i - 1
                j = i - 1
                while j >= 0 and days[i-1] - days[j] < d:
                    last = j
                    j -= 1
                dp[i] = min(dp[i], dp[last] + costs[k])
        return dp[len(days)]
```
[650. 2 Keys Keyboard](https://leetcode.com/problems/2-keys-keyboard/) `Medium`
```python
class Solution:
    def minSteps(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        dp[1] = 0
        for i in range(2, n+1):
            dp[i] = i
            for j in range(i-1, 0, -1):
                if i % j == 0:
                    dp[i] = dp[j] + i//j
                    break
        return dp[n]
```
[279. Perfect Squares](https://leetcode.com/problems/perfect-squares/) `Medium`
```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [sys.maxsize for _ in range(n + 1)]
        dp[0] = 0
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                dp[i] = min(dp[i], dp[i - j * j] + 1)
                j += 1
        return dp[n]
```
[1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/) `Medium`

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        totalSum = sum(stones)
        dp = [False for _ in range(totalSum // 2 + 1)]
        dp[0] = True
        s2 = 0
        for stone in stones:
            for i in range(totalSum // 2, -1, -1):
                dp[i] = dp[i] or (dp[i - stone] if i >= stone else False)
                if dp[i]:
                    s2 = max(s2, i)
        return totalSum - 2 * s2
```

[120. Triangle](https://leetcode.com/problems/triangle/) `Medium`

```c++
class Solution {
public:
	int minimumTotal(vector<vector<int>>& triangle) {
		int n = triangle.size();
		vector<int> dp(triangle.size(), 0);
		for (int i = 0; i < triangle[n-1].size(); i++) {
			dp[i] = triangle[n - 1][i];
		}
		for (int i = n - 2; i >= 0; i--) {
			for (int j = 0; j <= i;j++) {
				dp[j] = min(dp[j], dp[j + 1])+triangle[i][j];
				cout << dp[j] << " ";
			}
			cout << endl;
		}
		return dp[0];
	}
};

```

[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/) `Medium`

```c++
class Solution {
  public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));

        for (auto &s: strs) {
            int ones = count(s.begin(), s.end(), '1');
            int zeros= s.size()-ones;
            for (int j=n; j>=ones; j--)

            for (int i=m; i>=zeros; i--) 
                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1);
        }
        return dp[m][n];
    }
};
```

[221. Maximal Square](https://leetcode.com/problems/maximal-square/) `Medium`

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        res = 0
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                if int(matrix[i][j]) == 1:
                    dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j], dp[i][j]) + 1
                res = max(res, pow(dp[i + 1][j + 1], 2))
        return res

```

[322. Coin Change](https://leetcode.com/problems/coin-change/) `Medium`

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0
        dp = [amount + 1 for _ in range(amount + 1)]
        dp[0] = 0
        for i in range(1, amount + 1):
            for _, coin in enumerate(coins):
                if i >= coin:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        print(dp)
        if dp[amount] <=amount:
            return dp[amount]
        else:
            return -1
```

[1240. Tiling a Rectangle with the Fewest Squares](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/) `Hard`

[174. Dungeon Game](https://leetcode.com/problems/dungeon-game/) `Hard`
and 
[871. Minimum Number of Refueling Stops](https://leetcode.com/problems/minimum-number-of-refueling-stops/) `Hard`

# Distinct Ways

------


Generate problem statement for this pattern


### Statement

> Given a target find a number of distinct ways to reach the target.
### Approach

> Sum all possible ways to reach the current state.
```
  routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]
```


Generate sum for all values in the target and return the value for the target.

```
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] += dp[i - ways[j]];
       }
   }
}
 
return dp[target]
```
### Similar Problems


[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) `easy`

```
for (int stair = 2; stair <= n; ++stair) {
   for (int step = 1; step <= 2; ++step) {
       dp[stair] += dp[stair-step];   
   }
}
```

[62. Unique Paths](https://leetcode.com/problems/unique-paths/) `Medium`

```
for (int i = 1; i < m; ++i) {
   for (int j = 1; j < n; ++j) {
       dp[i][j] = dp[i][j-1] + dp[i-1][j];
   }
}
```

[1155. Number of Dice Rolls With Target Sum](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/) `Medium`

d个骰子，一个骰子f个面，求扔到结果为target不同的方式。

```
for (int rep = 1; rep <= d; ++rep) {
   vector<int> new_ways(target+1);
   for (int already = 0; already <= target; ++already) {
       for (int pipe = 1; pipe <= f; ++pipe) {
           if (already - pipe >= 0) {
               new_ways[already] += ways[already - pipe];
               new_ways[already] %= mod;
           }
       }
   }
   ways = new_ways;
}
```

**Note**


Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.

[688. Knight Probability in Chessboard](https://leetcode.com/problems/knight-probability-in-chessboard/) `Medium`

```python
class Solution:
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        dp = [[[None] * (K+1) for _ in range(N)] for _ in range(N)]
        dirs = ((2, 1), (2, -1), (-2, 1), (-2, -1),
                (1, 2), (1, -2), (-1, 2), (-1, -2))
        def f(r, c, k):
            if not (0 <= r < N and 0 <= c < N):
                return 0
            if k == 0:
                return 1
            if dp[r][c][k] is not None:
                return dp[r][c][k]
            res = 0
            for dir in dirs:
                res += 0.125 * f(r + dir[0], c + dir[1], k - 1)
            dp[r][c][k] = res
            return res

        return f(r, c, K)
```

[494. Target Sum](https://leetcode.com/problems/target-sum/) `Medium`

```java
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int S) {
		int sum = 0;
		for (int num : nums) 
			sum += num;
		if (sum < 0 || (S+sum) % 2 == 1||S>sum)
			return 0;
		int W = (sum + S) / 2;
		int *dp = new int[W + 1];
		fill(dp, dp + W + 1, 0);
		dp[0] = 1;
		for (int num : nums) {
			for (int i = W; i >= 0; i--) {
				if (i >= num) {
					dp[i] = dp[i] + dp[i - num];
				}
			}
		}
		return dp[W];
	}
};
```

[377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/) `Medium`

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1
        nums.sort()
        for i in range(1, target + 1):
            for num in nums :
                if i >= num:
                    dp[i] += dp[i-num]
                else:
                    break
        print(dp)
        return dp[target]

```

[935. Knight Dialer](https://leetcode.com/problems/knight-dialer/) `Medium`

```python
class Solution:
    def canReach(self, i: int) -> tuple():
        reachMap = {
            1: (6, 8),
            2: (7, 9),
            3: (4, 8),
            4: (3, 9, 0),
            6: (7, 1, 0),
            7: (2, 6),
            8: (1, 3),
            9: (4, 2),
            0: (4, 6)
        }
        return reachMap.get(i, ())

    def knightDialer(self, n: int) -> int:
        if n < 1:
            return 0
        dp = [[0 for _ in range(10)] for _ in range(n)]
        dp[0] = [1 for _ in range(10)]
        for i in range(1, n):
            for j in range(10):
                for reach in self.canReach(j):
                    dp[i][j] += dp[i - 1][reach]
                    dp[i][j] %= (10 ** 9 + 7)
        return sum(dp[n - 1]) % (10 ** 9 + 7)
```

[1223. Dice Roll Simulation](https://leetcode.com/problems/dice-roll-simulation/) `Medium`

每个骰子不能连续出现rollMax(i)次，统计时需要注意。

```python

class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        p = 10**9+7
        dp = [[0 for _ in range(6)] for _ in range(n + 1)]
        sum = [0 for _ in range(n + 1)]
        sum[0] = 1
        # dp i, j . res for roll i times when last with face j
        for i in range(1, n + 1):
            for j in range(6):
                for k in range(1, rollMax[j] + 1):
                    if i >= k:
                        dp[i][j] += sum[i - k] - dp[i - k][j]
                        dp[i][j] %= p
                sum[i] += dp[i][j]
        return sum[n] % p

```

[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) `Medium`

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        totalSum = sum(nums)
        if totalSum % 2 == 1:
            return False
        val = int(totalSum / 2)
        dp = [False for _ in range(val + 1)]
        dp[0] = True
        for i in range(1, len(nums) + 1):
            for j in range(val, 0, -1):
                dp[j] = dp[j] or dp[j - nums[i - 1]] if j >= nums[i - 1] else False
        return dp[val]

```

[808. Soup Servings](https://leetcode.com/problems/soup-servings/) `Medium`

```python
class Solution:
    def soupServings(self, N: int) -> float:
        memo = {}
        def f(A: int, B: int) -> float:
            if (A,B) in memo:
                return memo.get((A,B))
            # corner case
            if A <= 0 and B > 0:
                return 1
            elif A <= 0 and B <= 0:
                return 0.5
            elif B <=0:
                return 0
            # main code
            r = 0.25 * (f(A - 100, B) + f(A - 75, B - 25) + f(A - 50, B - 50) + f(A - 25, B - 75))
            memo[(A,B)] = r
            return r
        if N > 6000:
            return 1
        return f(N, N)
```

[790. Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling/) `Medium`

```python
class Solution:
    def numTilings(self, N: int) -> int:
        # 1, 2, 3 = top, down, top&down
        memo = {}
        p = 10 ** 9 + 7

        def f(i, t):
            if (i, t) in memo:
                return memo[(i, t)]
            # corner case:
            if i <= 0:
                if i == 0 and t == 3:
                    return 1
                else:
                    return 0
            if t == 1:
                r = f(i - 2, 3)%p + f(i - 1, 2)%p
            elif t == 2:
                r = f(i - 2, 3)%p + f(i - 1, 1)%p
            else:
                r = f(i - 1, 3)%p + f(i - 1, 1)%p + f(i - 1, 2)%p + f(i - 2, 3)%p
            r = r % p
            memo[(i, t)] = r
            return r

        #
        # assert f(1, 3) == 1
        # assert f(1, 1) == f(1, 2) == 0
        # assert f(2, 1) == f(2, 2) == 1
        # assert f(2, 3) == 2

        return f(N, 3)
```

[801. Minimum Swaps To Make Sequences Increasing](https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/)`Medium`

[673. Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/) `Medium`

[63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/) `Medium`

```c++
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		vector<vector<int>> d(obstacleGrid.size(), vector<int>(obstacleGrid[0].size(),0));
		if(obstacleGrid[0][0]==0)
			d[0][0] = 1;
		for (int i = 0; i < obstacleGrid.size(); i++) {
			for (int j = 0; j < obstacleGrid[0].size(); j++) {
				if (obstacleGrid[i][j] == 1)
					continue;
				if (i > 0)
					d[i][j] += d[i - 1][j];
				if (j > 0)
					d[i][j] += d[i][j - 1];
			}
		}
		return d[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1];
	}
};
```

[576. Out of Boundary Paths](https://leetcode.com/problems/out-of-boundary-paths/) `Medium`

[1269. Number of Ways to Stay in the Same Place After Some Steps](https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/) `Hard`

[1220. Count Vowels Permutation](https://leetcode.com/problems/count-vowels-permutation/) `Hard`

# Merging Intervals

------


Generate problem statement for this pattern


### Statement

> Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.
### Approach

> Find all optimal solutions for every interval and return the best possible answer.
```
// from i to j
dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]
```


Get the best from the left and right sides and add a solution for the current position.

```
for(int l = 1; l<n; l++) {
   for(int i = 0; i<n-l; i++) {
       int j = i+l;
       for(int k = i; k<j; k++) {
           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
       }
   }
}
 
return dp[0][n-1]
```
### Similar Problems

[1130. Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/) `Medium`

```
for (int l = 1; l < n; ++l) {
   for (int i = 0; i < n - l; ++i) {
       int j = i + l;
       dp[i][j] = INT_MAX;
       for (int k = i; k < j; ++k) {
           dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]);
       }
   }
}
```

[96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) `Medium`

一个1-n的数组能组成多少种bst

```pythonn
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
        for i in range(1, n + 1):
            dp[i][i] = 1
        for l in range(1, n):
            for i in range(1, n - l + 1):
                j = i + l
                for k in range(i, j + 1):
                    dp[i][j] += (dp[i][k-1] if k-1>=i else 1) * (dp[k+1][j] if k+1<=j else 1)
        return dp[1][n]
```

[1039. Minimum Score Triangulation of Polygon](https://leetcode.com/problems/minimum-score-triangulation-of-polygon/) `Medium`

多变形拆成一些三角形

```python
class Solution:
    def minScoreTriangulation(self, A: List[int]) -> int:
        dp = [[0] * 50 for _ in range(50)]

        def f(i=0, j=0):
            if j == 0:
                j = len(A) - 1
            if dp[i][j] != 0:
                return dp[i][j]
            if i != len(A) - 1 and i >= j - 1:
                return 0
            res = sys.maxsize
            for k in range(i + 1, j):
                res = min(res, f(i, k) + A[i] * A[k] * A[j] + f(k, j))
            dp[i][j] = res
            return res

```

[546. Remove Boxes](https://leetcode.com/problems/remove-boxes/) `Medium`

[1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/) `Medium`

[312. Burst Balloons](https://leetcode.com/problems/burst-balloons/) `Hard`

[375. Guess Number Higher or Lower II](https://leetcode.com/problems/guess-number-higher-or-lower-ii/) `Medium`

# DP on Strings

------


General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big


### Statement

> Given two strings `s1` and `s2`, return `some result`.
### Approach

> Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.
```
// i - indexing string s1
// j - indexing string s2
for (int i = 1; i <= n; ++i) {
   for (int j = 1; j <= m; ++j) {
       if (s1[i-1] == s2[j-1]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
```
> If you are given one string `s` the approach may little vary

```
for (int l = 1; l < n; ++l) {
   for (int i = 0; i < n-l; ++i) {
       int j = i + l;
       if (s[i] == s[j]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
```

[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) `Medium`

```
for (int i = 1; i <= n; ++i) {
   for (int j = 1; j <= m; ++j) {
       if (text1[i-1] == text2[j-1]) {
           dp[i][j] = dp[i-1][j-1] + 1;
       } else {
           dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
       }
   }
}
```

[647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/) `Medium`

```
for (int l = 1; l < n; ++l) {
   for (int i = 0; i < n-l; ++i) {
       int j = i + l;
       if (s[i] == s[j] && dp[i+1][j-1] == j-i-1) {
           dp[i][j] = dp[i+1][j-1] + 2;
       } else {
           dp[i][j] = 0;
       }
   }
}
```

[516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/) `Medium`

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];
        
        for (int i = s.length() - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i+1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][s.length()-1];
    }
}
```

[1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/) `Medium`

```python
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n1, n2 = len(str1), len(str2)
        dp = [[""] * (n2 + 1) for _ in range(n1 + 1)]
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + str1[i - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)
        lcs = dp[n1][n2]
        res = ""
        i, j = 0, 0
        for c in lcs:
            while str1[i] != c:
                res += str1[i]
                i += 1
            while str2[j] != c:
                res += str2[j]
                j += 1
            res += c
            i+=1
            j+=1
        res = res + str1[i:] + str2[j:]
        return res
```

[72. Edit Distance](https://leetcode.com/problems/edit-distance/) `Hard`

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n1, n2 = len(word1), len(word2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        for i in range(1, n1 + 1):
            dp[i][0] = i

        for j in range(1, n2 + 1):
            dp[0][j] = j
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        return dp[n1][n2]
```

[115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/) `Hard`

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(t), len(s)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        for j in range(0, n2+1):
            dp[0][j] = 1 # 为什么有这个？ 因为单个字符dp计算不对，比如aaa，a的情况
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if t[i - 1] == s[j - 1]:
                    dp[i][j] = dp[i-1][j-1]+dp[i][j-1]
                else:
                    dp[i][j] = dp[i][j-1]
        return dp[n1][n2]
```

[712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/) `Medium`

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        n1, n2 = len(s1), len(s2)
        dp = [[sys.maxsize] * (n2 + 1) for _ in range(n1 + 1)]
        dp[0][0] = 0
        for i in range(1, n1 + 1):
            dp[i][0] = dp[i - 1][0] + ord(s1[i-1])
        for j in range(1, n2 + 1):
            dp[0][j] = dp[0][j - 1] + ord(s2[j-1])
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i][j - 1] + ord(s2[j-1]), dp[i - 1][j] + ord(s1[i-1]))
        return dp[n1][n2]
```

[5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) `Medium`

# Decision Making

------


The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.

### Statement

> Given a set of values find an answer with an option to choose or ignore the current value.
### Approach

> If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.
```
// i - indexing a set of values
// j - options to ignore j values
for (int i = 1; i < n; ++i) {
   for (int j = 1; j <= k; ++j) {
       dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]});
       dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]});
   }
}
```

[198. House Robber](https://leetcode.com/problems/house-robber/) `Easy`

```
for (int i = 1; i < n; ++i) {
   dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]);
   dp[i][0] = dp[i-1][1];
}
```

[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) `Easy`

[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) `Medium`

每次交易有费用fee

```c++
class Solution {
public:
	int maxProfit(vector<int>& prices, int fee) {
		if (prices.size() <= 1) return 0;
		vector<int> buy(prices.size()), sell(prices.size());
		buy[0] = -prices[0] - fee;
		for (int i = 1; i < prices.size(); i++) {
			buy[i] = max(buy[i - 1], sell[i - 1] - prices[i] - fee);
			sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]);
		}
		return sell[prices.size() - 1];
	}
};
```

[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) `Medium`

cooldown 1 day

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # corner cases
        if len(prices) == 0:
            return 0
        # main part
        sell = [0] * (len(prices))
        buy = [float("-inf")] * (len(prices))
        buy[0] = -prices[0]
        for i in range(1, len(prices)):
            buy[i] = max((sell[i-2] if i>=2 else 0) -prices[i], buy[i-1])
            sell[i] = max(sell[i-1], buy[i-1]+prices[i])
        return sell[len(prices)-1]
```

[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) `Hard`

![image](https://user-images.githubusercontent.com/24795000/94980765-62a5d800-055f-11eb-9dd9-27388d10e9c8.png)



where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It's not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn't trade on that day.

```python
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        n = len(prices)
        K = 2
        # corner case
        if n == 0:
            return 0
        # main part
        dp = [[0] * n for _ in range(K + 1)]
        for i in range(1, K + 1):
            max_diff = float('-inf')
            for j in range(1, n):
                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j - 1])
                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
        return dp[K][n - 1]
```

因此正确的应该下面这个

```python
max_diff = max(max_diff, (dp[i - 1][j - 2] if j >= 2 else 0) - prices[j - 1])
```



```python
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """

    def maxProfit(self, prices):
        n = len(prices)
        K = 2
        # corner case
        if n == 0:
            return 0
        # main part
        dp = [[0] * n for _ in range(K + 1)]
        for i in range(1, K + 1):
            max_diff = float('-inf')
            for j in range(1, n):
                max_diff = max(max_diff, (dp[i - 1][j - 2] if j >= 2 else 0) - prices[j - 1])
                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
        return dp[K][n - 1]

```

[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) `Hard`

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        # corner case
        if n == 0:
            return 0
        # main part
        dp = [[0] * n for _ in range(k + 1)]
        for i in range(1, k + 1):
            max_diff = float('-inf')
            for j in range(1, n):
                max_diff = max(max_diff, (dp[i - 1][j - 2] if j >= 2 else 0) - prices[j - 1])
                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
        return dp[k][n - 1]

```

一个数组记录sell, 一个记录buy

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        # corner case
        if n == 0 or k==0:
            return 0
        # main part
        sell = [[0 for _ in range(n)] for _ in range(k + 1)]
        buy = [[float('-inf') for _ in range(n)] for _ in range(k + 1)]
        buy[1][0] = -prices[0]
        res = 0
        for i in range(1, k + 1):
            for j in range(1, n):
                buy[i][j] = max(buy[i][j - 1], sell[i - 1][j - 1] - prices[j])
                sell[i][j] = max(sell[i][j - 1], buy[i][j - 1] + prices[j])
                res = max(res, sell[i][j])
        return res
```

I hope these tips will be helpful 😊

