---
layout: post
category: algorithms
title: åŠ¨æ€è§„åˆ’æ€»ç»“
tags: Algorithms
---
[å‚è€ƒ](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns)

Before starting the topic let me introduce myself. I am a Mobile Developer currently working in Warsaw and spending my free time for interview preparations. I started to prepare for interviews two years ago. At that time I should say I could not solve the two sum problem. Easy problems seemed to me like hard ones so most of the time I had to look at editorials and discuss section. Currently, I have solved ~800 problems and time to time participate in contests. I usually solve 3 problems in a contest and sometimes 4 problems. Ok, lets come back to the topic.


Recently I have concentrated my attention on Dynamic Programming cause its one of the hardest topics in an interview prep. After solving ~140 problems in DP I have noticed that there are few patterns that can be found in different problems. So I did a research on that and find the following topics. I will not give complete ways how to solve problems but these patterns may be helpful in solving DP.

æ€»ç»“: 

æ±‚æå¤§æå°ã€æ–¹æ³•æ•°

```
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
					ã€‚ã€‚ã€‚
       }
   }
}
 
return dp[target]
```


åŒºé—´dp, ä¸€å®šè¦é•¿åº¦åœ¨å¤–

```
for(int l = 1; l<n; l++) {
   for(int i = 0; i<n-l; i++) {
       int j = i+l;
       for(int k = i; k<j; k++) {
           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
       }
   }
}
```



## Patterns

[Minimum (Maximum) Path to Reach a Target](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Minimum-(Maximum)-Path-to-Reach-a-Target)

[Distinct Ways](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#distinct-ways)

[Merging Intervals](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Merging-Intervals)

[DP on Strings](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#DP-on-Strings)

[Decision Making](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Decision-Making)

## Minimum (Maximum) Path to Reach a Target

------


Generate problem statement for this pattern


### Statement

> Given a target find minimum (maximum) cost / path / sum to reach the target.
### Approach

> Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.
```
routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]
```

Generate optimal solutions for all values in the target and return the value for the target.
```
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;
       }
   }
}
 
return dp[target]
```
### Similar Problems

[ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)`Easy`

```
for (int i = 2; i <= n; ++i) {
   dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]);
}
 
return dp[n]
```

[64. Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum/) `Medium`
æœ€å°è·¯å¾„å’Œ, ç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ m x n ç½‘æ ¼ grid ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚

```
for (int i = 1; i < n; ++i) {
   for (int j = 1; j < m; ++j) {
       grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];
   }
}
 
return grid[n-1][m-1]

ä¹Ÿå¯ä»¥è‡ªä¸Šè€Œä¸‹
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[sys.maxsize] * n for _ in range(m)]

        def f(i, j):
            if not (0 <= i < m and 0 <= j < n):
                return sys.maxsize
            if dp[i][j] < sys.maxsize:
                return dp[i][j]
            if i == 0 and j == 0:
                return grid[0][0]
            res = min(f(i - 1, j), f(i, j - 1)) + grid[i][j]
            dp[i][j] = res
            return res
        return f(m-1, n-1)
```

[322. Coin Change](https://leetcode-cn.com/problems/coin-change/) `Medium`

ç»™å®šä¸åŒé¢é¢çš„ç¡¬å¸ coins å’Œä¸€ä¸ªæ€»é‡‘é¢ amountã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1ã€‚

ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚

```
for (int j = 1; j <= amount; ++j) {
   for (int i = 0; i < coins.size(); ++i) {
       if (coins[i] <= j) {
           dp[j] = min(dp[j], dp[j - coins[i]] + 1);
       }
   }
}
```

[931. Minimum Falling Path Sum](https://leetcode-cn.com/problems/minimum-falling-path-sum/) `Medium`

ç»™å®šä¸€ä¸ªæ–¹å½¢æ•´æ•°æ•°ç»„ Aï¼Œæˆ‘ä»¬æƒ³è¦å¾—åˆ°é€šè¿‡ A çš„ä¸‹é™è·¯å¾„çš„æœ€å°å’Œã€‚

ä¸‹é™è·¯å¾„å¯ä»¥ä»ç¬¬ä¸€è¡Œä¸­çš„ä»»ä½•å…ƒç´ å¼€å§‹ï¼Œå¹¶ä»æ¯ä¸€è¡Œä¸­é€‰æ‹©ä¸€ä¸ªå…ƒç´ ã€‚åœ¨ä¸‹ä¸€è¡Œé€‰æ‹©çš„å…ƒç´ å’Œå½“å‰è¡Œæ‰€é€‰å…ƒç´ æœ€å¤šç›¸éš”ä¸€åˆ—ã€‚

```python
class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
        res = 0
        maxValue = sys.maxsize
        m, n = len(A), len(A[0])
        dp = [[maxValue for _ in range(n)] for _ in range(m)]
        dp[0] = A[0]
        for i in range(1, m):
            for j in range(0, n):
                for k in range(max(0, j - 1), min(n - 1, j + 1) + 1):
                    dp[i][j] = min(dp[i][j], A[i][j] + dp[i - 1][k])
        return min(dp[m - 1])
```
[983. Minimum Cost For Tickets](https://leetcode-cn.com/problems/minimum-cost-for-tickets/) `Medium`

åœ¨ä¸€ä¸ªç«è½¦æ—…è¡Œå¾ˆå—æ¬¢è¿çš„å›½åº¦ï¼Œä½ æå‰ä¸€å¹´è®¡åˆ’äº†ä¸€äº›ç«è½¦æ—…è¡Œã€‚åœ¨æ¥ä¸‹æ¥çš„ä¸€å¹´é‡Œï¼Œä½ è¦æ—…è¡Œçš„æ—¥å­å°†ä»¥ä¸€ä¸ªåä¸º days çš„æ•°ç»„ç»™å‡ºã€‚æ¯ä¸€é¡¹æ˜¯ä¸€ä¸ªä» 1 åˆ° 365 çš„æ•´æ•°ã€‚

ç«è½¦ç¥¨æœ‰ä¸‰ç§ä¸åŒçš„é”€å”®æ–¹å¼ï¼š

ä¸€å¼ ä¸ºæœŸä¸€å¤©çš„é€šè¡Œè¯å”®ä»·ä¸º costs[0] ç¾å…ƒï¼›
ä¸€å¼ ä¸ºæœŸä¸ƒå¤©çš„é€šè¡Œè¯å”®ä»·ä¸º costs[1] ç¾å…ƒï¼›
ä¸€å¼ ä¸ºæœŸä¸‰åå¤©çš„é€šè¡Œè¯å”®ä»·ä¸º costs[2] ç¾å…ƒã€‚
é€šè¡Œè¯å…è®¸æ•°å¤©æ— é™åˆ¶çš„æ—…è¡Œã€‚ ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ç¬¬ 2 å¤©è·å¾—ä¸€å¼ ä¸ºæœŸ 7 å¤©çš„é€šè¡Œè¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è¿ç€æ—…è¡Œ 7 å¤©ï¼šç¬¬ 2 å¤©ã€ç¬¬ 3 å¤©ã€ç¬¬ 4 å¤©ã€ç¬¬ 5 å¤©ã€ç¬¬ 6 å¤©ã€ç¬¬ 7 å¤©å’Œç¬¬ 8 å¤©ã€‚

è¿”å›ä½ æƒ³è¦å®Œæˆåœ¨ç»™å®šçš„åˆ—è¡¨ days ä¸­åˆ—å‡ºçš„æ¯ä¸€å¤©çš„æ—…è¡Œæ‰€éœ€è¦çš„æœ€ä½æ¶ˆè´¹ã€‚

```python
class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        n = len(days)
        maxValue = sys.maxsize
        dp = [maxValue for _ in range(n + 1)]
        duration = [1, 7, 30]
        dp[0] = 0
        for i in range(1, n + 1):
            for k in range(3):
                d = duration[k]
                last = i - 1
                j = i - 1
                while j >= 0 and days[i-1] - days[j] < d:
                    last = j
                    j -= 1
                dp[i] = min(dp[i], dp[last] + costs[k])
        return dp[len(days)]
```
[650. 2 Keys Keyboard](https://leetcode-cn.com/problems/2-keys-keyboard/) `Medium`

æœ€åˆåœ¨ä¸€ä¸ªè®°äº‹æœ¬ä¸Šåªæœ‰ä¸€ä¸ªå­—ç¬¦ 'A'ã€‚ä½ æ¯æ¬¡å¯ä»¥å¯¹è¿™ä¸ªè®°äº‹æœ¬è¿›è¡Œä¸¤ç§æ“ä½œï¼š

Copy All (å¤åˆ¶å…¨éƒ¨) : ä½ å¯ä»¥å¤åˆ¶è¿™ä¸ªè®°äº‹æœ¬ä¸­çš„æ‰€æœ‰å­—ç¬¦(éƒ¨åˆ†çš„å¤åˆ¶æ˜¯ä¸å…è®¸çš„)ã€‚
Paste (ç²˜è´´) : ä½ å¯ä»¥ç²˜è´´ä½ ä¸Šä¸€æ¬¡å¤åˆ¶çš„å­—ç¬¦ã€‚
ç»™å®šä¸€ä¸ªæ•°å­— n ã€‚ä½ éœ€è¦ä½¿ç”¨æœ€å°‘çš„æ“ä½œæ¬¡æ•°ï¼Œåœ¨è®°äº‹æœ¬ä¸­æ‰“å°å‡ºæ°å¥½ n ä¸ª 'A'ã€‚è¾“å‡ºèƒ½å¤Ÿæ‰“å°å‡º n ä¸ª 'A' çš„æœ€å°‘æ“ä½œæ¬¡æ•°ã€‚

```python
class Solution:
    def minSteps(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        dp[1] = 0
        for i in range(2, n+1):
            dp[i] = i
            for j in range(i-1, 0, -1):
                if i % j == 0:
                    dp[i] = dp[j] + i//j
                    break
        return dp[n]
```
[279. Perfect Squares](https://leetcode-cn.com/problems/perfect-squares/) `Medium`

ç»™å®šæ­£æ•´æ•° nï¼Œæ‰¾åˆ°è‹¥å¹²ä¸ªå®Œå…¨å¹³æ–¹æ•°ï¼ˆæ¯”å¦‚ 1, 4, 9, 16, ...ï¼‰ä½¿å¾—å®ƒä»¬çš„å’Œç­‰äº nã€‚ä½ éœ€è¦è®©ç»„æˆå’Œçš„å®Œå…¨å¹³æ–¹æ•°çš„ä¸ªæ•°æœ€å°‘ã€‚

ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›å’Œä¸º n çš„å®Œå…¨å¹³æ–¹æ•°çš„ æœ€å°‘æ•°é‡ ã€‚

å®Œå…¨å¹³æ–¹æ•° æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå…¶å€¼ç­‰äºå¦ä¸€ä¸ªæ•´æ•°çš„å¹³æ–¹ï¼›æ¢å¥è¯è¯´ï¼Œå…¶å€¼ç­‰äºä¸€ä¸ªæ•´æ•°è‡ªä¹˜çš„ç§¯ã€‚ä¾‹å¦‚ï¼Œ1ã€4ã€9 å’Œ 16 éƒ½æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œè€Œ 3 å’Œ 11 ä¸æ˜¯ã€‚

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [sys.maxsize for _ in range(n + 1)]
        dp[0] = 0
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                dp[i] = min(dp[i], dp[i - j * j] + 1)
                j += 1
        return dp[n]
```
[1049. Last Stone Weight II](https://leetcode-cn.com/problems/last-stone-weight-ii/) `Medium`

æœ‰ä¸€å †çŸ³å¤´ï¼Œæ¯å—çŸ³å¤´çš„é‡é‡éƒ½æ˜¯æ­£æ•´æ•°ã€‚

æ¯ä¸€å›åˆï¼Œä»ä¸­é€‰å‡ºä»»æ„ä¸¤å—çŸ³å¤´ï¼Œç„¶åå°†å®ƒä»¬ä¸€èµ·ç²‰ç¢ã€‚å‡è®¾çŸ³å¤´çš„é‡é‡åˆ†åˆ«ä¸º x å’Œ yï¼Œä¸” x <= yã€‚é‚£ä¹ˆç²‰ç¢çš„å¯èƒ½ç»“æœå¦‚ä¸‹ï¼š

å¦‚æœ x == yï¼Œé‚£ä¹ˆä¸¤å—çŸ³å¤´éƒ½ä¼šè¢«å®Œå…¨ç²‰ç¢ï¼›
å¦‚æœ x != yï¼Œé‚£ä¹ˆé‡é‡ä¸º x çš„çŸ³å¤´å°†ä¼šå®Œå…¨ç²‰ç¢ï¼Œè€Œé‡é‡ä¸º y çš„çŸ³å¤´æ–°é‡é‡ä¸º y-xã€‚
æœ€åï¼Œæœ€å¤šåªä¼šå‰©ä¸‹ä¸€å—çŸ³å¤´ã€‚è¿”å›æ­¤çŸ³å¤´æœ€å°çš„å¯èƒ½é‡é‡ã€‚å¦‚æœæ²¡æœ‰çŸ³å¤´å‰©ä¸‹ï¼Œå°±è¿”å› 0ã€‚

è§£ç­”ï¼šå…¶å®å°±æ˜¯ä¸€éƒ¨åˆ†ä¸º+, ä¸€éƒ¨åˆ†ä¸º-, æ¯”å¦‚1-ï¼ˆï¼ˆ4-2ï¼‰-ï¼ˆ8-7ï¼‰ï¼‰

æ‰€ä»¥ç»“æœå°±æ˜¯min(A-B), å…¶ä¸­A, Bä¸ºä¸€éƒ¨åˆ†å…ƒç´ sum. A+B=sum(stones), min(sum-2B),æŒ‘ä¸€äº›å…ƒç´ ï¼Œä½¿å¾—min(sum-2B)ï¼Œä¹Ÿå°±æ˜¯sum/2çš„èƒŒåŒ…æ±‚æœ€å¤šèƒ½è£…å¤šå°‘ã€‚

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        totalSum = sum(stones)
        dp = [False for _ in range(totalSum // 2 + 1)]
        dp[0] = True
        s2 = 0
        for stone in stones:
            for i in range(totalSum // 2, -1, -1):
                dp[i] = dp[i] or (dp[i - stone] if i >= stone else False)
                if dp[i]:
                    s2 = max(s2, i)
        return totalSum - 2 * s2
```

[120. Triangle](https://leetcode-cn.com/problems/triangle/) `Medium`

ç»™å®šä¸€ä¸ªä¸‰è§’å½¢ triangle ï¼Œæ‰¾å‡ºè‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚

æ¯ä¸€æ­¥åªèƒ½ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œä¸­ç›¸é‚»çš„ç»“ç‚¹ä¸Šã€‚ç›¸é‚»çš„ç»“ç‚¹ åœ¨è¿™é‡ŒæŒ‡çš„æ˜¯ ä¸‹æ ‡ ä¸ ä¸Šä¸€å±‚ç»“ç‚¹ä¸‹æ ‡ ç›¸åŒæˆ–è€…ç­‰äº ä¸Šä¸€å±‚ç»“ç‚¹ä¸‹æ ‡ + 1 çš„ä¸¤ä¸ªç»“ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ­£ä½äºå½“å‰è¡Œçš„ä¸‹æ ‡ i ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å¯ä»¥ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œçš„ä¸‹æ ‡ i æˆ– i + 1 ã€‚

```
è¾“å…¥ï¼štriangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
è¾“å‡ºï¼š11
è§£é‡Šï¼šå¦‚ä¸‹é¢ç®€å›¾æ‰€ç¤ºï¼š
   2
  3 4
 6 5 7
4 1 8 3
è‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œä¸ºÂ 11ï¼ˆå³ï¼Œ2Â +Â 3Â +Â 5Â +Â 1Â = 11ï¼‰ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/triangle
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```c++
class Solution {
public:
	int minimumTotal(vector<vector<int>>& triangle) {
		int n = triangle.size();
		vector<int> dp(triangle.size(), 0);
		for (int i = 0; i < triangle[n-1].size(); i++) {
			dp[i] = triangle[n - 1][i];
		}
		for (int i = n - 2; i >= 0; i--) {
			for (int j = 0; j <= i;j++) {
				dp[j] = min(dp[j], dp[j + 1])+triangle[i][j];
				cout << dp[j] << " ";
			}
			cout << endl;
		}
		return dp[0];
	}
};

```

[474. Ones and Zeroes](https://leetcode-cn.com/problems/ones-and-zeroes/) `Medium`

ç»™ä½ ä¸€ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²æ•°ç»„ strs å’Œä¸¤ä¸ªæ•´æ•° m å’Œ n ã€‚

è¯·ä½ æ‰¾å‡ºå¹¶è¿”å› strs çš„æœ€å¤§å­é›†çš„å¤§å°ï¼Œè¯¥å­é›†ä¸­ æœ€å¤š æœ‰ m ä¸ª 0 å’Œ n ä¸ª 1 ã€‚

å¦‚æœ x çš„æ‰€æœ‰å…ƒç´ ä¹Ÿæ˜¯ y çš„å…ƒç´ ï¼Œé›†åˆ x æ˜¯é›†åˆ y çš„ å­é›† ã€‚

```c++
class Solution {
  public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));

        for (auto &s: strs) {
            int ones = count(s.begin(), s.end(), '1');
            int zeros= s.size()-ones;
            for (int j=n; j>=ones; j--)

            for (int i=m; i>=zeros; i--) 
                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1);
        }
        return dp[m][n];
    }
};
```

[221. Maximal Square](https://leetcode-cn.com/problems/maximal-square/) `Medium`

åœ¨ä¸€ä¸ªç”± `'0'` å’Œ `'1'` ç»„æˆçš„äºŒç»´çŸ©é˜µå†…ï¼Œæ‰¾åˆ°åªåŒ…å« `'1'` çš„æœ€å¤§æ­£æ–¹å½¢ï¼Œå¹¶è¿”å›å…¶é¢ç§¯ã€‚

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        res = 0
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                if int(matrix[i][j]) == 1:
                    dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j], dp[i][j]) + 1
                res = max(res, pow(dp[i + 1][j + 1], 2))
        return res

```


[1240. Tiling a Rectangle with the Fewest Squares](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares/) `Hard`

[174. Dungeon Game](https://leetcode-cn.com/problems/dungeon-game/) `Hard`

ä¸€äº›æ¶é­”æŠ“ä½äº†å…¬ä¸»ï¼ˆPï¼‰å¹¶å°†å¥¹å…³åœ¨äº†åœ°ä¸‹åŸçš„å³ä¸‹è§’ã€‚åœ°ä¸‹åŸæ˜¯ç”± M x N ä¸ªæˆ¿é—´ç»„æˆçš„äºŒç»´ç½‘æ ¼ã€‚æˆ‘ä»¬è‹±å‹‡çš„éª‘å£«ï¼ˆKï¼‰æœ€åˆè¢«å®‰ç½®åœ¨å·¦ä¸Šè§’çš„æˆ¿é—´é‡Œï¼Œä»–å¿…é¡»ç©¿è¿‡åœ°ä¸‹åŸå¹¶é€šè¿‡å¯¹æŠ—æ¶é­”æ¥æ‹¯æ•‘å…¬ä¸»ã€‚

éª‘å£«çš„åˆå§‹å¥åº·ç‚¹æ•°ä¸ºä¸€ä¸ªæ­£æ•´æ•°ã€‚å¦‚æœä»–çš„å¥åº·ç‚¹æ•°åœ¨æŸä¸€æ—¶åˆ»é™è‡³ 0 æˆ–ä»¥ä¸‹ï¼Œä»–ä¼šç«‹å³æ­»äº¡ã€‚

æœ‰äº›æˆ¿é—´ç”±æ¶é­”å®ˆå«ï¼Œå› æ­¤éª‘å£«åœ¨è¿›å…¥è¿™äº›æˆ¿é—´æ—¶ä¼šå¤±å»å¥åº·ç‚¹æ•°ï¼ˆè‹¥æˆ¿é—´é‡Œçš„å€¼ä¸ºè´Ÿæ•´æ•°ï¼Œåˆ™è¡¨ç¤ºéª‘å£«å°†æŸå¤±å¥åº·ç‚¹æ•°ï¼‰ï¼›å…¶ä»–æˆ¿é—´è¦ä¹ˆæ˜¯ç©ºçš„ï¼ˆæˆ¿é—´é‡Œçš„å€¼ä¸º 0ï¼‰ï¼Œè¦ä¹ˆåŒ…å«å¢åŠ éª‘å£«å¥åº·ç‚¹æ•°çš„é­”æ³•çƒï¼ˆè‹¥æˆ¿é—´é‡Œçš„å€¼ä¸ºæ­£æ•´æ•°ï¼Œåˆ™è¡¨ç¤ºéª‘å£«å°†å¢åŠ å¥åº·ç‚¹æ•°ï¼‰ã€‚

ä¸ºäº†å°½å¿«åˆ°è¾¾å…¬ä¸»ï¼Œéª‘å£«å†³å®šæ¯æ¬¡åªå‘å³æˆ–å‘ä¸‹ç§»åŠ¨ä¸€æ­¥ã€‚

**æ³¨æ„ï¼šäºŒç»´æ•°ç»„ä¸ŠåŠ¨æ€è§„åˆ’ä¸€èˆ¬éƒ½æ˜¯ä»åå¾€å‰ã€‚**

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        dp = [[0 for _ in range(n)] for _ in range(m + 1)]
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                minn = 0
                if i == m - 1 and j == n - 1:
                    minn = 1 - dungeon[i][j]
                elif i == m - 1:
                    # æœ€åä¸€è¡Œ
                    minn = dp[i][j + 1] - dungeon[i][j]
                elif j == n - 1:
                    minn = dp[i + 1][j] - dungeon[i][j]
                else:
                    minn = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]
                dp[i][j] = max(1, minn)
        return dp[0][0]
```


[871. Minimum Number of Refueling Stops](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/) `Hard`

## Distinct Ways

------


Generate problem statement for this pattern


### Statement

> Given a target find a number of distinct ways to reach the target.
### Approach

> Sum all possible ways to reach the current state.
```
  routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]
```


Generate sum for all values in the target and return the value for the target.

```
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] += dp[i - ways[j]];
       }
   }
}
 
return dp[target]
```
### Similar Problems


[70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/) `easy`

```
for (int stair = 2; stair <= n; ++stair) {
   for (int step = 1; step <= 2; ++step) {
       dp[stair] += dp[stair-step];   
   }
}
```

[62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/) `Medium`

```
for (int i = 1; i < m; ++i) {
   for (int j = 1; j < n; ++j) {
       dp[i][j] = dp[i][j-1] + dp[i-1][j];
   }
}
```

[1155. Number of Dice Rolls With Target Sum](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/) `Medium`

dä¸ªéª°å­ï¼Œä¸€ä¸ªéª°å­fä¸ªé¢ï¼Œæ±‚æ‰”åˆ°ç»“æœä¸ºtargetä¸åŒçš„æ–¹å¼ã€‚

```c
for (int rep = 1; rep <= d; ++rep) {
   vector<int> new_ways(target+1);
   for (int already = 0; already <= target; ++already) {
       for (int pipe = 1; pipe <= f; ++pipe) {
           if (already - pipe >= 0) {
               new_ways[already] += ways[already - pipe];
               new_ways[already] %= mod;
           }
       }
   }
   ways = new_ways;
}
```

**Note**


Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.

[688. Knight Probability in Chessboard](https://leetcode-cn.com/problems/knight-probability-in-chessboard/) `Medium`

```python
class Solution:
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        dp = [[[None] * (K+1) for _ in range(N)] for _ in range(N)]
        dirs = ((2, 1), (2, -1), (-2, 1), (-2, -1),
                (1, 2), (1, -2), (-1, 2), (-1, -2))
        def f(r, c, k):
            if not (0 <= r < N and 0 <= c < N):
                return 0
            if k == 0:
                return 1
            if dp[r][c][k] is not None:
                return dp[r][c][k]
            res = 0
            for dir in dirs:
                res += 0.125 * f(r + dir[0], c + dir[1], k - 1)
            dp[r][c][k] = res
            return res

        return f(r, c, K)
```

[494. Target Sum](https://leetcode-cn.com/problems/target-sum/) `Medium`

```java
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int S) {
		int sum = 0;
		for (int num : nums) 
			sum += num;
		if (sum < 0 || (S+sum) % 2 == 1||S>sum)
			return 0;
		int W = (sum + S) / 2;
		int *dp = new int[W + 1];
		fill(dp, dp + W + 1, 0);
		dp[0] = 1;
		for (int num : nums) {
			for (int i = W; i >= 0; i--) {
				if (i >= num) {
					dp[i] = dp[i] + dp[i - num];
				}
			}
		}
		return dp[W];
	}
};
```

[377. Combination Sum IV](https://leetcode-cn.com/problems/combination-sum-iv/) `Medium`

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1
        nums.sort()
        for i in range(1, target + 1):
            for num in nums :
                if i >= num:
                    dp[i] += dp[i-num]
                else:
                    break
        print(dp)
        return dp[target]

```

[935. Knight Dialer](https://leetcode-cn.com/problems/knight-dialer/) `Medium`

```python
class Solution:
    def canReach(self, i: int) -> tuple():
        reachMap = {
            1: (6, 8),
            2: (7, 9),
            3: (4, 8),
            4: (3, 9, 0),
            6: (7, 1, 0),
            7: (2, 6),
            8: (1, 3),
            9: (4, 2),
            0: (4, 6)
        }
        return reachMap.get(i, ())

    def knightDialer(self, n: int) -> int:
        if n < 1:
            return 0
        dp = [[0 for _ in range(10)] for _ in range(n)]
        dp[0] = [1 for _ in range(10)]
        for i in range(1, n):
            for j in range(10):
                for reach in self.canReach(j):
                    dp[i][j] += dp[i - 1][reach]
                    dp[i][j] %= (10 ** 9 + 7)
        return sum(dp[n - 1]) % (10 ** 9 + 7)
```

[1223. Dice Roll Simulation](https://leetcode-cn.com/problems/dice-roll-simulation/) `Medium`

æ¯ä¸ªéª°å­ä¸èƒ½è¿ç»­å‡ºç°rollMax(i)æ¬¡ï¼Œç»Ÿè®¡æ—¶éœ€è¦æ³¨æ„ã€‚

```python

class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        p = 10**9+7
        dp = [[0 for _ in range(6)] for _ in range(n + 1)]
        sum = [0 for _ in range(n + 1)]
        sum[0] = 1
        # dp i, j . res for roll i times when last with face j
        for i in range(1, n + 1):
            for j in range(6):
                for k in range(1, rollMax[j] + 1):
                    if i >= k:
                        dp[i][j] += sum[i - k] - dp[i - k][j]
                        dp[i][j] %= p
                sum[i] += dp[i][j]
        return sum[n] % p

```

[416. Partition Equal Subset Sum](https://leetcode-cn.com/problems/partition-equal-subset-sum/) `Medium`

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        totalSum = sum(nums)
        if totalSum % 2 == 1:
            return False
        val = int(totalSum / 2)
        dp = [False for _ in range(val + 1)]
        dp[0] = True
        for i in range(1, len(nums) + 1):
            for j in range(val, 0, -1):
                dp[j] = dp[j] or dp[j - nums[i - 1]] if j >= nums[i - 1] else False
        return dp[val]

```

[808. Soup Servings](https://leetcode-cn.com/problems/soup-servings/) `Medium`

```python
class Solution:
    def soupServings(self, N: int) -> float:
        memo = {}
        def f(A: int, B: int) -> float:
            if (A,B) in memo:
                return memo.get((A,B))
            # corner case
            if A <= 0 and B > 0:
                return 1
            elif A <= 0 and B <= 0:
                return 0.5
            elif B <=0:
                return 0
            # main code
            r = 0.25 * (f(A - 100, B) + f(A - 75, B - 25) + f(A - 50, B - 50) + f(A - 25, B - 75))
            memo[(A,B)] = r
            return r
        if N > 6000:
            return 1
        return f(N, N)
```

[790. Domino and Tromino Tiling](https://leetcode-cn.com/problems/domino-and-tromino-tiling/) `Medium`

```python
class Solution:
    def numTilings(self, N: int) -> int:
        # 1, 2, 3 = top, down, top&down
        memo = {}
        p = 10 ** 9 + 7

        def f(i, t):
            if (i, t) in memo:
                return memo[(i, t)]
            # corner case:
            if i <= 0:
                if i == 0 and t == 3:
                    return 1
                else:
                    return 0
            if t == 1:
                r = f(i - 2, 3)%p + f(i - 1, 2)%p
            elif t == 2:
                r = f(i - 2, 3)%p + f(i - 1, 1)%p
            else:
                r = f(i - 1, 3)%p + f(i - 1, 1)%p + f(i - 1, 2)%p + f(i - 2, 3)%p
            r = r % p
            memo[(i, t)] = r
            return r

        #
        # assert f(1, 3) == 1
        # assert f(1, 1) == f(1, 2) == 0
        # assert f(2, 1) == f(2, 2) == 1
        # assert f(2, 3) == 2

        return f(N, 3)
```

[801. Minimum Swaps To Make Sequences Increasing](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/)`Medium`

```python
class Solution:
    def minSwap(self, A: List[int], B: List[int]) -> int:
        # enum: k=0, not swap, k=1, swap
        N = len(A)
        dp = [[N] * 2 for _ in range(N + 1)]
        dp[0] = [0, 1]
        for i in range(1, N):
            a, a1, b, b1 = A[i - 1], A[i], B[i - 1], B[i]
            if a1 > a and b1 > b:
                dp[i][0] = min(dp[i][0], dp[i - 1][0])
                dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1)
            if a1 > b and b1 > a:
                dp[i][0] = min(dp[i][0], dp[i - 1][1])
                dp[i][1] = min(dp[i][1], dp[i - 1][0] + 1)
        return min(dp[N-1])
```

[673. Number of Longest Increasing Subsequence](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) `Medium`

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        N = len(nums)
        lengths = [1] * (N)
        count = [1] * (N)
        for i, v in enumerate(nums):
            for j in range(i):
                if v > nums[j]:
                    if lengths[i] < lengths[j] + 1:
                        lengths[i] = lengths[j] + 1
                        count[i] = count[j]
                    elif lengths[i] == lengths[j] + 1:
                        count[i] += count[j]
        max_len = max(lengths)
        return sum(c for i, c in enumerate(count) if lengths[i] == max_len)

```

[63. Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/) `Medium`

```c++
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		vector<vector<int>> d(obstacleGrid.size(), vector<int>(obstacleGrid[0].size(),0));
		if(obstacleGrid[0][0]==0)
			d[0][0] = 1;
		for (int i = 0; i < obstacleGrid.size(); i++) {
			for (int j = 0; j < obstacleGrid[0].size(); j++) {
				if (obstacleGrid[i][j] == 1)
					continue;
				if (i > 0)
					d[i][j] += d[i - 1][j];
				if (j > 0)
					d[i][j] += d[i][j - 1];
			}
		}
		return d[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1];
	}
};
```

[576. Out of Boundary Paths](https://leetcode-cn.com/problems/out-of-boundary-paths/) `Medium`

```python

class Solution:
    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:
        dir = (-1, 0, 1, 0, -1)
        memo = {}
        p = 10**9+7

        def f(x, y, l):
            if (x,y,l) in memo:
                return memo.get((x,y,l))
            if x < 0 or x >= m or y < 0 or y >= n:
                return 1
            if l <= 0:
                return 0
            r = 0
            for k in range(4):
                r += f(x + dir[k], y + dir[k + 1], l - 1)
            r %= p
            memo[(x,y,l)] = r
            return r

        return f(i, j, N)

```

[1269. Number of Ways to Stay in the Same Place After Some Steps](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/) `Hard`

[1220. Count Vowels Permutation](https://leetcode-cn.com/problems/count-vowels-permutation/) `Hard`

## Merging Intervals

------


Generate problem statement for this pattern


### Statement

> Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.
### Approach

> Find all optimal solutions for every interval and return the best possible answer.
```
// from i to j
dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]
```


Get the best from the left and right sides and add a solution for the current position.

```
for(int l = 1; l<n; l++) {
   for(int i = 0; i<n-l; i++) {
       int j = i+l;
       for(int k = i; k<j; k++) {
           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
       }
   }
}
 
return dp[0][n-1]
```
### Similar Problems

[1130. Minimum Cost Tree From Leaf Values](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/) `Medium`

```
for (int l = 1; l < n; ++l) {
   for (int i = 0; i < n - l; ++i) {
       int j = i + l;
       dp[i][j] = INT_MAX;
       for (int k = i; k < j; ++k) {
           dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]);
       }
   }
}
```

[96. Unique Binary Search Trees](https://leetcode-cn.com/problems/unique-binary-search-trees/) `Medium`

ä¸€ä¸ª1-nçš„æ•°ç»„èƒ½ç»„æˆå¤šå°‘ç§bst

```pythonn
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
        for i in range(1, n + 1):
            dp[i][i] = 1
        for l in range(1, n):
            for i in range(1, n - l + 1):
                j = i + l
                for k in range(i, j + 1):
                    dp[i][j] += (dp[i][k-1] if k-1>=i else 1) * (dp[k+1][j] if k+1<=j else 1)
        return dp[1][n]
```

[1039. Minimum Score Triangulation of Polygon](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/) `Medium`

å¤šè¾¹å½¢æ‹†æˆä¸€äº›ä¸‰è§’å½¢

```python
class Solution:
    def minScoreTriangulation(self, A: List[int]) -> int:
        dp = [[0] * 50 for _ in range(50)]

        def f(i=0, j=0):
            if j == 0:
                j = len(A) - 1
            if dp[i][j] != 0:
                return dp[i][j]
            if i != len(A) - 1 and i >= j - 1:
                return 0
            res = sys.maxsize
            for k in range(i + 1, j):
                res = min(res, f(i, k) + A[i] * A[k] * A[j] + f(k, j))
            dp[i][j] = res
            return res

```

[546. Remove Boxes](https://leetcode-cn.com/problems/remove-boxes/) `Medium`

```python
class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        memo = {}

        def f(i, j, k):
            if i > j:
                return 0
            if (i, j, k) in memo:
                return memo.get((i, j, k))
            while i + 1 < j and boxes[i + 1] == boxes[i]:
                i += 1
                k += 1
            res = (1 + k) * (1 + k) + f(i + 1, j, 0)
            for m in range(i + 1, j + 1):
                if boxes[m] == boxes[i]:
                    res = max(res, f(i + 1, m - 1, 0) + f(m, j, 1 + k))
            memo[(i, j, k)] = res
            return res
        return f(0, len(boxes) - 1, 0)
```

[1000. Minimum Cost to Merge Stones](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/) `Medium`  åŒºé—´dpé—®é¢˜ï¼Œ[å‚è€ƒ](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/solution/yi-dong-you-yi-dao-nan-yi-bu-bu-shuo-ming-si-lu-he/)

[312. Burst Balloons](https://leetcode-cn.com/problems/burst-balloons/) `Hard`

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + [i for i in nums if i > 0] + [1]
        N = len(nums)
        dp = [[0] * N for _ in range(N)]
        for l in range(2, N):
            for left in range(N - l):
                right = left + l
                for k in range(left + 1, right):
                    dp[left][right] = max(dp[left][right],
                                          dp[left][k] + nums[left] * nums[k] * nums[right] + dp[k][right])
        return dp[0][-1]
```

[375. Guess Number Higher or Lower II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/) `Medium`

```python
class Solution:
    def getMoneyAmount(self, n: int) -> int:
        inf = float('inf')
        memo = {}

        def f(i, j):
            if j <= i:
                return 0
            key = (i, j)
            if key in memo:
                return memo[key]
            res = inf
            for k in range(i, j + 1):
                res = min(res, k + max(f(i, k - 1), f(k + 1, j)))
            memo[key] = res
            return res

        r = f(1, n)
        return r
```



## DP on Strings

------


General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big


### Statement

> Given two strings `s1` and `s2`, return `some result`.
### Approach

> Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.
```
// i - indexing string s1
// j - indexing string s2
for (int i = 1; i <= n; ++i) {
   for (int j = 1; j <= m; ++j) {
       if (s1[i-1] == s2[j-1]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
```
> If you are given one string `s` the approach may little vary

```
for (int l = 1; l < n; ++l) {
   for (int i = 0; i < n-l; ++i) {
       int j = i + l;
       if (s[i] == s[j]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
```

[1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/) `Medium`

```
for (int i = 1; i <= n; ++i) {
   for (int j = 1; j <= m; ++j) {
       if (text1[i-1] == text2[j-1]) {
           dp[i][j] = dp[i-1][j-1] + 1;
       } else {
           dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
       }
   }
}
```

[647. Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings/) `Medium`

```
for (int l = 1; l < n; ++l) {
   for (int i = 0; i < n-l; ++i) {
       int j = i + l;
       if (s[i] == s[j] && dp[i+1][j-1] == j-i-1) {
           dp[i][j] = dp[i+1][j-1] + 2;
       } else {
           dp[i][j] = 0;
       }
   }
}
```

[516. Longest Palindromic Subsequence](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) `Medium`

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];
        
        for (int i = s.length() - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i+1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][s.length()-1];
    }
}
```

[1092. Shortest Common Supersequence](https://leetcode-cn.com/problems/shortest-common-supersequence/) `Medium`

```python
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n1, n2 = len(str1), len(str2)
        dp = [[""] * (n2 + 1) for _ in range(n1 + 1)]
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + str1[i - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)
        lcs = dp[n1][n2]
        res = ""
        i, j = 0, 0
        for c in lcs:
            while str1[i] != c:
                res += str1[i]
                i += 1
            while str2[j] != c:
                res += str2[j]
                j += 1
            res += c
            i+=1
            j+=1
        res = res + str1[i:] + str2[j:]
        return res
```

[72. Edit Distance](https://leetcode-cn.com/problems/edit-distance/) `Hard`

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n1, n2 = len(word1), len(word2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        for i in range(1, n1 + 1):
            dp[i][0] = i

        for j in range(1, n2 + 1):
            dp[0][j] = j
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        return dp[n1][n2]
```

[115. Distinct Subsequences](https://leetcode-cn.com/problems/distinct-subsequences/) `Hard`

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(t), len(s)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        for j in range(0, n2+1):
            dp[0][j] = 1 # ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªï¼Ÿ å› ä¸ºå•ä¸ªå­—ç¬¦dpè®¡ç®—ä¸å¯¹ï¼Œæ¯”å¦‚aaaï¼Œaçš„æƒ…å†µ
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if t[i - 1] == s[j - 1]:
                    dp[i][j] = dp[i-1][j-1]+dp[i][j-1]
                else:
                    dp[i][j] = dp[i][j-1]
        return dp[n1][n2]
```

[712. Minimum ASCII Delete Sum for Two Strings](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/) `Medium`

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        n1, n2 = len(s1), len(s2)
        dp = [[sys.maxsize] * (n2 + 1) for _ in range(n1 + 1)]
        dp[0][0] = 0
        for i in range(1, n1 + 1):
            dp[i][0] = dp[i - 1][0] + ord(s1[i-1])
        for j in range(1, n2 + 1):
            dp[0][j] = dp[0][j - 1] + ord(s2[j-1])
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i][j - 1] + ord(s2[j-1]), dp[i - 1][j] + ord(s1[i-1]))
        return dp[n1][n2]
```

[5. Longest Palindromic Substring](https://leetcode-cn.com/problems/longest-palindromic-substring/) `Medium`

## Decision Making

------


The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.

### Statement

> Given a set of values find an answer with an option to choose or ignore the current value.
### Approach

> If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.
```
// i - indexing a set of values
// j - options to ignore j values
for (int i = 1; i < n; ++i) {
   for (int j = 1; j <= k; ++j) {
       dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]});
       dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]});
   }
}
```

[198. House Robber](https://leetcode-cn.com/problems/house-robber/) `Easy`

```
for (int i = 1; i < n; ++i) {
   dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]);
   dp[i][0] = dp[i-1][1];
}
```

[121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) `Easy`

[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) `Medium`

æ¯æ¬¡äº¤æ˜“æœ‰è´¹ç”¨fee

```c++
class Solution {
public:
	int maxProfit(vector<int>& prices, int fee) {
		if (prices.size() <= 1) return 0;
		vector<int> buy(prices.size()), sell(prices.size());
		buy[0] = -prices[0] - fee;
		for (int i = 1; i < prices.size(); i++) {
			buy[i] = max(buy[i - 1], sell[i - 1] - prices[i] - fee);
			sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]);
		}
		return sell[prices.size() - 1];
	}
};
```

[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) `Medium`

cooldown 1 day

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # corner cases
        if len(prices) == 0:
            return 0
        # main part
        sell = [0] * (len(prices))
        buy = [float("-inf")] * (len(prices))
        buy[0] = -prices[0]
        for i in range(1, len(prices)):
            buy[i] = max((sell[i-2] if i>=2 else 0) -prices[i], buy[i-1])
            sell[i] = max(sell[i-1], buy[i-1]+prices[i])
        return sell[len(prices)-1]
```

[123. Best Time to Buy and Sell Stock III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/) `Hard`

![image](https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/fac8566877dab66694b8ab827b73fe8f.png)



where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It's not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn't trade on that day.

```python
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        n = len(prices)
        K = 2
        # corner case
        if n == 0:
            return 0
        # main part
        dp = [[0] * n for _ in range(K + 1)]
        for i in range(1, K + 1):
            max_diff = float('-inf')
            for j in range(1, n):
                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j - 1])
                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
        return dp[K][n - 1]
```

å› æ­¤æ­£ç¡®çš„åº”è¯¥ä¸‹é¢è¿™ä¸ª

```python
max_diff = max(max_diff, (dp[i - 1][j - 2] if j >= 2 else 0) - prices[j - 1])
```



```python
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """

    def maxProfit(self, prices):
        n = len(prices)
        K = 2
        # corner case
        if n == 0:
            return 0
        # main part
        dp = [[0] * n for _ in range(K + 1)]
        for i in range(1, K + 1):
            max_diff = float('-inf')
            for j in range(1, n):
                max_diff = max(max_diff, (dp[i - 1][j - 2] if j >= 2 else 0) - prices[j - 1])
                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
        return dp[K][n - 1]

```

[188. Best Time to Buy and Sell Stock IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/) `Hard`

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        # corner case
        if n == 0:
            return 0
        # main part
        dp = [[0] * n for _ in range(k + 1)]
        for i in range(1, k + 1):
            max_diff = float('-inf')
            for j in range(1, n):
                max_diff = max(max_diff, (dp[i - 1][j - 2] if j >= 2 else 0) - prices[j - 1])
                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
        return dp[k][n - 1]

```

ä¸€ä¸ªæ•°ç»„è®°å½•sell, ä¸€ä¸ªè®°å½•buy

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        # corner case
        if n == 0 or k==0:
            return 0
        # main part
        sell = [[0 for _ in range(n)] for _ in range(k + 1)]
        buy = [[float('-inf') for _ in range(n)] for _ in range(k + 1)]
        buy[1][0] = -prices[0]
        res = 0
        for i in range(1, k + 1):
            for j in range(1, n):
                buy[i][j] = max(buy[i][j - 1], sell[i - 1][j - 1] - prices[j])
                sell[i][j] = max(sell[i][j - 1], buy[i][j - 1] + prices[j])
                res = max(res, sell[i][j])
        return res
```

I hope these tips will be helpful ğŸ˜Š



