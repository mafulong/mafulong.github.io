---
layout: post
category: Algorithms
title: 链表
tags: Algorithms
---



## 快慢指针找中间节点

如果是偶数节点靠前的，fast = head.fast
是靠后的，fast = head

```python

def middle(self, head):
  # 找中间节点
  '''
        如果是偶数节点靠前的，fast = head.fast
        是靠后的，fast = head
        '''
  newhead = ListNode(0)
  newhead.next = head
  pre = newhead
  slow, fast = head, head.next
  while fast and fast.next:
    fast = fast.next.next
    pre = slow
    slow = slow.next
    print(pre.val, slow.val)
    return slow
```

## 复杂链表的复制

[两种方法：](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/fu-za-lian-biao-de-fu-zhi-by-leetcode-so-9ik5/
)

1. 迭代+拆分: 可以每个节点都在后面有个一样的，然后设置random成员, 再拆分下拉
2. 回溯+hash: 可以递归的复制，记得缓存下对应的复制值，没有的话就生成一个，有的话直接引用。

```c++
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};

```

## 链表反转

```python
def reverse1(self, head):
  # 递归
  if not head or not head.next: return head
  last = self.reverse1(head.next)
  head.next.next = head
  head.next = None
  return last

def reverse2(self, head):
  # 改变当前next值，pre->head->nxt, 改head的
  pre = None
  while head:
    nxt = head.next
    head.next = pre
    pre = head
    head = nxt
    return pre

  def reverse3(self, head):
    # 头插法反转
    newhead = ListNode(0)
    while head:
      nxt = head.next
      x = newhead.next
      head.next = x
      newhead.next = head
      head = nxt
      return newhead.nex
```

## 链表重构

参考：[https://leetcode-cn.com/problems/reorder-list/](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …



## 判断是否有环和找环的入口

一种方法是hash表，这里不多说。下面展示快慢指针做法

参考：[https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)



注意这里fast = head. 这是标准用法.

**检查是否有环:**

```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        slow, fast = head, head
        while fast:
            slow = slow.next
            if not fast.next: return False
            fast = fast.next.next
            if fast == slow:
                return True
        return False
```

**找环的入口：**


```python
# 找环入口
# 先找到slow和fast相遇点，然后fast从head开始，一样速度遍历
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while fast:
            slow = slow.next
            if not fast.next:
                return None
            fast = fast.next.next
            if fast == slow:
                fast = head
                while fast != slow:
                    slow = slow.next
                    fast = fast.next
                return fast
        return None

```

## 两个链表的第一个公共节点

[题目: 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)



一种方法是hash表。

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走 （因为2个链表用公共的尾部）

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

