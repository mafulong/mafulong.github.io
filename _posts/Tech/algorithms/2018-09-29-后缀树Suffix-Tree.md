---
layout: post
category: 算法知识
title: 后缀树Suffix-Tree
---

[参考1](https://blog.csdn.net/u013949069/article/details/78056102)

[参考2](https://blog.csdn.net/v_july_v/article/details/6897097)

#### 简介

后缀树，它描述了给定字符串的所有后缀，许多重要的字符串操作都能够在后缀树上快速地实现。

一个长度为n的字符串S，它的后缀树定义为一棵满足如下条件的树：

1. 从根到树叶的路径与S的后缀一一对应。即每条路径惟一代表了S的一个后缀；
2. 每条边都代表一个非空的字符串；
3. 所有内部节点（根节点除外）都有至少两个子节点。

由于并非所有的字符串都存在这样的树，因此S通常使用一个终止符号进行填充（通常使用$）。

![](https://images0.cnblogs.com/blog/422951/201304/05153837-4015b84ed2c04d3c91489be95ebaaa5f.gif)

#### 优点
匹配快。对于长度为m的模式串，只需花费至多O(m)的时间进行匹配。

空间省。Suffix tree的空间耗费要低于Suffix trie，因为Suffix tree除根节点外不允许其内部节点只含单个子节点，因此它是Suffix trie的压缩表示。

![](https://images0.cnblogs.com/blog/422951/201304/05153857-70581b5d09be49acaadcd5db08fbd9be.gif)

![](https://images0.cnblogs.com/blog/422951/201304/05153914-07a04ec22ceb4a6dad533a75a60b2d7a.gif)

![](https://img-blog.csdn.net/20170922094213854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzk0OTA2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



#### 应用

后缀树（Suffix tree）是一种树形数据结构，能快速解决很多关于字符串的问题。后缀樹的概念最早由Weiner 於1973年提出，既而由McCreight 在1976年和Ukkonen在1992年和1995年加以改進完善。

总结起来，它主要可以解决类似如下的一些问题：

- 查找字符串o是否在字符串S中
- 指定字符串T在字符串S中的重复次数
- 字符串S中的最长重复子串
- 两个字符串S1，S2的最长公共部分

这些问题如何解决，我们最后再谈。


查找字符串o是否在字符串S中  
解法：如果S存在于o中，那么S必然是o的某一个后缀的前缀，按照Trie树搜索前缀的方法，遍历后缀树即可。复杂度为O(M)，其中M为字符串S的长度。

指定字符串T在字符串S中的重复次数  
解法：在字符串S后追加$构造包含所有后缀的完整后缀树，在其中找到T子川，的最后一个节点，该节点拥有的叶子节点个数几位重复次数，复杂度为O(M)，M为T的长度。

字符串S中的最长重复子串  
解法：遍历整个后缀树，找到深度最大的非叶子节点，复杂度为O(N)，N为字符串的长度。

两个字符串S1，S2的最长公共部分  
解法：分别 为S1、S2追加#、$作为末尾，把他们压入同一个后缀树，然后找到最深的非叶子节点，该节点的叶子节点中，既有#又有$。复杂度为构造两颗后缀树的复杂度之和，取最大即可max(O(N),O(M))，其中N、M为S1、S2的长度，假设我们以线性时间构造了后缀树，下位讲解构造方法。

