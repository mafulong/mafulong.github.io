---
layout: post
category: Algorithms
title: 字符串匹配KMP算法
tags: Algorithms
---
![](https://raw.githubusercontent.com/mafulong/mdPic/master/images/ORDxbX6.jpg)

![image-20210123112420296](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/20210123112425.png)





![](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/20210123112457.png)


```c++
//cpp:
next[1] = 0；
Assuming that ：next[j] = k；and if  T[j] = T[k]
Then ： next[j+1] = k+1 = next[j]+1
If   T[j] != T[k]  then backtrack to check 
 T[j] == T[ k’]，… then next[j+1] = next[k] +1

```

## 最终版

```python
def kmp_search(s=str(), p=str()):
    next = get_next(p)
    i, j = 0, 0
    while i < len(s) and j < len(p):
        if j == -1 or s[i] == p[j]:
            i, j = i + 1, j + 1
        else:
            j = next[j]
    if j == len(p):
        return i - j
    else:
        return -1


def get_next(p=str()):
    next = [0] * len(p)
    next[0] = -1
    i, j = 0, -1
    while i < len(p) - 1:
        if j == -1 or (p[i] == p[j]):
            i, j = i + 1, j + 1
            if p[i] != p[j]:
                next[i] = j
            else:
                next[i] = next[j]
        else:
            j = next[j]
    return next


if __name__ == '__main__':
    s = 'abcdabcefgsabc'
    # print get_next(s)
    print kmp_search(s, "abcefg")
```



## KMP算法

特意设置next[0] = -1, 因为当next[0]=0地时候会死循环，无限地j=next[j], j=0.

```c++
int KmpSearch(char* s, char* p)  
{  
    int i = 0;  
    int j = 0;  
    int sLen = strlen(s);  
    int pLen = strlen(p);  
    while (i < sLen && j < pLen)  
    {  
        //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      
        if (j == -1 || s[i] == p[j])  
        {  
            i++;  
            j++;  
        }  
        else  
        {  
            //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      
            //next[j]即为j所对应的next值        
            j = next[j];  
        }  
    }  
    if (j == pLen)  
        return i - j;  
    else  
        return -1;  
} 
```

## 求next数组

最好理解的是

这里注意是先i++,j++，再赋值next，因为kmp用next地时候是if s[i] != p[j], j = next[j]. 

```c++
void getNext(string t,int next[]){
  	next[0] = -1
    i,j=0,-1
    while(i<length){
        if(j==-1||t[i]===t[j]){ i++;j++;next[i]=j}
        else
            j=next[j];
    }
}
```

为了解决比如aaaab的next数组地问题, next只会往后移1位，优化为
```c++
void getNext(string t,int next[]){
    next[0] = -1
    i,j=0,-1
    while(i<length){
        if(j==-1||t[i]===t[j]){ 
            i++;j++;
            if(t[i]!=t[j])
                next[i]=j
            else
                next[i]=next[j];//解决aaaaab问题
        }
        else
            j=next[j];
    }
}
```

但代码里都是0开始的，所以j开始时都是-1

```c++
//优化过后的next 数组求法  
void GetNextval(char* p, int next[])  
{  
    int pLen = strlen(p);  
    next[0] = -1;  
    int k = -1;  
    int j = 0;  
    while (j < pLen - 1)  
    {  
        //p[k]表示前缀，p[j]表示后缀    
        if (k == -1 || p[j] == p[k])  
        {  
            ++j;  
            ++k;  
            //较之前next数组求法，改动在下面4行  
            if (p[j] != p[k])  
                next[j] = k;   //之前只有这一行  
            else  
                //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]  
                next[j] = next[k];  
        }  
        else  
        {  
            k = next[k];  
        }  
    }  
}  
```

可以直接看最后下面这个

```python
def kmp_search(s=str(), p=str()):
    next = get_next(p)
    i, j = 0, 0
    while i < len(s) and j < len(p):
        if j == -1 or s[i] == p[j]:
            i, j = i + 1, j + 1
        else:
            j = next[j]
    if j == len(p):
        return i - j
    else:
        return -1


def get_next(p=str()):
    next = [0] * len(p)
    next[0] = -1
    i, j = 0, -1
    while i < len(p) - 1:
        if j == -1 or (p[i] == p[j]):
            i, j = i + 1, j + 1
            if p[i] != p[j]:
                next[i] = j
            else:
                next[i] = next[j]
        else:
            j = next[j]
    return next


if __name__ == '__main__':
    s = 'abcdabcefgsabc'
    # print get_next(s)
    print kmp_search(s, "abcefg")

```


```python
def kmp_seartch(s: str, p: str):
    def get_next(p: str):
        next = [0] * len(p)
        next[0] = -1
        k = -1
        i = 0
        while i < len(p) - 1:
            if k == -1 or p[i] == p[k]:
                k += 1
                i += 1
                if p[i] == p[k]:
                    next[i] = next[k]
                else:
                    next[i] = k
            else:
                k = next[k]
        return next

    next = get_next(p)
    i, j = 0, 0
    while i < len(s) and j < len(p):
        if j == -1 or s[i] == p[j]:
            i += 1
            j += 1
            if j == len(p):
                return i - j
        else:
            j = next[j]
    return -1

```