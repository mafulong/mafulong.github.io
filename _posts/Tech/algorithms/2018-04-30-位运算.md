---
layout: post
category: algorithms
title: 位运算
tags: Algorithms
---

n&(n-1)用法：包括判断是否2的次幂，求二进制表示中1的个数，求n!中有多少个k

[链接](http://mafulong.top/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/2018/04/21/n&(n-1)%E7%9A%84%E7%94%A8%E6%B3%95.html)

## 基本的操作：

1. ```&``` 按位与 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
2. ```|``` 按位或 两个相应的二进制位中只要有一个为1，该位的结果值为1
3. ```^``` 按位异或 若参加运算的两个二进制位值相同则为0，否则为1
4. ```~``` 取反 ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0
5. ```<<``` 左移 用来将一个数的各二进制位全部左移N位，右补0
6. ```>>``` 右移 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0
7. 同或   ```~(^)``` // 异或后求反

## 1、“按位与”运算符（&）

取出某个数的某一位

```c++
bool get_bit(int t,int x) {
    //    在 t 中，取出第 x 位     --从零开始
    return t & (1<<(x));
}
```

若有一个整数a(2byte),想要取其中的低字节，只需要将a与8个1按位与即可。


保留指定位：与一个数进行“按位与”运算，此数在该位取1.例如：有一数84，即01010100（2），想把其中从左边算起的第3，4，5，7，8位保留下来，运算如下：
 01010100(2)
&00111011(2)
 00010000(2)
即：a=84,b=59
c=a&b=16

## 2、“按位或”运算符（|）
应用：按位或运算常用来对一个数据的某些位定值为1。例如：如果想使一个数a的低4位改为1，则只需要
将a与17（8）进行按位或运算即可。

## 3、“异或”运算符（^）
（1）使特定位翻转
设有数01111010（2），想使其低4位翻转，即1变0，0变1.可以将其与00001111（2）进行“异或”运算，

(２)与0相“异或”，保留原值
例如：012^00=012  因为原数中的1与0进行异或运算得1，0^0得0，故保留原数。

(３) 交换两个值，不用临时变量想将ａ和ｂ的值互换，可以用以下赋值语句实现：
    ａ＝a∧b;
    ｂ＝b∧a;
    ａ＝a∧b;

## 4、“取反”运算符（~）
他是一元运算符，用于求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变为1。

## 5、左移运算符（<<）
左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。

## 6、右移运算符（>>）
右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负
值），移到右端的低位被舍弃，对于无符号数，高位补0。对于有符号数，某些机器将对左边空出的部分
用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。注
意：对无符号数,右移时左边高位移入0；对于有符号的值,如果原来符号位为0(该数为正),则左边也是移
入0。如果符号位原来为1(即负数),则左边移入0还是1,要取决于所用的计算机系统。有的系统移入0,有的
系统移入1。移入0的称为“逻辑移位”,即简单移位；移入1的称为“算术移位”。 

## 应用举例
(1) 判断int型变量a是奇数还是偶数           
       a&1   = 0 偶数
       a&1 =   1 奇数

(2) 取int型变量a的第k位 (k=0,1,2……sizeof(int))，即```a>>k&1```

(3) 将int型变量a的第k位清0，即```a=a&~(1<<k)```

(4) 将int型变量a的第k位置1，即```a=a|(1<<k)```

(5) int型变量循环左移k次，即```a=a<<k|a>>16-k ```  (设sizeof(int)=16)

(6) int型变量a循环右移k次，即```a=a>>k|a<<16-k```   (设sizeof(int)=16)

(7)整数的平均值   
对于两个整数x,y，如果用 (x+y)/2 求平均值，会产生溢出，因为 x+y 可能会大于INT_MAX，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法：
```c++
int average(int x, int y)   //返回X,Y 的平均值
{   
     return (x&y)+((x^y)>>1);
}
```

(8)判断一个整数是不是2的幂,对于一个数 x >= 0，判断他是不是2的幂
```c++
boolean power2(int x)
{
    return ((x&(x-1))==0)&&(x!=0)；
}
```

(9)不用temp交换两个整数
```c++
void swap(int x , int y)
{
    x ^= y;
    y ^= x;
    x ^= y;
}
```

(10)计算绝对值
```c++
int abs( int x )
{
int y ;
y = x >> 31 ;
return (x^y)-y ;        //or: (x+y)^y
}
```

(11)取模运算转化成位运算 (在不产生溢出的情况下)
         a % (2^n) 等价于 a & (2^n - 1)

(12)乘法运算转化成位运算 (在不产生溢出的情况下)

         a * (2^n) 等价于 a<< n

(13)除法运算转化成位运算 (在不产生溢出的情况下)

         a / (2^n) 等价于 a>> n
        例: 12/8 == 12>>3

(14) a % 2 等价于 a & 1       

(15) if (x == a) x= b;
　　          else x= a;
　　      等价于 x= a ^ b ^ x;

(16) x 的 相反数 表示为 (~x+1)

把右边连续的1变成```0 ¦ (100101111->100100000) ¦ x & (x+1)```

把右起第一个0变成```1 ¦ (100101111->100111111) ¦ x ¦ (x+1)```

把右边连续的0变成```1 ¦ (11011000->11011111) ¦ x ¦ (x-1)```

[参考链接](https://blog.csdn.net/liangxingda/article/details/52209084)