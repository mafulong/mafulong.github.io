---
layout: post
category: Others
title: 编码和压缩
tags: Others
---

## 编码和压缩

## 编码前置知识

### 变长编码和定长编码：

- 定长编码使用固定字节数来表示，如int32类型固定使用4个字节表示
- 变长编码是需要几个字节就使用几个字节，如对于int32类型的数字1来说，只需要1个字节

### 小端序和大端序

- Big-Endian：大端序，高位字节在前，低位字节在后，这是人类读写数值的方法
- Little-Endian：小端序，低位地址在前，高位地址在后

### TLV编码格式

TLV即Tag-Length-Value, Tag作为该字段的唯一标识，Length代表Value数据域的长度，最后即Value数据本身

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20211220153141.png)



### 负数的处理

如果要表示的数是一个负数，采用上面所说的方式编码，就会占用很多字节，因为对于比较常用（数值比较大）的负数来说，转成补码后会有很多个1，也就是说占用的字节会比较多，这样如果还采用上面那种方式编码，就得不偿失了，因此Google又新增加了一种数据类型，叫sint，专门用来处理这些负数，其实现原理是采用zigzag编码，zigzag编码的映射函数为：

```
ZigZag(n) = (n << 1) ^ (n << k)，k为31或者63
```

最终的效果就是将负数映射为正整数，了解到这里即可

## thrift

Thrift是一套包含序列化功能和支持服务通信的RPC框架，主要包含三大部分：**代码生成**、**序列化框架**、**RPC框架**，大致相当于protoc + protobuffer + grpc，并且支持大量语言，保证常用功能在跨语言间功能一致，是一套全栈式的RPC解决方案。

二进制编码常用TLV编码实现，TLV是指由数据的类型Tag，数据的长度Length，数据的值Value组成的结构体，几乎可以描述任意数据类型，TLV的Value也可以是一个TLV结构，正因为这种嵌套的特性，可以让我们用来包装协议的实现。Thrift中Binary和Compact编码实现都是采用的TLV编码变种实现，两者不同点主要在于对整数类型处理方面。

每个字段又有一个编号，因此是一个四元组: (id,type, length,value) 其中length在定长里不用，在非定长里用最高位表示。

### binary序列化

简单数据类型为定长编码，包含一个字节类型标识+两个字节编号+类型对应定长值。因此这里就不用长度来记录了，因为是定长。

### compact序列化

区别就是使用不定长编码，每个字节，我们只使用低7位，最高的一位作为一个标志位（msb）：

- 1：下一个byte也是该数字的一部分
- 0：下一个byte不是该数字的一部分

该编码好处是对于小数字采用更少字节，大数字采用更多字节，但大部分使用都是小数字，则整体看压缩作用明显。

对于负数用了最高位，会先做个转换。

## protocol buffer

## 压缩算法

### RLE

RLE 又叫 Run Length Encoding ，是一个针对无损压缩的非常简单的算法。它用重复字节和重复的次数来简单描述来代替重复的字节。尽管简单并且对于通常的压缩非常低效，但它有的时候却非常有用（例如， JPEG 就使用它）。

比如aaabbb变成3a3b

### 哈夫曼

哈夫曼编码是无损压缩当中最好的方法。它使用预先二进制描述来替换每个符号，长度由特殊符号出现的频率决定。常见的符号需要很少的位来表示，而不常见的符号需要很多为来表示。

哈夫曼算法在改变任何符号二进制编码引起少量密集表现方面是最佳的。然而，它并不处理符号的顺序和重复或序号的序列。



