---
layout: post
category: Java
title: java泛型
tags: Java
---

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

其实就是一种编译检查的工具，类似某些注解一样。

## 泛型的使用

### 泛型方法

```java
   public static < E > void printArray( E[] inputArray )
   {
      // 输出数组元素
         for ( E element : inputArray ){
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
```

### 泛型类

泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。

```java
public class Box<T> {
  private T t;
  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    Box<String> stringBox = new Box<String>();
  }
}
```

### 泛型接口

```java
public interface Generator<T> {
    public T next();
}
```

在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型

## 泛型的好处

① 类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作 java.lang.ClassCastException 展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。

② 消除了代码中许多的强制类型转换，增强了代码的可读性。

③ 为较大的优化带来了可能。

## 类型通配符

### 为什么需要类型通配符

java 数组具有协变性：

- class Circle implements Shape, 如果给 某方法(Shape[] arr) 传递一个 Circle[] 类型的数组，这是可以的，编译通过，也能正常运行。也就是说：Circle[] IS-A Shape[]

集合无协变性：

- 给`totalArea(Collection<Shape> arr)`传递一个 `Collection<Circle>`类型的集合，这是不可以的。编译器就会报如下的错误：

  - `The method totalArea(Collection<Shape>) in the type Demo is not applicable for the arguments (Collection<Circle>)`

- 也就是说，形参是`List<Object>`，你无法传入`List<Integer>`,`List<Integer>`,`ArrayList<Integer>`等，在编译期间就出现错误，它们是不同的类型。

有了类型通配符后，就可以约束泛型的父类或者子类，然后就可以让带有类型通配符泛型的 List 有数组一样的协变性，比如

```java
//假如B继承A
List<B>可以赋值给List<? extends A>
List<? extends B>也可以赋值给List<? extends A>
```

注意如下是不可以的

```
The type List<?extends A>is assignable to List<A>.
```

### 类型通配符

类型通配符一般是使用?代替具体的类型参数。

**`<? extends T>`和`<? super T>`的区别**

前者表示该通配符所代表的类型是 T 类型的子类。

后者表示该通配符所代表的类型是 T 类型的父类。

<?> 是无界通配符。

#### PECS 原则

“Producer Extends” – 如果你需要一个只读 List，用它来 produce T，那么使用? extends

“Consumer Super” – 如果你需要一个只写 List，用它来 consume T，那么使用? super

如果阅读过一些 Java 集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样：

```java
public class Collections {
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (int i=0; i<src.size(); i++)
            dest.set(i, src.get(i));
    }
}
```

### List<?>

> [参考](https://stackoverflow.com/questions/1844770/what-does-list-mean-in-java-generics)

The `?`, or unbounded wildcard, means that the type of the object is not specified. It could be unknown, could be meant for multiple possible values or might be just plain irrelevant. `List<?>`, is pronounced "List of unknown."

Unbounded Wildcards ?

> The unbounded wildcard type is specified using the wildcard character (`?`), for example, `List<?>`. This is called a list of unknown type. There are two scenarios where an unbounded wildcard is a useful approach:
>
> - If you are writing a method that can be implemented using functionality provided in the Object class.
> - When the code is using methods in the generic class that don't depend on the type parameter. For example, `List.size` or `List.clear`. In fact, `Class<?>` is so often used because most of the methods in `Class<T>` do not depend on `T`.

? 表示一种特定的未知类型，所以 List<?> 不能 add 因为会类型绑定错误，会出现错误 capture xx of ?之类的。

- `List`: There is no type restriction and assignment restriction at all.
- `List<Object>`: It seems to be used the same as `List`, but a compilation error will occur when accepting other generic assignments. 不能`List<Object> list = a, where a is List<Integer>`
- `List<?>`: It is a generic type. Before assignment, it means that it can accept any type of set assignment, but after assignment, you can't `add` elements to it, but you can `remove` and `clear`, not an `immutable set`. `List<?>` is generally used as a parameter to receive an external collection, or return a collection of specific element types, also known as a `wildcard collection`.

```java
The type List<A>is assignable to List.
The type List<Object>is assignable to List<?>.
```



注意，**优先使用带?的泛型**，这样做的好处是告诉编译器，我们是确实是采用任意类型的泛型，而非忘记使用泛型约束，并且**在编译器检查时不会产生警告信息。**

## 类型擦除

Java 的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息。到了运行时，是看不到泛型的。

因此可能会带来一些问题，比如如下代码运行到最后一行时会产生异常 ClassCastException

```java
        ArrayList<Integer> intList = new ArrayList<Integer>();
        intList.add(2);
        Object obj = intList;

        //just warnning: Type safety: Unchecked cast from Object to ArrayList<String>
        ArrayList<String> strList = (ArrayList<String>) obj;

        // 这里会ClassCastException，因为类型擦除
        //Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
        String str = strList.get(0);
```

## 泛型的约束和限制

### **类型检查不可使用泛型**

```java
if(aaa instanceof Pair<String>){}//error

Pair<String> p = (Pair<String>) a;//warn

Pair<String> p;
Pair<Integer> i;
i.getClass()==p.getClass();//true

public static <E> void rtti(List<E> list) {
    if (list instanceof ArrayList<Integer>) {  // compile-time error
        // ...
    }
}
```

可以这样使用

```java
public static void rtti(List<?> list) {
    if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type
        // ...
    }
}
```

### **不能创建泛型对象数组**

```java
GenericMethod<User>[] o=null;//ok
o=new GenericMethod<User>[10];//error
```

可以定义泛型类对象的数组变量，不能创建及初始化。

注，可以创建通配类型数组，然后进行强制类型转换。不过这是类型不安全的。

```java
o=(GenericMethod<User>[]) new GenericMethod<?>[10];
```

不可以创建的原因是：因为类型擦除的原因无法在为元素赋值时类型检查，因此 jdk 强制不允许。

### **不能实例化泛型对象**

```java
T t= new T();//error
T.class.newInstance();//error
T.class;//error
```

但可以这样创建

```java

public static <E> void append(List<E> list, Class<E> cls) throws Exception {
    E elem = cls.newInstance();   // OK
    list.add(elem);
}

List<String> ls = new ArrayList<>();
append(ls, String.class);

```

### **不能在泛型类的静态域中使用泛型类型**

```java
public class Singleton<T>{
    private static T singleton; //error
    public static T getInstance(){} //error
    public static void print(T t){} //error
}
```

但是，静态的泛型方法可以使用泛型类型:

```java
public static <T> T getInstance(){return null;} //ok
public static <T> void print(T t){} //ok
```

这个原因很多资料中都没说的太明白，说一下个人理解，仅供参考：

1. 泛型类中，`<T>`称为类型变量,实际上就相当于在类中隐形的定义了一个不可见的成员变量：`private T t;`，这是对象级别的，对于泛型类型变量来说是在对象初始化时才知道其具体类型的。而在静态域中，不需要对象初始化就可以调用，这是矛盾的。
2. 静态的泛型方法，是在方法层面定义的，就是说在调用方法时，T 所指的具体类型已经明确了。

### 继承泛型类时自动重写

对于泛型代码，Java 编译器实际上还会偷偷帮我们实现一个 Bridge method。

在继承一个泛型类时，会自动加对泛型类的方法的调用时的类型强制转换。

```java
public class Node<T> {
    public T data;
    public Node(T data) { this.data = data; }
    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

类型擦除后：

```java
public class Node {
    public Object data;
    public Node(Object data) { this.data = data; }
    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
class MyNode extends Node {
    // Bridge method generated by the compiler
    public void setData(Object data) {、
        // 这个是关键！！！！，有个强制类型转化。
        setData((Integer) data);
    }
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
    // ...
}
```
