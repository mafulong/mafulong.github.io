---
layout: post
category: Java
title: jvm自动内存管理
tags: Java
---

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分若干个不同的数据区域。这个区域都各自的用途，以及创建的销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域。

![](https://github.com/changwensir/study_document/raw/master/upload_img/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

　其中程序计数器、虚拟机栈、本地方法栈3个区域会随线程线程而生，随线程而灭，所以这一块上的代码是线程安全的；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。因此这几个 区域的内存分配和回收都具备确定性，在这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程时，内存自然就跟随着回收了。


## 虚拟机栈（Virtual Machine Stacks）
与程序计数器一样，也是线程私有的，其生命周期和线程一样，每个Java线程有一个虚拟机栈。平常我们讲的“栈内存”就是虚拟机栈，或者说是虚拟机栈中局部变量表部分。

作用: 虚拟机栈描述的是Java方法执行的内存模型，即：每个方法在执行的时候都会创建一个栈帧（Stack Frame），栈帧中存储：

　1).局部变量表
　　存放了编译期就可知的：各种基本数据类型（8个基本数据类型）、对象引用(reference类型)、returnAddress类型（指向一条字节码指令地址）
　　其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存大小在编译期就完成了分配，也就是说当进入一个方法时，此方法需要在栈帧中分配多大的局部变量表空间时完全确定的，运行期不会改变

　2).操作数栈

　3).动态链接

　4).方法出口等

　　方法从调用到执行完成的过程，就对应了，一个栈帧在虚拟机栈中的入栈和出栈的过程
有两种异常：

　　1).如果线程请求的栈深度大于JVM所允许的深度，将抛出StackOverflowError异常

　　2).如果栈扩展时无法申请到足够的内存，将抛出OutOfMemoryError(OOM)异常

## Java堆（Java Heap）

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只在逻辑上是连续的即可。对于大多数应用来说，Java堆是虚拟机管理的内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建，通过参数“-Xmx和-Xms”控制。

此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（当然也有例外）:对象实例以及对应的实例变量、数组。
Java堆是垃圾回收器管理的主要区域，因此很多时候也被称做“GC堆”。

由于现代GC基本都采用分带收集算法，所以Java堆还可以细分为：

    　　①.新生代
    　　②.老年代

再细分一下还可分为：

    　　①.Eden空间
    　　②.From Survivor空间
    　　③.To Survivor空间

![](https://github.com/changwensir/study_document/raw/master/upload_img/JVM/%E6%96%B0%E8%80%81%E5%B9%B4%E4%BB%A3.png)

从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，

默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )

JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

### GC回收动作

Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。

### Minor GC
Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。

当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。

当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。

但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。

### Full GC
Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。

现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。

另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

