---
layout: post
category: Algorithms
title: 数学
tags: Algorithms
---

## 排列组合

> [参考](https://baike.baidu.com/item/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/706498)

计算公式：

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210801123910.svg)

计算公式：

![image-20211002195906842](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20211002195912.png)



## 等差等比数列

> [参考](https://wenku.baidu.com/view/0c5e350102020740be1e9b79.html)

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210801124050.png" alt="image-20210801124031771" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210801124109.png" alt="image-20210801124109093" style="zoom:50%;" />



## 复杂的复杂度计算

### 幂函数和对数函数和指数函数对比



![image-20220223194514512](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220223194514.png)

### 调和级数

![image-20220223193553568](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220223193558.png)

### 二项式定理

![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20211002200037.png)

在状态压缩中，枚举子集时可能就会用到。

![image-20220223195451869](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220223195451.png)

## 素数

### 判断是否素数和求1-n的素数求某数的素数

```python
# 判断某数是否是素数
def is_prime(a):
    if a <= 1: return False
    import math
    for i in range(2, int(math.sqrt(a) + 1)):
        if a % i == 0: return False
    return True


# 求1-n每个数的素数，以下时间复杂度O(n)  朴素筛法
def get_all_prime(n):
    a = [False] * n
    res = []
    for i in range(2, n):
        if a[i]: continue
        # a[i]是素数
        res.append(i)
        for j in range(2 * i, n, i):
            a[j] = True
    return res

# 求某数的质因数列表，比如8，是[(2,3)], 6是[(2,1),(3,1)]
def calcu(a):
    counter = collections.Counter()
    prime = get_all_prime(a + 1)
    for p in prime:
        while a % p == 0:
            counter[p] += 1
            a /= p
    return counter.items()
```

## 因数

### 求质因数和对应计数

o(n)近似

```python
# 求质因数列表
# Python Version
def breakdown(N):
    result = []
    from math import sqrt
    for i in range(2, int(sqrt(N)) + 1):
        if N % i == 0:  # 如果 i 能够整除 N，说明 i 为 N 的一个质因子。
            while N % i == 0:
                N = N // i
                result.append(i)
    if N != 1:  # 说明再经过操作之后 N 留下了一个素数
        result.append(N)
    return result
```

### 统计1-n每个数的因子列表

o(nlogn)

```python
MX = 100001
divisors = [[] for _ in range(MX)] # 每个value就是key的因子列表，乘积肯定>value，因为因子之间可能有倍数
for i in range(1, MX):  # 预处理每个数的所有因子，时间复杂度 O(MlogM)，M=1e5
    for j in range(i, MX, i):
        divisors[j].append(i)
```

### 求一个数的因子列表

o(sqrt(n))

```python
divisors = []  
d = 1
while d * d <= k:  # 预处理 k 的所有因子
	if k % d == 0:
		divisors.append(d)
		if d * d < k: # 避免 d= k/d的情况，此时如果append会重复
				divisors.append(k / d)
				d += 1
```

### gcd求最大公约数：

```c++
int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a%b);
}

int gcd(int a, int b) {
	while (b != 0) {
		int t = a%b;
		a = b;
		b = t;
	}
	return a;
}
```

最小公倍数就是a*b/gcd(a,b)

## 进制转换

```c++
	int a, b;
	vector<int> v;
	cin >> a >> b;
	while (a != 0) {
		v.push_back(a%b);
		a = a / b;
	}
```

### 小数的进制转换

[可以参考](https://blog.csdn.net/u013349653/article/details/51367453)
