---
layout: post
category: Algorithms
title: 算法刷题套路总结
tags: Algorithms
---

算法 = 思路 + 实现

## 思考原则

### 局部原则

局部原则，从一个点，从一个索引位置去考虑。

> [参考](https://zhuanlan.zhihu.com/p/99432936)

## 根据时间复杂度找思路

> [leetcode刷题参考，更全面，有例子](https://posts.careerengine.us/p/5ecfb6a139e6b6417d58011b)

根据时间复杂度做题的具体流程：
1. 根据数据范围选择时间复杂度
2. 根据时间复杂度选择对应的常见算法集合
3. 思考题目特征，从集合中选出合适的算法
4. 根据选出的算法求解题目

### 根据数据范围找时间复杂度

通常来说，在力扣上，Python 可以支持到 10^7 的时间复杂度；C++ 会稍微多一点，大概 10^7 - 10^8 之间。因此我们可以得到如下表所示的，数据范围与算法大致时间复杂度的对应表。

![image-20210216110346629](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/20210216110346.png)



### 根据时间复杂度找算法

![image-20210216110406039](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/20210216110406.png)



> [常见时间复杂度参考](https://www.acwing.com/blog/content/32/)

- n≤30n≤30, 指数级别, dfs+剪枝，状态压缩dp

- n≤100n≤100 => O(n3)O(n3)，floyd，dp，高斯消元

- n≤1000n≤1000 => O(n2)O(n2)，O(n2logn)O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford

- n≤10000n≤10000 => O(n∗n‾√)O(n∗n)，块状链表、分块、莫队

- n≤100000n≤100000 => O(nlogn)O(nlogn) => 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、

  prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分

- n≤1000000n≤1000000 => O(n)O(n), 以及常数较小的 O(nlogn)O(nlogn) 算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa

- n≤10000000n≤10000000 => O(n)O(n)，双指针扫描、kmp、AC自动机、线性筛素数

- n≤109n≤109 => O(n‾√)O(n)，判断质数

- n≤1018n≤1018 => O(logn)O(logn)，最大公约数，快速幂

- n≤101000n≤101000 => O((logn)2)O((logn)2)，高精度加减乘除

- n≤10100000n≤10100000 => O(logk×loglogk)，k表示位数O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT



## 根据题目特征找思路

### 求符合要求的全部结果

- 求全部全排列
  - 回溯法 o(n!)
- 求全部子序列
  - 回溯法 o(n!)
  - 子集生成法 2^20以内，也就是n<=20
- 求全部子数组
  - 双指针

### 求最优目标值

> 最优目标值： max, min， equal等

- 求某个子序列的最优目标值
  - 回溯法 o(n!)
  - 子集生成法 2^20以内，也就是n<=20
  - 动态规划
- 求某个子数组的最优目标值
  - 前缀和，比如带负数的数组求是否有子数组=S
  - 动态规划
- 求全部i,j的最优目标值
  - 

## 各种算法特征

> [参考](https://dcbupt.github.io/2017/03/11/FarBox/Forwarddc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/)



### 贪心

当我们求解一个问题时，如果能最大化利用我们当前获得的信息，得到当前情况下的最优解，那么当我们迭代完所有的已知条件后，最后的结果就是我们想要的。

