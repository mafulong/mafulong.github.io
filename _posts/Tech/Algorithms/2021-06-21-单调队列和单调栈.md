---
layout: post
category: Algorithms
title: 单调队列和单调栈
tags: Algorithms
---

## 单调栈和单调队列

单调栈用于求下一个比它大或者比它小的。o(n)。 或者是左边最小的。

单调队列在此基础上可以筛选头部不要的元素。

当访问到第 i 个元素时，单调栈维护的区间为 [0, i) ，而单调队列维护的区间为 (last_pop, i)。因此单调队列可以做一些比如j-i<N的限制维护单调队列。



单调栈总结：**如果压栈之后仍然可以保持单调性，那么直接压。否则先弹出栈的元素，直到压入之后可以保持单调性。** 这个算法的原理用一句话总结就是，**被弹出的元素都是大于当前元素的，并且由于栈是单调增的，因此在其之后小于其本身的最近的就是当前元素了**



场景：

- 求左边/右边 第一个比a[i]大/小的值。 
- 求左边/右边 持续的a[i]<a[j]或者a[i]>a[j]的值。
- 利用单调栈做一些合并，比如[901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/) 求出小于或等于今天价格的最大连续日数等价于求出最近的一个大于今日价格的日子。使用单调栈，元素weight进行合并。再比如题目: [1130. 叶值的最小代价生成树](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/) ， [1504. 统计全 1 子矩形](https://leetcode-cn.com/problems/count-submatrices-with-all-ones/)
- [求不重复的字典序字符串](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/)
- [求A[i]<A[j]的最大j-i, 最大宽度坡](https://chengzhaoxi.xyz/cc968d26.html)

## 单调栈可利用的点

维护一个栈， 最终目的是把当前元素append进去，因此可能对pop一些元素，可利用的就是pop的这些元素，和最后插入元素这两个时机。

如果是递减栈，则插入过程中被Pop掉的都是小于当前i的值， 因此对于pop元素，求的是的右边第一个大，对i也知道左边第一个小。



- 因此求右边第一个大的，可以递减栈，从左往右遍历，弹出时操作。 也可以顺便求左边第一个大的，在push时操作。

- 求右边第一个小的，可以递增栈，从左往右遍历，弹出时操作。

- 求左边第一个大的，可以递减栈，从右往左遍历，弹出时操作。

- 求左边第一个小的，可以递增栈，从右往左遍历，弹出时操作。

  

模板：

求左右两边第一个小的：[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        if not heights:
            return 0
        n = len(heights)
        l = [-1 for _ in range(n)]
        r = [n for _ in range(n)]
        stack = []
        for i, h in enumerate(heights):
            while stack and heights[stack[-1]] >= h:
                r[stack[-1]] = i
                stack.pop()
            l[i] = stack[-1] if stack else -1
            stack.append(i)
        ans = max(h * (r[i] - l[i] - 1) for i, h in enumerate(heights))
        return ans

```

注意以上求法是非严格小的。 

严格小的：对于stack[-1]，它左右两边就是严格小的。，[参考：](https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/python3-tong-84ti-zui-da-zhi-fang-tu-by-5ersw/)



相关题目：

- [力扣加加](https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/monotone-stack)
- [1944. 队列中可以看到的人数](https://leetcode-cn.com/problems/number-of-visible-people-in-a-queue/) 统计右边连续A[i]<A[j]的数量。
- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 计算左右两边第一个小的位置i,j, 然后用i,j就可以求出矩形面积了，可以一次遍历求出。
- [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) 遍历到i, 求右边第一个比A[i]大的位置，就可以求出雨水大小了。
- [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)  求在每一天需要等几天才会有更高的温度。实际就是求下一个更大值的位置。
- [1081. 不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/)  用递增栈维护子序列，遍历到i时， 当在栈里直接continue, 当栈顶的字符后面不会再出现时，不能pop。
- [求A[i]<A[j]的最大j-i, 最大宽度坡](https://chengzhaoxi.xyz/cc968d26.html) 维护有序数组或者按照大小对1,2,3,4...排序。
- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 左右两边最小值索引。
- [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)  变成柱状图中最大矩形即可。
- [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/) 求移除这个数中的 `k` 位数字，使得剩下的数字最小
- [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/) 求出小于或等于今天价格的最大连续日数等价于求出最近的一个大于今日价格的日子。使用单调栈，元素weight进行合并。
- [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/) 求以arr[i]作为最小值的subarray数量= left_count*right_count. 注意这里取左开右闭。实际就是先求以arr[i]左右两边最小值的位置。
- [1504. 统计全 1 子矩形](https://leetcode-cn.com/problems/count-submatrices-with-all-ones/) 单调栈合并。先求直方图，再从上往下遍历，求(i,j)为右下角顶点的个数，单调栈记录了(left(i,j), height), height是合并后的count. 
- [1130. 叶值的最小代价生成树](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/) 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。求返回每个非叶节点的值的最小可能总和。类似hufflman树，小的在下面，单调栈，如[6,2,4]，插入4时，合并2和4, 变成[6,4],ans+= 2*4



求左边右边, 最小的大于等于arr[i]的位置，一种方式是sortedList, 一种方式是sorted(range(N), lambda x:arr[x])



## 单调队列



- [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/) 当i<j and nums[i]<nums[j]  当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中，这是 ii 在 jj 的左侧所保证的。因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将 nums[i] 永久地移除。所以可以用个递减单调队列。

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        import collections
        q = collections.deque()
        for i in range(k-1):
            while q and q[-1][0] <= nums[i]:
                q.pop()
            q.append((nums[i], i))
        for i in range(k-1, len(nums)):
            v = nums[i]
            while q and q[-1][0] <= v:
                q.pop()
            q.append((v, i))
            while q and q[0][1] <= i - k:
                q.popleft()
            ans.append(q[0][0])
        return ans
```

