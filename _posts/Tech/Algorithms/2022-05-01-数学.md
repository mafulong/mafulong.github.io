---
layout: post
category: Algorithms
title: 数学
tags: Algorithms
recent_update: true
---

## 排列组合

> [参考](https://baike.baidu.com/item/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/706498)

计算公式：

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210801123910.svg)

计算公式：

![image-20211002195906842](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20211002195912.png)

![image-20220904145610986](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202209041456830.png)

另外 C(0,0) = 1， 0 的为 1。

组合数性质

![image-20220904145924154](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202209041459183.png)

### 大组合数求解边模

利用组合数性质. o(n2)

```python
    def comb_mod(self, n, m, mod=10 ** 9 + 7):
        '''
        大组合数计算C(n,m)，边求边mod, 利用组合数性质C(n,m) = 1*C(n-1,m-1) + C(n-1,m)
        '''
        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
        dp[0][0] = 1
        for i in range(1, n+1):
            dp[i][0] = 1
            for j in range(1, i+1):
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % mod
        return dp[n][m]

```

组合数求和公式

![image-20220904150115865](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202209041501896.png)



### python中排列组合

```python
    # 组合
    math.comb  # n! / (k! * (n - k)!)
    math.perm  # n! / (n - k)!

```







## 等差等比数列

> [参考](https://wenku.baidu.com/view/0c5e350102020740be1e9b79.html)

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210801124050.png" alt="image-20210801124031771" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210801124109.png" alt="image-20210801124109093" style="zoom:50%;" />

## 复杂的复杂度计算

### 幂函数和对数函数和指数函数对比

![image-20220223194514512](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220223194514.png)

### 调和级数

![image-20220223193553568](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220223193558.png)

### 二项式定理

![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20211002200037.png)

在状态压缩中，枚举子集时可能就会用到。

![image-20220223195451869](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220223195451.png)

## 中位数

在一步操作中，你可以使数组中的一个元素加 `1` 或者减 `1` ，所有数都靠近**中位数**可使所有数组元素相等时移动数最少。 相关题目： [最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/) 

即中位数到所有数距离和最小，如果是偶数，可以在中位数两侧的数据构成的区间内任意取值，对结果无影响证明：

![image-20221023121438346](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202210231214395.png)

另一个相似题目：有cost，需转化拆分，然后再算中位数，[6216. 使数组相等的最小开销](https://mafulong.github.io/2022/10/23/6216.-%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E5%BC%80%E9%94%80/)

## 素数

### 判断是否素数 o(sqrt(N))

```python
# 判断某数是否是素数 o(sqrt(n))
def is_prime(a):
    if a <= 1: return False
    import math
    for i in range(2, int(math.sqrt(a) + 1)):
        if a % i == 0: return False
    return True


```

### 求 1-n 的所有素数 筛法 o(N)

#### 埃氏筛法

```python
# 求1-n每个数的素数，以下时间复杂度O(nloglogn) 接近o(n)
# 如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。
#  Eratosthenes 筛法（埃拉托斯特尼筛法，简称埃氏筛法）
def get_all_prime(n):
    a = [False] * n
    res = []
    for i in range(2, n):
        if a[i]: continue
        # a[i]是素数
        res.append(i)
        for j in range(2 * i, n, i):
            a[j] = True
    return res
```

#### **线性筛法** 也称为 **Euler 筛法**（欧拉筛法）

埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。

如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 o(n)了。

```python
def get_all_prime(n):
    a = [False] * n
    res = []
    for i in range(2, n):
        if a[i]: continue
        # a[i]是素数
        res.append(i)
        for j in range(2 * i, n, i):
						if a[j]: break # 多了个这行
            a[j] = True
    return res
```

## 平方数

[先看 Cyc2018](http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.html#_1-%E5%B9%B3%E6%96%B9%E6%95%B0)

### 生成所有平方数

平方序列：1,4,9,16,..

间隔：3,5,7,...

间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。

### 3 的 n 次方

[Power of Three (Easy)](https://leetcode-cn.com/problems/power-of-three/description/)

```java
public boolean isPowerOfThree(int n) {
    return n > 0 && (1162261467 % n == 0);
}
```

## 除法

```python
    # b % a == 0
    # 表示b能被a整除，a可以整除b, 被除数永远都是有这个『被』
```

表示b能被a整除，a可以整除b, 被除数永远都是有这个『被』



大整数除法，除法中取模。



## 因数理论

### 素数分解

每一个数都可以分解成素数的乘积，例如 84 = 22 _ 31 _ 50 _ 71 _ 110 _ 130 _ 170 \* …

### 整除

令 x = 2m0 _ 3m1 _ 5m2 _ 7m3 _ 11m4 \* …

令 y = 2n0 _ 3n1 _ 5n2 _ 7n3 _ 11n4 \* …

如果 x 整除 y（y mod x == 0），则对于所有 i，mi <= ni。

### 最大公约数最小公倍数的素数表示

每个质因数的乘积

x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) _ 3min(m1,n1) _ 5min(m2,n2) \* ...

x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) _ 3max(m1,n1) _ 5max(m2,n2) \* ...

### 约数个数和约数之和

如果 N = p1^c1 _ p2^c2 _ ... _pk^ck
约数个数： (c1 + 1) _ (c2 + 1) _ ... _ (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) _ ... _ (pk^0 + pk^1 + ... + pk^ck)



## 因数相关问题

### 试除法求所有约数:

#### 求一个数的因子列表 o(sqrt(n))

o(sqrt(n))

```python
divisors = []
d = 1
while d * d <= k:  # 预处理 k 的所有因子
	if k % d == 0:
		divisors.append(d)
		if d * d < k: # 避免 d= k/d的情况，此时如果append会重复
				divisors.append(k / d)
				d += 1
```

#### 统计 1-n 每个数的因子列表 o(nlogn)

o(nlogn)

```python
MX = 100001
divisors = [[] for _ in range(MX)] # 每个value就是key的因子列表，乘积肯定>value，因为因子之间可能有倍数
for i in range(1, MX):  # 预处理每个数的所有因子，时间复杂度 O(MlogM)，M=1e5
    for j in range(i, MX, i):
        divisors[j].append(i)
```

### 分解质因数

#### 求某数质因数列表 o(sqrt(N))

o(sqrt(N))

求某数的质因数列表，比如 8，是[2,2,2]

枚举[2, sqrt(n)+1), 如果是质因数，就接着除，最大大于 1，它本身就是质数。

也叫 求欧拉函数

```python
# 求质因数列表
def breakdown(N):
    result = []
    from math import sqrt
    for i in range(2, int(sqrt(N)) + 1):
        if N % i == 0:  # 如果 i 能够整除 N，说明 i 为 N 的一个质因子。
            while N % i == 0:
                N = N // i
                result.append(i)
    if N != 1:  # 说明再经过操作之后 N 留下了一个素数
        result.append(N)
    return result
```

#### 统计 1-n 每个数的质因数列表

筛法求欧拉函数

类似，暂时不写。

### gcd 求最大公约数和最小公倍数 欧几里得算法

欧几里得算法

```python
class Math1:
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a % b)
```

最小公倍数就是 a\*b/gcd(a,b)



### 多个数求最大公约数和最小公倍数

多个数的最大公约数:

```python
def gcd_list(self, nums):
    import math
    cur = nums[0]
    for i in range(1, len(nums)):
        cur = math.gcd(cur, nums[i])
    return cur
```

多个数的最小公倍数:

> 注意这里不是直接多个数乘积除以他们的gcd呀，而且不断一个一个加计算的。

```python
def lcm_list(self, nums):
    import math
    prod = 1
    for v in nums:
        prod = prod * v / math.gcd(prod, v)
    return prod
```

### 1到n里有多少个数可整除a?

```python
n//a
```



### 1到n里有多少个a的因数?

[参考另一个博客](https://mafulong.github.io/2018/04/30/%E8%AE%A1%E7%AE%97n%E7%9A%84%E9%98%B6%E4%B9%98%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AAk/)

```python
    def calcu(x,a):
        '''
        1-x中有多少个因数a， 比如1-26里有5，10, 15, 20, 各自1个5， 5*5两个5，一共6个
        '''
        r = 0
        while x:
            # 贡献5的数量，贡献5*5的数量，贡献5*5*5的数量
            r += x //a
            x //= a
        return r
    print(calcu(26, 5))
```



## 大整数取模问题

### 大数相乘取模

```python
    def prod(d=[], mod=10 ** 9 + 7):
        r = d[0] % mod
        for v in d[1:]:
            r *= v
            r %= mod
        return r
```



### 大数相除取模 费马小定理

如果a/b,然后a和b都是大数要取模，这时不能相乘取模来计算

`(a/b)%c=(a%c)/(b%c)`是**不成立**的



> [除法取模](https://leetcode.cn/problems/count-anagrams/solution/by-simpleson-crwb/)

```python

# 原: i//j%MOD 
# 现: i*modInverse(j)%MOD
MOD = int(1e9 + 7)

class BigIntDivide:
    def mod_inverse(sefl, i):
        # 调用取模的乘幂运算, pow复杂度是log(exp)即log(MOD)
        return pow(i, MOD - 2, MOD)

    def divide_mod(self, a, b):
        '''
        计算(a/b) % MOD, 除法变乘法，前提是b和MOD互为质数
        '''
        # 如果有多个b,比如a/b1/b2, 那就可以递归。a*mod_inverse(b1) % mod * mod_inverse(b2) % mod这样
        return a * self.mod_inverse(b) % MOD

    def divide_mods(self, a, b=[]):
        '''
        计算a /(b1*b2*b3) % MOD等形式，前提是b和MOD互为质数
        '''
        r = a % MOD
        for i, v in enumerate(b):
            r *= self.mod_inverse(v)
            r %= MOD
        return r


```



### 大数幂取模

```python
r = pow(base=2, exp=3, mod=3)
print(r)
```



## 阶乘

```python
import math
math.factorial(3)
```



## 分配问题

### a能否分成满足条件的两份，其中只能分给指定一份



## 进制转换

```c++
	int a, b;
	vector<int> v;
	cin >> a >> b;
	while (a != 0) {
		v.push_back(a%b);
		a = a / b;
	}
```

### 小数的进制转换

[可以参考](https://blog.csdn.net/u013349653/article/details/51367453)

十进制小数转二进制数：“乘以 2 取整，顺序排列”（乘 2 取整法）

例： (0．625)10= (0．101)2

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220603233141.png" alt="image-20220603233141181" style="zoom:25%;" />

## 容斥原理

[参考](https://leetcode-cn.com/problems/rectangle-area-ii/solution/ju-xing-mian-ji-ii-by-leetcode/)

![image-20220228201935551](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220228201935.png)

定理：

![image-20220228202026269](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220228202026.png)

## 幂

### 快速幂 O(logk)

求 m^k mod p，时间复杂度 O(logk)。

```c++
int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

### 求根号

[题目](https://leetcode-cn.com/problems/sqrtx/)

牛顿迭代法

### 求根号变种 小数精度

`while l<=r`不用变，只需要变步长即可。eps 可以比期望精度再小一个量级。

```python

def f(x, eps):
    l, r = 0, max(x, 1)
    while l <= r:
        mid = (l + r) / 2
        if int(mid) * int(mid) == x:
            return int(mid)
        if mid * mid > x:
            r = mid - eps
        else:
            l = mid + eps
    return r


if __name__ == '__main__':
    eps = 1e-3
    # print(f(4, eps))
    # print(f(8, eps))
    # print(f(9, eps))
    print(f(0.04, 1e-10))
```

## Acwing 数学

[参考](https://www.acwing.com/file_system/file/content/whole/index/content/3273/) 本文只涉及部分
