---
layout: post
category: Algorithms
title: BFS
tags: Algorithms
---

## 常规BFS

- 每次把周围未访问的点加进队列
- 在append时检查visit标记和设置visit标记
- 只能解决长度为1的问题

```
const visited = {}
function bfs() {
	let q = new Queue()
	q.push(初始状态)
	while(q.length) {
		let i = q.pop()
		if (visited[i]) continue
		for (i的可抵达状态j) {
			if (j 合法) {
				q.push(j)
			}
		}
	}
	// 找到所有合法解
}
```

题目：

- [求最少转弯的路径](https://mafulong.github.io/2018/08/27/bfs%E6%9C%80%E5%B0%8F%E8%BD%AC%E5%BC%AF%E8%B7%AF%E5%BE%84/) 每次转弯时加1，

## 双向BFS

> [双向bfs模板参考](https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/)

常规bds可能会搜索空间爆炸， 假如**同时从两个方向开始搜索，一旦搜索到相同的值，意味着找到了一条联通起点和终点的最短路径。**



双向 BFS」的基本实现思路如下：

1. 创建「两个队列」分别用于两个方向的搜索；
2. 创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；
3. 为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；
4. 如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。

```java
d1、d2 为两个方向的队列
m1、m2 为两个方向的哈希表，记录每个节点距离起点的
    
// 只有两个队列都不空，才有必要继续往下搜索
// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
while(!d1.isEmpty() && !d2.isEmpty()) {
    if (d1.size() < d2.size()) {
        update(d1, m1, m2);
    } else {
        update(d2, m2, m1);
    }
}

// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）
void update(Deque d, Map cur, Map other) {}
```

题目：

- [433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)
- [126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)

## 优先队列BFS

[dijkstra](https://mafulong.github.io/2018/02/19/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/)

题目：

- [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)



## 0-1 广度优先搜索

参考：[https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/solution/shi-wang-ge-tu-zhi-shao-you-yi-tiao-you-xiao-lu-2/](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/solution/shi-wang-ge-tu-zhi-shao-you-yi-tiao-you-xiao-lu-2/)

为了可以处理权值为0的边，使用双端队列，当遇到是0的边，就加入到队首。



保证广度优先搜索正确性的基础在于：对于源点 s*s* 以及任意两个节点 u*u* 和 v*v*，如果 \textit{dist}(s, u) < \textit{dist}(s, v)*dist*(*s*,*u*)<*dist*(*s*,*v*)（其中 \textit{dist}(x, y)*dist*(*x*,*y*) 表示从节点 x*x* 到节点 y*y* 的最短路长度），那么节点 u*u* 一定会比节点 v*v* 先被取出队列。在常规的广度优先搜索中，我们使用队列作为维护节点的数据结构，就保证了从队列中取出的节点，它们与源点之间的距离是单调递增的。

然而如果边权可能为 00，就会出现如下的情况：

- 源点 s*s* 被取出队列；
- 源点 s*s* 到节点 v_1*v*1 有一条权值为 11 的边，将节点 v_1*v*1 加入队列；
- 源点 s*s* 到节点 v_2*v*2 有一条权值为 00 的边，将节点 v_2*v*2 加入队列；

此时节点 v_2*v*2 一定会在节点 v_1*v*1 之后被取出队列，但节点 v_2*v*2 与源点之间的距离反而较小，这样就破坏了广度优先搜索正确性的基础。

那么我们如何修改广度优先搜索的算法框架呢？我们可以使用双端队列（double-ended queue, deque）代替普通的队列作为维护节点的数据结构。当任一节点 u*u* 被取出队列时，如果它到某节点 v_i*v**i* 有一条权值为 00 的边，那么就将节点 v_i*v**i* 加入双端队列的「队首」。如果它到某节点 v_j*v**j* 有一条权值为 11 的边，那么和常规的广度优先搜索相同，我们将节点 v_j*v**j* 加入双端队列的「队尾」。这样以来，我们保证了任意时刻从队首到队尾的所有节点，它们与源点之间的距离是单调递增的，即从队列中取出的节点与源点之间的距离同样是单调递增的。

0-1 广度优先搜索的实现其实与 Dijkstra 算法非常相似。在 Dijkstra 算法中，我们用优先队列保证了距离的单调递增性。而在 0-1 广度优先搜索中，实际上任意时刻队列中的节点与源点的距离均为 d*d* 或 d + 1*d*+1（其中 d*d* 为某一非负整数），并且所有与源点距离为 d*d* 的节点都出现在队首附近，所有与源点距离为 d + 1*d*+1 的节点都出现在队尾附近。因此，我们只要使用双端队列，对于边权为 00 和 11 的两种情况分别将对应节点添加至队首和队尾，就保证了距离的单调递增性。



实现：

- 为了可以处理权值为0的边，使用双端队列，当遇到是0的边，就加入到队首。
- 每次pop时检查是否visit，如果是visit就continue跳过，否则接着处理，并设置visit为true，这个和dijstra类似，和常规bfs(append时检查visit和设置visit)有区别
- 只能解决0/1的长度问题。



题目列表：

- [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)
