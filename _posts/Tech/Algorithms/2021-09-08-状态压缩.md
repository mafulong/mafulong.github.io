---
layout: post
category: Algorithms
title: 状态压缩
tags: Algorithms
---

## 状态压缩

## 前言

其实，状压 DP 就是枚举所有情况的 「 暴力 」。

题的数据范围会隐约地告诉我们，需要暴力地将所有情况算出来，取最优解。

**Tips：以普遍理性而论，状压的数据范围都会小于 `20`。**



### 状态压缩

状态压缩，其实就是将每个任务 `task[i]` 看作某个 「 十进制数字 」 的**二进制上的第 `i` 位**，`1` 表示该任务被选择，反之不被选择。

**Tips：** 十进制数字是多少我们根本不用关心，我们关心的是它的二进制长啥样。

状态压缩可以简单的理解为把一个布尔 `boolean` 数组压缩到了一个十进制数字上，之后便可以使用位运算的各种技巧来简化代码逻辑，这可比布尔数组好用多了！(๑•̀ㅂ•́)و✧



## 技巧

### **枚举二进制子集**

```
// m => 总状态数
for (int i = 1; i < m; i++) {
    // 枚举状态 i 的二进制子集
    for (int j = i; j > 0; j = (j - 1) & i) {
        // To Do..
    }
}
```

当然，不知道这个技巧也没关系，我们依然可以暴力地枚举 `i` 及之前的每个状态，如果这个状态是 `i` 的子集，则可以参与状态转移。

检查 `x` 是否为 `y` 的二进制子集：

`(x | y) == y`，即 `x` 对应二进制位上的 `1` 在 `y` 中的对应位置也是 `1`。

**暴力枚举二进制子集**

```
// m => 总状态数
for (int i = 1; i < m; i++) {
    // 从 [1, i] 就可以了，后面的一定不会是 i 的子集
    for (int j = 1; j <= i; j++) {
        // 检查状态 j 是不是状态 i 的二进制子集
        if ((i | j) == i) {
            // To Do..
        }
    }
}
```

从所有mask里挑两个。

```
        for(int i = 1; i < 1 << n; ++i) {
            int rev = (i ^ ((1 << n) - 1));
            for(int j = rev; j; j = (j - 1) & rev) {
                if(isp[j]) ans = max(ans, len[i] * len[j]);
            }
        }
```



### 时间复杂度计算

所有mask复杂度： o(2^n)， 如果每个都枚举子集，比如mask有k个1，那子集复杂度o(2^k)

总的复杂度=3^n=(1+2)^n = ..二项式定理。



3^n只能适用于n<14的情况。否则可以选用n*(2^n)的方法，就是dp[mask]不断扩张时是按+1维度扩张的，而不是增加某个子集扩张的。



### 状态压缩选长度短的

比如人分配楼，从楼角度，是楼选人，从人角度，是人选楼，状态压缩选长度短的，这样状态数目少。





## 题目示例

- [1986. 完成任务的最少工作时间段](https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/)  求最小值，划分子集，求每个mask的最小值，不断扩张mask，直到全为1. 

- [1601. 最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/) 求最大值，暴力枚举所有状态。

- [1434. 每个人戴不同帽子的方案数](https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other/) 求方案数，帽子选人，状态记录为人的状态，用dp(i, mask), i是帽子，这样每个人选的帽子也不一样。

- [1799. N 次操作后的最大分数和](https://leetcode-cn.com/problems/maximize-score-after-n-operations/) 求最大值，状态压缩暴力法， 子空间遍历，扩张mask。

- [526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)  求符合条件排列数量，可以用dp(i,mask)表示前i个的mask的数量，但这里可以优化，mask里也有i的信息。

- ```python
          dp = [0] * (1 << n)
          dp[0] = 1
          for mask in range(1, 1 << n):
              j = bin(mask).count('1')
              t = 0
              for i in range(n):
                  if (1 << i) & mask and (j % (i + 1) == 0 or (i + 1) % j == 0):
                      t += dp[mask ^ (1 << i)]
              dp[mask] = t
        
  ```

- [691. 贴纸拼词](https://leetcode-cn.com/problems/stickers-to-spell-word/) 不断扩张mask

  ```python
  class Solution:
      def minStickers(self, stickers: List[str], target: str) -> int:
          import collections
          # target_counter = collections.Counter(target)
          scounter = [collections.Counter(l) for l in stickers]
          n = len(target)
          inf = float('inf')
          dp = [inf] * (1 << n)
          dp[0] = 0
          for mask in range(1 << n):
              if dp[mask] == inf:
                  continue
              for l in scounter:
                  c = l.copy()
                  new_mask = mask
                  for i in range(n):
                      if (1 << i) & mask:
                          continue
                      if c[target[i]] > 0:
                          c[target[i]] -= 1
                          new_mask |= (1 << i)
                  dp[new_mask] = min(dp[new_mask], dp[mask] + 1)
  
          return dp[(1 << n) - 1] if dp[(1 << n) - 1] != inf else -1
  ```

- [1595. 连通两组点的最小成本](https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points/) 在一个矩阵中选取一些值, 满足矩阵的每一行和每一列都至少有一个元素被选中, 同时选中元素的总和最小 (此矩阵就是 `cost` 矩阵).  枚举rest子集。
- [1617. 统计子树中城市之间最大距离](https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/) 枚举mask, 然后求每个mask的最大距离，以及是否是个子树，可以dfs实现。



典型：

- 能分划分成k个子数组，每个子数组和相等，比如=target，可以用dp[mask]表示当前和，不断扩张， 当dp[pre]%target+cur > target时，当前选择是不能用的。 dp[i]默认=-1，最后毕竟dp[1<<n - 1] == sum(v)即可。

  - [473. 火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/)  分成4个边长一样的子数组。

  - ```python
    class Solution:
        def makesquare(self, matchsticks: List[int]) -> bool:
            total = sum(matchsticks)
            if total % 4 != 0:
                return False
            equal = total // 4
            if max(matchsticks) > equal:
                return False
            n = len(matchsticks)
            dp = [-1] * (1 << n)
            dp[0] = 0
            matchsticks = sorted(matchsticks)
            for mask in range(1 << n):
                for i in range(n):
                    bit = 1 << i
                    if bit & mask == 0:
                        continue
                    prev = dp[mask ^ bit]
                    if prev == -1:
                        continue
                    if (prev % equal) + matchsticks[i] > equal:
                        break
                    dp[mask] = prev + matchsticks[i]
                    break
            return dp[(1 << n) - 1] == total
    ```

    

- 可以把部分需要permutation的写法变成状态压缩，其实是动态规划。这样的复杂度是O(2^n * n)

  - [1879. 两个数组最小的异或值之和](https://leetcode-cn.com/problems/minimum-xor-sum-of-two-arrays/)

  - ```python
    class Solution:
        def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
            n = len(nums2)
            inf = float("inf")
            dp = [inf] * (1 << n)
            dp[0] = 0
            for mask in range(1 << n):
                if dp[mask] == inf:
                    continue
                count = bin(mask).count("1")
                for i in range(n):
                    if (1 << i) & mask:
                        continue
                    new_mask = mask | (1 << i)
                    dp[new_mask] = min(dp[new_mask], dp[mask] + (nums1[count] ^ nums2[i]))
            return dp[(1 << n) - 1]
    ```
    
  - [1125. 最小的必要团队](https://leetcode-cn.com/problems/smallest-sufficient-team/) 类似帽子选人。

- 长度大于30的，基本就是要分开操作。

  - [805. 数组的均值分割](https://leetcode-cn.com/problems/split-array-with-same-average/) 分成left和right，然后left和right里拼一个和为0则返回true. 可以子集生成法生成左边和右边的set，然后判断。注意set时间复杂度为o(1)
  
- o(2^n  * n *n)的模式。dp(mask, i)表示mask的状态下最后以i结尾的状态， 不断扩张mask，最后得出结果。可以预处理i和j的关系。dp(mask, i) =handle( dp(mask%(1<<i), j)...)

  - [847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)  返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。
  
  - [943. 最短超级串](https://leetcode-cn.com/problems/find-the-shortest-superstring/) 给定一个字符串数组 `words`，找到以 `words` 中每个字符串作为子字符串的最短字符串
  
  - [996. 正方形数组的数目](https://leetcode-cn.com/problems/number-of-squareful-arrays/)给定一个非负整数数组 `A`，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为*正方形*数组。返回 A 的正方形排列的数目。
  
- N <= 12,是可以回溯的。12!= 4*10**7

