---
layout: post
category: Algorithms
title: 状态压缩
tags: Algorithms
---

## 状态压缩

## 前言

其实，状压 DP 就是枚举所有情况的 「 暴力 」。

题的数据范围会隐约地告诉我们，需要暴力地将所有情况算出来，取最优解。

**Tips：以普遍理性而论，状压的数据范围都会小于 `20`。**



### 状态压缩

状态压缩，其实就是将每个任务 `task[i]` 看作某个 「 十进制数字 」 的**二进制上的第 `i` 位**，`1` 表示该任务被选择，反之不被选择。

**Tips：** 十进制数字是多少我们根本不用关心，我们关心的是它的二进制长啥样。

状态压缩可以简单的理解为把一个布尔 `boolean` 数组压缩到了一个十进制数字上，之后便可以使用位运算的各种技巧来简化代码逻辑，这可比布尔数组好用多了！(๑•̀ㅂ•́)و✧



## 技巧

### **枚举二进制子集**

```
// m => 总状态数
for (int i = 1; i < m; i++) {
    // 枚举状态 i 的二进制子集
    for (int j = i; j > 0; j = (j - 1) & i) {
        // To Do..
    }
}
```

当然，不知道这个技巧也没关系，我们依然可以暴力地枚举 `i` 及之前的每个状态，如果这个状态是 `i` 的子集，则可以参与状态转移。

检查 `x` 是否为 `y` 的二进制子集：

`(x | y) == y`，即 `x` 对应二进制位上的 `1` 在 `y` 中的对应位置也是 `1`。

**暴力枚举二进制子集**

```
// m => 总状态数
for (int i = 1; i < m; i++) {
    // 从 [1, i] 就可以了，后面的一定不会是 i 的子集
    for (int j = 1; j <= i; j++) {
        // 检查状态 j 是不是状态 i 的二进制子集
        if ((i | j) == i) {
            // To Do..
        }
    }
}
```

### 状态压缩选长度短的

比如人分配楼，从楼角度，是楼选人，从人角度，是人选楼，状态压缩选长度短的，这样状态数目少。



## 题目示例

- [1986. 完成任务的最少工作时间段](https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/)  求最小值，划分子集，求每个mask的最小值，不断扩张mark，直到全为1. 

- [1601. 最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/) 求最大值，暴力枚举所有状态。
- [1434. 每个人戴不同帽子的方案数](https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other/) 求方案数，帽子选人，状态记录为人的状态，用dp(i, mask), i是帽子，这样每个人选的帽子也不一样。
