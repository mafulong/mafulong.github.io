---
layout: post
category: CourseNotes
title: 语言的内存管理
tags: CourseNotes
---

## 语言的内存管理

![内存分配](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv4/v4/20210327161709.png)

[参考](https://draveness.me/system-design-memory-management/)

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325194358.png)

实际上两个模块： 即内存分配器（Allocator）、垃圾收集器（Collector）。当然除了这两个模块之外，在研究内存管理时都会引入第三个模块 — 用户程序（Mutator），帮助我们理解整个系统的工作流程。

![mutator-allocator-collector](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325195159.png)



- 用户程序（Mutator）- 可以通过分配器创建对象或者更新对象持有的指针；
- 内存分配器（Allocator）— 处理用户程序的的内存分配请求；
- 垃圾收集器（Collector）- 标记内存中的对象并回收不需要的内存；

## 基本概念

### 内存布局

操作系统会为在其上运行的应用程序分配一片巨大的虚拟内存，是操作系统构建的逻辑概念，并不是在物理上真正存在的概念。

![memory-layout](https://img.draveness.me/2021-02-28-16145096642893-memory-layout.png)

- 栈区（Stack）— 存储程序执行期间的本地变量和函数的参数，从高地址向低地址生长；
- 堆区（Heap）— 动态内存分配区域，通过 `malloc`、`new`、`free` 和 `delete` 等函数管理；
- 未初始化变量区（BSS）— 存储未被初始化的全局变量和静态变量；
- 数据区（Data）— 存储在源代码中有预定义值的全局变量和静态变量；
- 代码区（Text）— 存储只读的程序执行代码，即机器指令；

上述五种不同段虽然存储着不同的数据，但是我们可以将它们分成三种不同的内存分配类型，也就是静态内存、栈内存和堆内存。

#### 静态内存

所有静态内存的布局都是在编译期间确认的，运行期间也不会分配新的静态内存，因为所有的静态内存都是在编译期间确认的，所以会为这些变量申请固定大小的内存空间，这些固定的内存空间也会导致静态内存无法支持函数的递归调用



<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325213131.png" alt="static-allocation-features" style="zoom: 67%;" />

因为编译器可以确定静态变量的地址，所以它们是程序中唯一可以使用绝对地址寻址的变量。当程序被加载到内存中时，静态变量会直接存储在程序的 BSS 区或者数据区，这些变量也会在程序退出时被销毁，正是因为静态内存的这些特性，我们并不需要在程序运行时引入静态内存的管理机制。



#### 栈内存

栈是应用程序中常见的内存空间，它遵循后进先出的规则管理存储的数据[2](https://draveness.me/system-design-memory-management/#fn:2)。当应用程序调用函数时，它会将函数的参数加入栈顶，当函数返回时，它会将当前函数使用的栈全部销毁。栈内存管理的指令也都是由编译器生成的，我们会使用 BP 和 SP 这两个寄存器存储当前栈的相关信息，完全不需要工程师的参与，不过我们也只能在栈上分配大块固定的数据结构。

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325213338.png" alt="stack-allocation-features" style="zoom: 67%;" />

因为栈内存的释放是动态的并且是线性的，所以它可以支持函数的递归调用，不过运行时动态栈分配策略的引入也会导致程序栈内存的溢出，如果我们在编程语言中使用的递归函数超出了程序内存的上限，会造成栈溢出错误。

#### 堆内存

堆内存也是应用程序中的常见内存，与超过函数作用域会自动回收的栈内存相比，它能够让函数的被调用方向调用方返回内存并在内存的分配提供更大的灵活性，不过它提供的灵活性也带来了内存泄漏和悬挂指针等内存安全问题。

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325213546.png" alt="heap-allocation-features" style="zoom:67%;" />

因为堆上的内存是工程师手动申请的，所以需要在使用结束时释放，一旦用过的内存没有释放，就会造成内存泄漏，占用更多的系统内存；如果在使用结束前释放，会导致危险的悬挂指针，其他对象指向的内存已经被系统回收或者重新使用。虽然进程的内存可以划分成很多区域，但是当我们在谈内存管理时，一般指的都是堆内存的管理，也就是如何解决内存泄漏和悬挂指针的问题。

> *指针*指向非法的内存地址，那么这个*指针*就是*悬挂指针*，也叫野指针。

### 对象头

对象头是实现自动内存管理的关键元信息，内存分配器和垃圾收集器都会访问对象头以获取相关的信息。当我们通过 `malloc` 等函数申请内存时，往往都需要将内存按照指针的大小对齐（32 位架构上为 4 字节，64 位架构上为 8 字节），除了用于对齐的内存之外，每一个堆上的对象也都需要对应的对象头：

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210325213922.png" alt="object-header" style="zoom:67%;" />

不同的自动内存管理机制会在对象头中存储不同的信息，使用垃圾回收的编程语言会存储标记位 `MarkBit`/`MarkWord`，例如：Java 和 Go 语言；使用自动引用计数的会在对象头中存储引用计数 `RefCount`，例如：Objective-C。

编程语言会选择将对象头与对象存储在一起，不过因为对象头的存储可能影响数据访问的局部性，所以有些编程语言可能会单独开辟一片内存空间来存储对象头并通过内存地址建立两者之间的隐式联系。

## 内存分配

内存分配器只包含线性内存分配器（Sequential Allocator）和空闲链表内存分配器（Free-list Allocator）两种，内存管理机制中的所有内存分配器其实都是上述两种不同分配器的变种，它们的设计思路完全不同，同时也有着截然不同的应用场景和特性，我们在这里依次介绍这两种内存分配器的原理。



### 线性分配器

线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：

<img src="https://img.draveness.me/2021-02-28-16145096642924-bump-allocator.png" alt="bump-allocator" style="zoom:67%;" />

**图 10 - 线性分配器**

根据线性分配器的原理，我们可以推测它有较快的执行速度，以及较低的实现复杂度；但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器是无法重新利用红色的这部分内存的：

<img src="https://img.draveness.me/2021-02-28-16145096642930-bump-allocator-reclaim-memory.png" alt="bump-allocator-reclaim-memory" style="zoom:67%;" />

**图 11 - 线性分配器回收内存**

正是因为线性分配器的这种特性，我们需要合适的垃圾回收算法配合使用。标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。

因为线性分配器的使用需要配合具有拷贝特性的垃圾回收算法，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略，我们会在下一节详细介绍常见垃圾回收算法的设计原理。

### 空闲链表分配器

空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：

<img src="https://img.draveness.me/2021-02-28-16145096642935-free-list-allocator.png" alt="free-list-allocator" style="zoom:67%;" />

**图 12 - 空闲链表分配器**

因为不同的内存块以链表的方式连接，所以使用这种方式分配内存的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度就是 `O(n)`。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的就是以下四种方式：

- 首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；
- 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；
- 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；
- 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；

上述四种策略的前三种就不过多介绍了，Go 语言使用的内存分配策略与第四种策略有些相似，我们通过下图了解一下该策略的原理：

<img src="https://img.draveness.me/2021-02-28-16145096642956-segregated-list.png" alt="segregated-list" style="zoom:67%;" />

**图 13 - 隔离适应策略**

如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，我们会在上图中的第二个链表找到空闲的内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。



