```
layout: post
category: golang
title: golang语法
```

```go
package main

import (
	"fmt"
)
```

## go基本知识

在 Printf 方法中，使用 %T 格式说明符（Format Specifier）

所有可执行的 Go 程序都必须包含一个 main 函数。这个函数是程序运行的入口。main 函数应该放置于 main 包中。

在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。

#### 运行Go程序

使用go run a.go

注意：这只会运行一个go文件，当引用其他go文件时，会出错，比如函数未定义，因此需要运行 
```
go run *.go
```

go install命令会安装程序，在工作区嗯bin目录下创建二进制文件，比如kitool,比如lift

#### init 函数
所有包都可以包含一个 init 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。

包的初始化顺序如下：
1. 首先初始化被导入的包。因此，首先初始化了 rectangle 包。
1. 接着初始化了包级别的变量 rectLen 和 rectWidth。
1. 调用 init 函数。
1. 最后调用 main 函数。



## 变量、常量及初始化

下面是 Go 支持的基本类型：

- bool

- 数字类型

	int8, int16, int32, int64, int
	uint8, uint16, uint32, uint64, uint
	float32, float64
	complex64, complex128

- byte    byte 是 uint8 的别名。
- rune    rune 是 int32 的别名。
- string

Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。

```go
/*
变量
 */

func variable()  {

    //集体定义
    var{
        a=3
        b=4
    }
	//1. 指定类型
	// 有默认值
	var a int
	println(a)
	//也可以同时赋值
	var a1 bool=true
	println(a1)

	//2. 自动判断类型
	var b=3
	println(b)

	//3. 省略var
	c:=3
	println(c)
}

/*
常量
 */
 func constVariable(){
 	const a int=3;
	 //多类型简写
	 const c,d,e=1,false,4
	 //可以做枚举
	 const(
		h=1
		i=2
		j=3
		//如果不赋值，就是上一行的值
	 )


	 //itoa
	 //iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，
	 // const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。
	 const (
		 a1 = iota
		 b = iota
		 c1 = iota
	 )
	 //a1是0
 }
 ```

## 字符串和rune

字符串是一个字节切片，所以我们可以获取字符串的每一个字节。

但是 字符串是不可变的。 Go 中的字符串是不可变的。一旦一个字符串被创建，那么它将无法被修改。

len(s) 返回字符串中字节的数量

一个汉字3个字节。。。不知道为啥，本应该是4个字节的，这个到时再看下

```go
func printBytes(s string) {
    for i:= 0; i < len(s); i++ {
        fmt.Printf("%x ", s[i])
    }
}
```

我们尝试输出 Señor 的字符，但却输出了错误的 S e Ã ± o r。 为什么程序分割 Hello World 时表现完美，但分割 Señor 就出现了错误呢？这是因为 ñ 的 Unicode 代码点（Code Point）是 U+00F1。它的 UTF-8 编码占用了 c3 和 b1 两个字节。它的 UTF-8 编码占用了两个字节 c3 和 b1。而我们打印字符时，却假定每个字符的编码只会占用一个字节，这是错误的。在 UTF-8 编码中，一个代码点可能会占用超过一个字节的空间。那么我们该怎么办呢？rune 能帮我们解决这个难题。

rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。让我们修改一下上面的程序，用 rune 来打印字符。

```go
func printChars(s string) {
    runes := []rune(s)
    for i:= 0; i < len(runes); i++ {
        fmt.Printf("%c ",runes[i])
    }
}
```

**用字节切片构造字符串**
```go
    byteSlice := []byte{67, 97, 102, 195, 169}//decimal equivalent of {'\x43', '\x61', '\x66', '\xC3', '\xA9'}
    str := string(byteSlice)
	fmt.Println(str)
```

**用 rune 切片构造字符串**

```go
func main() {  
    runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
    str := string(runeSlice)
    fmt.Println(str)
}
```
**字符串的长度**
utf8 package 包中的 func RuneCountInString(s string) (n int) 方法用来获取字符串的长度。这个方法传入一个字符串参数然后返回字符串中的 rune 的数量。



## 条件语句、循环语句
```go
/*
运算符
 */

func operator()  {
	/*
	运算符没有三目运算符
	有赋值运算法及&& || ！
	有指针操作， & 及 *
	 */
}

/*
条件语句
 */
func ifStatement()  {
	//if
	if 3<4{
		println("3<4")
	}

	if(3<4){
		println("3<4")
	}
	if 3<4{
		println("3<4")
	}else if(4==4){
		println("4==4")
	}else{
		println("Jdd")
	}

	//switch
	/*
	switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，
	从上直下逐一测试，直到匹配为止。。

	switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break
	 */


	var grade string = "B"
	var marks int = 90

	switch marks {
	case 90: grade = "A"
	case 80: grade = "B"
	case 50,60,70 : grade = "C"
	default: grade = "D"
	}

	switch {
	case grade == "A" :
		fmt.Printf("优秀!\n" )
	case grade == "B", grade == "C" :
		fmt.Printf("良好\n" )
	case grade == "D" :
		fmt.Printf("及格\n" )
	case grade == "F":
		fmt.Printf("不及格\n" )
	default:
		fmt.Printf("差\n" );
	}
	//
	//switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。
	//
	//Type Switch 语法格式如下：

	//switch x.(type){
	//	case type:
	//	statement(s);
	//	case type:
	//	statement(s);
	//	/* 你可以定义任意个数的case */
	//	default: /* 可选 */
	//	statement(s);
	//}

	//select
	/*
	select是Go中的一个控制结构，
	类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。

	select随机执行一个可运行的case。如果没有case可运行，它将阻塞，
	直到有case可运行。一个默认的子句应该总是可运行的。
	 */

	var c1, c2, c3 chan int
	var i1, i2 int
	select {
	case i1 = <-c1:
		fmt.Printf("received ", i1, " from c1\n")
	case c2 <- i2:
		fmt.Printf("sent ", i2, " to c2\n")
	case i3, ok := (<-c3):  // same as: i3, ok := <-c3
		if ok {
			fmt.Printf("received ", i3, " from c3\n")
		} else {
			fmt.Printf("c3 is closed\n")
		}
	default:
		fmt.Printf("no communication\n")
	}//out: no communication

}

/*
循环语句
 */

func forStatement() {
	/*
	Go语言的For循环有3中形式，只有其中的一种使用分号。

	和 C 语言的 for 一样：

	for init; condition; post { }
	和 C 的 while 一样：

	for condition { }
	和 C 的 for(;;) 一样：

	for { }
	 */

	//for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：

	//for循环里的变量属于局部变量，与外界不冲突。。。就是for条件的那个位置


	/*
	和 C 的 while 一样：

	for condition { }
	 */
}

```

## 函数
```go
/*
函数
 */

func function()  {
	/*
	func function_name( [parameter list] ) [return_types] {
   		函数体
	}
	 */


	/*
	func swap(x, y string) (string, string) {
		return y, x
	}
	 */

	/*
   函数可作为变量
	*/
	//func f7(){
	//	/* 声明函数变量 */
	//	getSquareRoot := func(x float64) float64 {
	//		return math.Sqrt(x)
	//	}
	//
	//	/* 使用函数 */
	//	fmt.Println(getSquareRoot(9))
	//}

	/*
	闭包
	 */
	//func getSequence() func() int {
	//	i:=0
	//	return func() int {
	//		i+=1
	//		return i
	//	}
	//}
	///* nextNumber 为一个函数，函数 i 为 0 */
	//nextNumber := getSequence()
	//
	///* 调用 nextNumber 函数，i 变量自增 1 并返回 */
	//fmt.Println(nextNumber())
	//fmt.Println(nextNumber())
	//fmt.Println(nextNumber())

	/*
	方法
	 */
	///* 定义结构体 */
	//type Circle struct {
	//	radius float64
	//}
	////该 method 属于 Circle 类型对象中的方法
	//func (c Circle) getArea() float64 {
	//	//c.radius 即为 Circle 类型对象中的属性
	//	return 3.14 * c.radius * c.radius
	//}

}
```


## 数组和指针

Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，则不会影响原始数组。

通过将数组作为参数传递给 len 函数，可以得到数组的长度。


```go
/*
数组
 */
func array()  {
	/*
	var balance [10] float32
	var balance1 = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
	//如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：
	var balance2 = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//直接[]也行
	//多维数组
	var threedim [5][10][4]int
	var a = [3][4]int{
		{0, 1, 2, 3} ,
		{4, 5, 6, 7} ,
		{8, 9, 10, 11},
	}

	*/
	/* 未定义长度的数组只能传给不限制数组长度的函数 */
	/* 定义了长度的数组只能传给限制了相同数组长度的函数 */

}
```

指针的零值是 nil。

**不要向函数传递数组的指针，而应该使用切片**

假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数。

```go
func modify(sls []int) {  
    sls[0] = 90
}

func main() {  
    a := [3]int{89, 90, 91}
    modify(a[:])
    fmt.Println(a)
}
```
Go 并不支持其他语言（例如 C）中的指针运算。


```go
/*
指针
 */

func pointer()  {
	var a int= 20   /* 声明实际变量 */
	var ip *int        /* 声明指针变量 */

	ip = &a  /* 指针变量的存储地址 */
	println(*ip)
	/*
	nil 指针也称为空指针。
	nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
	 */


	 //指针数组
	//var ptr [MAX]*int;

	//指向指针的指针
	//var pptr **int

	//指针作为函数参数
	/* 调用函数用于交换值
	* &a 指向 a 变量的地址
	* &b 指向 b 变量的地址
	*/
	//swap(&a, &b);
	//func swap(x *int, y *int) {}


}
```

## 结构体

结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的。

如果结构体包含不可比较的字段，则结构体变量也不可比较。比如map

匿名结构体
```go
    emp3 := struct {
        firstName, lastName string
        age, salary         int
    }{
        firstName: "Andreah",
        lastName:  "Nikola",
        age:       31,
        salary:    5000,
    }

```

匿名字段

当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。
```go
type Person struct {  
    string
    int
}

func main() {  
    p := Person{"Naveen", 50}
    fmt.Println(p)
}
```

**提升字段（Promoted Fields）**

如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。

```go
type Address struct {
    city, state string
}
type Person struct {
    name string
    age  int
    Address
}

func main() {  
    var p Person
    p.name = "Naveen"
    p.age = 50
    p.Address = Address{
        city:  "Chicago",
        state: "Illinois",
    }
    fmt.Println("Name:", p.name)
    fmt.Println("Age:", p.age)
    fmt.Println("City:", p.city) //city is promoted field
    fmt.Println("State:", p.state) //state is promoted field
}
```

```go
/*
结构体
 */

func structStatement()  {
	/*
	type struct_variable_type struct {
	   member definition;
	   member definition;
	   ...
	   member definition;
	}
	 */

	//variable_name := structure_variable_type {value1, value2...valuen}
	//或
	//variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}

	//// 创建一个新的结构体
	//fmt.Println(Books{"Go 语言", "www.runoob.com", "Go 语言教程", 6495407})
	//
	//// 也可以使用 key => value 格式
	//fmt.Println(Books{title: "Go 语言", author: "www.runoob.com", subject: "Go 语言教程", book_id: 6495407})
	//
	//// 忽略的字段为 0 或 空
	//fmt.Println(Books{title: "Go 语言", author: "www.runoob.com"})

	//结构体作为函数参数
	//func printBook( book Books )

	//结构体指针
	//var struct_pointer *Books
	//使用结构体指针访问结构体成员，使用 "." 操作符：
	//struct_pointer.title;


}
```

## 方法

一般来说，指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。

指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。

在其他的所有情况，值接收器都可以被使用。

注意给值接收器传递指针，那也是更改不可见的，只有指针接收器才可以更改可见

```go
type Employee struct {
    name     string
    salary   int
    currency string
}

/*
  displaySalary() 方法将 Employee 做为接收器类型
*/
func (e Employee) displaySalary() {
    fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
}

func main() {
    emp1 := Employee {
        name:     "Sam Adolf",
        salary:   5000,
        currency: "$",
    }
    emp1.displaySalary() // 调用 Employee 类型的 displaySalary() 方法
}
```

## 可变参数

如果函数最后一个参数被记作 ...T ，这时函数可以接受任意个 T 类型参数作为最后一个参数。

请注意只有函数的最后一个参数才允许是可变的。

```go
func append(slice []Type, elems ...Type) []Type
```

传入后，当成一个数组，range访问就好了


## 切片

append 函数的定义是 func append（s[]T，x ... T）[]T。

我们可以认为，切片在内部可由一个结构体类型表示。这是它的表现形式，

是引用传递，要同步内容修改的

如果切片由数组支持，并且数组本身的长度是固定的，那么切片如何具有动态长度。以及内部发生了什么，当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。

```go
type slice struct {  
    Length        int
    Capacity      int
    ZerothElement *byte
}
```

```go
/*
切片
 */
func slice()  {
	//使用结构体指针访问结构体成员，使用 "." 操作符：
	//struct_pointer.title;

	//var slice1 []type = make([]type, len)
	//
	//也可以简写为
	//
	//slice1 := make([]type, len)

	//make([]T, length, capacity)
	//s := arr[startIndex:endIndex]

	// var numbers = make([]int,3,5)

	//一个切片在未初始化之前默认为 nil，长度为 0，
	//var numbers []int

	numbers := []int{0,1,2,3,4,5,6,7,8}
	/* 打印原始切片 */
	fmt.Println("numbers ==", numbers)

	/* 打印子切片从索引1(包含) 到索引4(不包含)*/
	fmt.Println("numbers[1:4] ==", numbers[1:4])

	//append() 和 copy() 函数

	/* 同时添加多个元素 */
	numbers = append(numbers, 2,3,4)

	/* 创建切片 numbers1 是之前切片的两倍容量*/
	numbers1 := make([]int, len(numbers), (cap(numbers))*2)

	/* 拷贝 numbers 的内容到 numbers1 */
	copy(numbers1,numbers)

}

/*
范围 range
 */

func rangeStatement()  {
	/*
	 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。
	在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key及value 值。
	 */

	//这是我们使用range去求一个slice的和。使用数组跟这个很类似
	nums := []int{2, 3, 4}
	sum := 0
	for _, num := range nums {
		sum += num
	}


}
```

## map

map 的零值是 nil。如果你想添加元素到 nil map 中，会触发运行时 panic。因此 map 必须使用 make 函数初始化。

也就是说必须使用Make

获取 map 的长度使用 len 函数。

和 slices 类似，map 也是引用类型。当 map 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，改变其中一个变量，就会影响到另一变量。

map 之间不能使用 == 操作符判断，== 只能用来检查 map 是否为 nil。

```go
/*
map
 */
func mapStatement()  {
	/* 声明变量，默认 map 是 nil */
	//var map_variable map[key_data_type]value_data_type
	//nil map 不能用来存放键值对

	/* 使用 make 函数 */
	//map_variable := make(map[key_data_type]value_data_type)

	/* 创建map */
	//countryCapitalMap := map[string]string{"France": "Paris",
	// "Italy": "Rome", "Japan": "Tokyo", "India": "New delhi"}


	var countryCapitalMap map[string]string /*创建集合 */
	countryCapitalMap = make(map[string]string)

	/* map插入key - value对,各个国家对应的首都 */
	countryCapitalMap [ "France" ] = "Paris"
	countryCapitalMap [ "Italy" ] = "罗马"

	/*查看元素在集合中是否存在 */
	captial, ok := countryCapitalMap [ "美国" ] /*如果确定是真实的,则存在,否则不存在 */
	/*fmt.Println(captial) */
	/*fmt.Println(ok) */
	if (ok) {
		fmt.Println("美国的首都是", captial)
	} else {
		fmt.Println("美国的首都不存在")
	}

	/*删除元素*/
	delete(countryCapitalMap, "France")
}
```



## 接口

接口的零值是 nil。对于值为 nil 的接口，其底层值（Underlying Value）和具体类型（Concrete Type）都为 nil。


类型断言

类型断言用于提取接口的底层值（Underlying Value）。

在语法 i.(T) 中，接口 i 的具体类型是 T，该语法用于获得接口的底层值。
```go

func assert(i interface{}) {  
    s := i.(int) //get the underlying int value from i
    fmt.Println(s)
}
```

```go
/*
接口 interface
 */
func interfaceStatement()  {
	/*
		type Phone interface {
		call()
	}

	type NokiaPhone struct {
	}

	func (nokiaPhone NokiaPhone) call() {
		fmt.Println("I am Nokia, I can call you!")
	}

	type IPhone struct {
	}

	func (iPhone IPhone) call() {
		fmt.Println("I am iPhone, I can call you!")
	}

	func main() {
		var phone Phone

		phone = new(NokiaPhone)
		phone.call()

		phone = new(IPhone)
		phone.call()

	}
	 */
}
```

注意接口赋值问题

```go
type Describer interface {  
    Describe()
}
type Person struct {  
    name string
    age  int
}

func (p Person) Describe() { // 使用值接受者实现  
    fmt.Printf("%s is %d years old\n", p.name, p.age)
}

type Address struct {
    state   string
    country string
}

func (a *Address) Describe() { // 使用指针接受者实现
    fmt.Printf("State %s Country %s", a.state, a.country)
}

func main() {  
    var d1 Describer
    p1 := Person{"Sam", 25}
    d1 = p1
    d1.Describe()
    p2 := Person{"James", 32}
    d1 = &p2
    d1.Describe()

    var d2 Describer
    a := Address{"Washington", "USA"}

    /* 如果下面一行取消注释会导致编译错误：
       cannot use a (type Address) as type Describer
       in assignment: Address does not implement
       Describer (Describe method has pointer
       receiver)
    */
    //d2 = a

    d2 = &a // 这是合法的
    // 因为在第 22 行，Address 类型的指针实现了 Describer 接口
    d2.Describe()

}
```

## 错误处理
```go
/*
错误处理
 */

func errorHandle()  {
	/*
	error类型是一个接口类型，这是它的定义：

		type error interface {
			Error() string
		}
	 */

/*
	// 定义一个 DivideError 结构
	type DivideError struct {
		dividee int
		divider int
	}

	// 实现 `error` 接口
	func (de *DivideError) Error() string {
		strFormat := `
		Cannot proceed, the divider is zero.
		dividee: %d
		divider: 0
	`
		return fmt.Sprintf(strFormat, de.dividee)
	}

	// 定义 `int` 类型除法运算的函数
	func Divide(varDividee int, varDivider int) (result int, errorMsg string) {
		if varDivider == 0 {
			dData := DivideError{
				dividee: varDividee,
				divider: varDivider,
			}
			errorMsg = dData.Error()
			return
		} else {
			return varDividee / varDivider, ""
		}

	}

 */
}
func main() {

}
```
