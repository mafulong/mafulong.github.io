---
layout: post
category: golang
title: 消息队列nsq和kafka
---
<!-- TOC -->

- [工作原理](#工作原理)
- [使用场景](#使用场景)
- [区别](#区别)

<!-- /TOC -->
kafka有topic和partition的概念，而nsq有topic和channel的概念，topic这一层上大家概念还比较类似，都是说一种订阅的消息类型。到partition和channel这一层就不同了。

## 工作原理
kafka的producer产生特定种类的topic，分发到各个partition中，是没有重复消息的，comsumer本身订阅的是某一个topic，而每个partition只能连接1个comsumer，1个comsumer是可以处理多个partition的，而且其中会根据comsumer的数量做负载均衡。

nsq的channel就不同了，所有的channel都会拿到一份topic传来全部信息传到1个nsqd里，comsumer订阅的不是不仅是topic，还要包含指定channel，一个nsqd接的comsumer数量也可以是多个，nsqlookup会根据comsumer的订阅的channel将其指到特定的nsqd上。

## 使用场景
kafka更像是一个消息的分发器件，对于消息的分发实现topic级别的负载均衡，是针对不同消息的处理模式。对同一消息的不同处理，因为kafka本身会将所有消息固化，接不同的comsumer组去处理的时候只要将offset置到指定位置即可。

nsq比kafka多了一层，对同一消息可能不同业务场景需求也不同，因此用不同的channel去接topic，这样consumer连接channel对应的nsqd去做处理，这是因为nsq本身不做消息的固化，处理完了除了内存里的其他就丢了（除非将 –mem-queue-size 设置为 0），因此用这种处理模式。

## 区别
kafka消息会固化，存文件，nsq默认是不保存的
kafka消息因为固化下来，所以是保序的，nsq传递时候通常是无序的，当然你也可以保留下信息去check时间戳，因此nsq更适合处理数据量大但是彼此间没有顺序关系的消息。
