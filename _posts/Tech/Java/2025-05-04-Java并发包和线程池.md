---
layout: post
category: Java
title: Java并发包和线程池
tags: Java
---

## Java并发包和线程池

## JDK 并发包

### 重入锁

几个重要方法
re-entrance-lock

```java
lock.lock();
//获得锁，如占用，则等待
lockInteruptibly()；
//获得锁，但优先响应中断，就是可以中断的
tryLock()；
//失败返回false,不等待
tryLock(time,unit);
//在给定时间内尝试获得锁
unlock();
//释放锁
```

### 重入锁的好搭档：Condition 条件

condition.await()和 wait()类似

condition.signal()和 notify()类似

要在 lock 块内

### Semaphore

信号量机制

允许多个线程同时访问

```java
Semaphore semaphore=new semaphore(int permits);//permits是个许可证


run(){
    semaphore.acquire();

    ..

    semaphore.release();
}
```

以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

```java
public class SemaphoreExample {
    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
```

resutl:
2 1 2 2 2 2 2 1 2 2

### ReadWriteLock

读写分离锁，可以减少锁竞争，提升性能

### CountdownLatch

就是倒计数的锁存期，可以让线程等待直到倒计时结束，再开始执行

用来控制一个线程等待多个线程。

维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

```java
public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("run..");
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println("end");
        executorService.shutdown();
    }
}
```

result:

    run..run..run..run..run..run..run..run..run..run..end

### CyclicBarrier

允许一组线程互相等待，直到都到达某个公共屏障点

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。但是它的计数器是递增的，每次执行 await() 方法之后，计数器会加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。和 CountdownLatch 的另一个区别是，CyclicBarrier 的计数器可以循环使用，所以它才叫做循环屏障。

这个是规定多少个线程，这一定数量的线程都到达 await()时才开始都唤醒，继续执行

```java
public class CyclicBarrierExample {
    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("before..");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print("after..");
            });
        }
        executorService.shutdown();
    }
}
```

result:

```
before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
```

### Exchanger

用于两个线程之间数据的同步交换，都准备好才交换

## 线程池

[线程池的粗浅使用](https://www.jianshu.com/p/edd7cb4eafa0)

[线程池的分析](http://ifeve.com/java-threadpool/)

[线程池分析更好些](https://www.cnblogs.com/absfree/p/5357118.html)

合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。

### 创建线程池

一般通过工具类 Executors 的静态方法来获取线程池或静态方法。介绍四种常用创建方法

单例线程，表示在任意的时间段内，线程池中只有一个线程在工作

```java
ExecutorService service1 = Executors.newSingleThreadExecutor();
```

缓存线程池，先查看线程池中是否有当前执行线程的缓存，如果有就 resue(复用),如果没有,那么需要创建一个线程来完成当前的调用.并且这类线程池只能完成一些生存期很短的一些任务.并且这类线程池内部规定能 resue(复用)的线程，空闲的时间不能超过 60s,一旦超过了 60s,就会被移出线程池

```java
ExecutorService service2 = Executors.newCacheThreadPool();
```

固定型线程池，和 newCacheThreadPool()差不多，也能够实现 resue(复用),但是这个池子规定了线程的最大数量，也就是说当池子有空闲时，那么新的任务将会在空闲线程中被执行，一旦线程池内的线程都在进行工作，那么新的任务就必须等待线程池有空闲的时候才能够进入线程池,其他的任务继续排队等待.这类池子没有规定其空闲的时间到底有多长.这一类的池子更适用于服务器.

```java
ExecutorService service3 = Executors.newFixedThreadPool(10);
```

调度型线程池,调度型线程池会根据 Scheduled(任务列表)进行延迟执行，或者是进行周期性的执行.适用于一些周期性的工作.

```java
public class Test {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        service.submit(new Runnable() {
            @Override
            public void run() {
                while(true){
                    System.out.println("hello world !");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        System.out.println(" ===> main Thread execute here ! " );
    }
}

```

```java
ExecutorService service4 = Executors.newScheduledThreadPool(10);
```

### 线程池任务创建与提交

任务分为两种:一种是有返回值的（ callable ），一种是没有返回值的（ runnable ）. Callable 与 Future 两功能是 Java 在后续版本中为了适应多并法才加入的，Callable 是类似于 Runnable 的接口，实现 Callable 接口的类和实现 Runnable 的类都是可被其他线程执行的任务。

1. 无返回值的任务就是一个实现了 runnable 接口的类.使用 run 方法.
1. 有返回值的任务是一个实现了 callable 接口的类.使用 call 方法.

Callable 和 Runnable 的区别如下：

1. Callable 定义的方法是 call，而 Runnable 定义的方法是 run。
1. Callable 的 call 方法可以有返回值，而 Runnable 的 run 方法不能有返回值。
1. Callable 的 call 方法可抛出异常，而 Runnable 的 run 方法不能抛出异常。

execute 与 submit 区别：

1. 接收的参数不一样
1. submit 有返回值，而 execute 没有
1. submit 方便 Exception 处理
1. execute 是 Executor 接口中唯一定义的方法；submit 是 ExecutorService（该接口继承 Executor）中定义的方法

### 线程池的关闭

我们可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，但是它们的实现原理不同，shutdown 的原理是只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow 会首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。

只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。

### 线程池的分析

#### 线程池创建分析

```java
new ThreadPoolExecutor(corePoolSize, maximumPoolSize,
keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);
```

创建一个线程池需要输入几个参数：

- corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；
- runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。

1. ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
1. LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列。
1. SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。
1. PriorityBlockingQueue：一个具有优先级得无限阻塞队列。

- maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。也就是说 corePoolSize 就是线程池大小，maximumPoolSize 在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。
- ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。
- RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略。

1. AbortPolicy：直接抛出异常
1. CallerRunsPolicy：只用调用者所在线程来运行任务。
1. DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
1. DiscardPolicy：不处理，丢弃掉。

当然也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务。

- keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。
- TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。

![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505041121762.jpeg)

从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：

1. 如果当前线程池中的线程数目小于 corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
1. 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
1. 如果当前线程池中的线程数目达到 maximumPoolSize，则会采取任务拒绝策略进行处理；

如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止

从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。

newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；

newSingleThreadExecutor 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；

newCachedThreadPool 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过 60 秒，就销毁线程。

实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。

## AQS原理

> AQS（AbstractQueuedSynchronizer）的原理。它是 Java 并发框架中用于构建锁和同步器的一个核心框架类，比如 ReentrantLock、Semaphore、CountDownLatch 等同步器，底层都是基于 AQS 实现的。是 Java 并发包 `java.util.concurrent.locks` 中用来构建锁和其他同步器（如信号量、读写锁、倒计时器等）的一个**基础框架类**。它是 J.U.C 并发框架中最核心的底层组件之一。



AQS 通过一个**FIFO 队列**（先进先出等待队列）来**管理获取锁失败的线程**，并通过一个**原子变量 state** 来**表示同步状态**，从而实现各种自定义同步器。

#### 🌟 1. 核心思想：状态 + 队列

AQS 的核心是两个部分：

- **state**：一个 `volatile int state` 表示当前的同步状态，比如 0 表示未加锁，1 表示已加锁。
- **等待队列（CLH 队列）**：线程获取锁失败后，会被封装为一个 `Node` 节点，加入到一个 **FIFO 双向队列** 中，并通过 `LockSupport.park()` 挂起。

#### 🔁 2. 获取锁流程（以独占为例）：

- 线程调用 `acquire()` 尝试加锁，底层会调用 `tryAcquire()`。
- 如果 `tryAcquire()` 失败，就进入等待队列，并阻塞当前线程。
- 前一个线程释放锁时调用 `release()`，底层调用 `tryRelease()` 成功后唤醒下一个线程。

#### 🧱 3. AQS 提供模板方法，子类负责实现：

```

protected boolean tryAcquire(int arg);
protected boolean tryRelease(int arg);
```

开发者通过继承 AQS 并实现这些方法，可以自定义同步器的行为。

#### 📌 4. 支持两种模式：

- **独占模式（Exclusive）**：一次只允许一个线程获取资源，如 ReentrantLock。
- **共享模式（Shared）**：多个线程可以共享资源，如 Semaphore、CountDownLatch。

#### 📚 5. 实际应用举例：

- ReentrantLock：基于 AQS 的独占模式。
- Semaphore：基于共享模式控制并发数量。
- CountDownLatch：通过共享计数控制线程等待。



Java 中很多同步器都是基于 AQS 实现的：

| 同步器                     | 使用 AQS 模式  |
| -------------------------- | -------------- |
| ReentrantLock              | 独占           |
| Semaphore                  | 共享           |
| CountDownLatch             | 共享           |
| ReentrantReadWriteLock     | 读共享，写独占 |
| AbstractQueuedSynchronizer | 自定义扩展     |