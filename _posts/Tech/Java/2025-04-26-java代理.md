---
layout: post
category: Java
title: java代理
tags: Java
---

## java代理

## 1. Java 中的代理分类



| 类型     | 描述                         | 例子                     |
| -------- | ---------------------------- | ------------------------ |
| 静态代理 | 编写代理类，手动调用目标方法 | 自己写的代理类           |
| 动态代理 | 运行时生成代理类             | JDK 动态代理、CGLIB 代理 |

------

## 2. 静态代理

### 特点

- 代理类和被代理类都需要实现相同的接口。
- 需要手动编写代理类。
- 扩展性差，如果接口方法多，需要重复工作。

### 示例

```java

public interface Service {
    void doSomething();
}

public class RealService implements Service {
    public void doSomething() {
        System.out.println("Real service is doing something");
    }
}

public class ServiceProxy implements Service {
    private RealService realService = new RealService();

    public void doSomething() {
        System.out.println("Before");
        realService.doSomething();
        System.out.println("After");
    }
}
```

------

## 3. JDK 动态代理

### 特点

- 只能代理**接口**（`interface`）。
- 运行时动态生成代理对象。
- 通过 `Proxy` 类和 `InvocationHandler` 接口实现。

### 核心类

- `Proxy`：生成代理对象。
- `InvocationHandler`：处理方法调用的接口。

### 示例代码

```java

UserService target = new UserServiceImpl();
UserService proxy = (UserService) Proxy.newProxyInstance(
        target.getClass().getClassLoader(),
        target.getClass().getInterfaces(),
        (proxyObj, method, args) -> {
            System.out.println("Before");
            Object result = method.invoke(target, args);
            System.out.println("After");
            return result;
        }
);
proxy.sayHello();
```

### 面试重点

- **为什么 JDK 动态代理只能代理接口？**
   因为 Java 的 Proxy 类生成的代理类是通过 `implements 接口` 来创建的，不是继承类。

- **JDK 动态代理的底层实现？**
   通过运行时生成一个新类（继承 `Proxy` 类并实现接口），字节码生成后加载到 JVM 中。

- **如何保存生成的代理类？**
   设置系统属性：

  ```java
  
  System.setProperty("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");
  ```

------

## 4. CGLIB 动态代理

### 特点

- 可以代理**普通类**（没有接口也能代理）。
- 通过**继承**的方式生成子类代理。
- CGLIB（Code Generation Library）是开源项目，Spring 默认也集成了。

### 核心类

- `Enhancer`：生成代理对象。
- `MethodInterceptor`：方法拦截器。

### 示例代码

```java

Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(UserService.class);
enhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -> {
    System.out.println("Before");
    Object result = proxy.invokeSuper(obj, args);
    System.out.println("After");
    return result;
});
UserService proxy = (UserService) enhancer.create();
proxy.sayHello();
```

### 面试重点

- **为什么 final 类不能被 CGLIB 代理？**
   因为 CGLIB 是通过继承来生成代理子类的，final 类不能被继承。
- **CGLIB 与 JDK 动态代理的区别？**



|              | JDK 动态代理   | CGLIB 动态代理                       |
| ------------ | -------------- | ------------------------------------ |
| 是否需要接口 | 是             | 否                                   |
| 实现方式     | 实现接口       | 继承类                               |
| 代理限制     | 只能代理接口   | final类不能代理，final方法不会被代理 |
| 性能         | 接口少时性能好 | 类复杂时性能好                       |

- **CGLIB 代理的原理？**
   基于 ASM 框架，在运行时生成字节码文件，创建子类并重写方法。

------

## 5. 动态代理在 Spring AOP 中的应用

### Spring 代理选择策略

- 有接口：**默认用 JDK 动态代理**。

- 没有接口：使用 **CGLIB 动态代理**。

- 可以通过配置强制使用 CGLIB：

  ```java
  
  spring:
    aop:
      proxy-target-class: true
  ```

  或者在 JavaConfig 里：

  ```java
  
  @EnableAspectJAutoProxy(proxyTargetClass = true)
  ```

------

## 6. QA

✅ **什么是动态代理？**
 动态代理是运行时生成代理对象，拦截并增强方法调用的一种机制。

✅ **JDK 动态代理和 CGLIB 的区别？**
 JDK 动态代理基于接口，CGLIB 基于继承（子类化目标类）。

✅ **JDK 动态代理的底层原理？**
 通过 `Proxy` 类+`InvocationHandler` 动态生成实现接口的类（字节码生成+反射调用）。

✅ **CGLIB 动态代理能代理 final 类吗？**
 不能，CGLIB 通过继承生成代理类，final 类无法继承。final方法也不能代理

✅ **Spring AOP 是如何选择代理方式的？**
 默认有接口用 JDK 动态代理，没接口用 CGLIB；可以配置 `proxy-target-class=true` 强制使用 CGLIB。

✅ **如何保存 JDK 生成的代理类字节码？**
 设置系统属性：

```

System.setProperty("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");
```

✅ **动态代理的优缺点？**



| 优点                                        | 缺点                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| 1. 解耦增强逻辑与业务逻辑 2. 运行时灵活增强 | 1. 性能稍有开销 2. JDK Proxy必须有接口 3. CGLIB无法代理final类或方法 |