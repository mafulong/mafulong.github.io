---
layout: post
category: Java
title: java垃圾回收
tags: Java
---

## java垃圾回收

垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。



## 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 提供了四种强度不同的引用类型。

#### 1. 强引用

被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

#### 2. 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

#### 3. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### 4. 虚引用

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来创建虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

## 垃圾回收

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法



### 垃圾收集器

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv6/v6/202505031212304.jpg)



以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

细节参考 [link](http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95)



| 收集器     | 新生代 / 老年代   | 是否并发 | 是否压缩整理   | 暂停时间 | 使用场景                            |
| ---------- | ----------------- | -------- | -------------- | -------- | ----------------------------------- |
| Serial     | 是 / 是           | 否       | 是             | 高       | 小内存、单核场景（如客户端）        |
| Parallel   | 是 / 是           | 否       | 是             | 中       | 吞吐优先场景，如批处理              |
| CMS        | 是 / 是           | 部分并发 | 否             | 低       | 低延迟要求，但 JDK9 起废弃          |
| G1         | 是 / 是（Region） | 是       | 是（并发整理） | 中低     | 推荐，默认 GC，适合大多数服务端应用 |
| ZGC        | 是 / 是（Region） | 全并发   | 是             | 极低     | 超低延迟，大内存应用，JDK11+        |
| Shenandoah | 是 / 是（Region） | 全并发   | 是             | 极低     | RedHat 主推，类似 ZGC，适合低延迟   |





- **Serial** 简单、低资源；
- **Parallel** 高吞吐；
- **CMS** 停顿短但容易碎片；**CMS** 不建议使用，G1 是推荐替代方案。
- **G1** 平衡型、适用于大多数服务端；
- **ZGC/Shenandoah** 面向超低延迟场景。



**CMS 和 G1 有什么区别？**

| 对比项   | CMS             | G1              |
| -------- | --------------- | --------------- |
| 内存结构 | 新生代 + 老年代 | Region 动态分配 |
| 并发性   | 并发标记        | 并发标记 + 压缩 |
| 碎片问题 | 有              | 无              |
| 吞吐量   | 中              | 中高            |
| 已废弃   | 是              | 否（默认）      |



STW 是 JVM 在某些 GC 阶段需要 **暂停所有用户线程**。为了减少影响：

- 使用并发收集器（如 G1、ZGC）
- 设置合理参数（如 `MaxGCPauseMillis`）
- 减少大对象和频繁分配
- 使用 GC 日志分析 GC 次数与耗时



GC卡顿排查

- 开启 GC 日志：`-Xlog:gc*` 或 `-XX:+PrintGCDetails`
- 分析 GC 时间、频率、Full GC 是否频繁
- 观察堆使用情况、晋升失败等
- 使用工具（如 VisualVM、jstat、JFR、Arthas）诊断



### G1

G1 的思路是 —— **以 Region 为单位整理活对象**。 G1 通过在 GC 过程中，按 Region 单位将活对象搬迁并压缩，避免碎片化，同时又分阶段进行，减轻暂停负担。

✅ 具体流程如下：

1. **标记活对象（Concurrent Marking）**
   - 通过并发标记阶段，识别出所有“存活对象”
   - 并计算每个 Region 的“回收价值”（垃圾比例）
2. **筛选 Region**
   - G1 选择回收价值最高的部分 Region 进行回收（称为 **收集集（Collection Set, CSet）**）
3. **对象转移（Evacuation）**
   - 将存活对象从 CSet 中迁移到新的空 Region（可 Eden、Survivor、Old）
   - 迁移时是压缩式移动：**连续地复制活对象 → 减少碎片**
4. **更新引用**
   - 并发地通过记忆集（Remembered Set）和 SATB（Snapshot At The Beginning）机制，更新被引用地址
5. **旧 Region 回收**
   - 所有对象被转移后，旧 Region 被标记为空，可重用



注意

- G1 的压缩不是在 **Full GC** 阶段才执行，而是在 **Young GC 和 Mixed GC 中增量地进行**
- 每次 GC 只处理部分 Region，**减少一次性 Stop-The-World 的开销**
- 所以 G1 被称为支持“**增量压缩**”的收集器

### 各版本JDK垃圾回收

| JDK版本     | 默认 GC     | 描述简要                           |
| ----------- | ----------- | ---------------------------------- |
| ≤ JDK 1.3   | Serial GC   | 单线程、Stop-The-World             |
| JDK 1.4 - 7 | Parallel GC | 高吞吐量，服务端默认               |
| JDK 8       | Parallel GC | 默认 Parallel，可选开启 G1         |
| JDK 9 - 14  | G1 GC       | 默认 G1，支持并发压缩，低停顿      |
| JDK 15 - 17 | G1 GC       | 默认 G1，ZGC/Shenandoah 成熟       |
| JDK 18 - 20 | G1 GC       | 默认仍为 G1，ZGC 更加稳定          |
| JDK 21 LTS  | G1 GC       | 默认 G1，ZGC/Shenandoah 可选生产用 |
| JDK 22+     | G1 GC       | 社区拟改为 ZGC，暂未切换默认       |





