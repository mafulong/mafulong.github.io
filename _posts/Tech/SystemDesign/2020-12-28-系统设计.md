---
layout: post
category: SystemDesign
title: 系统设计
tags: SystemDesign
---

## 系统设计

[参考](https://soulmachine.gitbooks.io/system-design/content/cn/)

[https://www.bookstack.cn/read/system-design/cn-task-scheduler.md](https://www.bookstack.cn/read/system-design/cn-task-scheduler.md)



几本书：

[https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd6.html](https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd6.html)

[https://github.com/donnemartin/system-design-primer](https://github.com/donnemartin/system-design-primer)

[对应上面的翻译](https://wizardforcel.gitbooks.io/system-design-primer/content/)

必看： Grokking system design

[https://github.com/lei-hsia/grokking-system-design](https://github.com/lei-hsia/grokking-system-design)

设计数据密集型应用-Data-Intensive Application

[https://github.com/donnemartin/interactive-coding-challenges](https://github.com/donnemartin/interactive-coding-challenges)

[两周系统设计面试速成大纲](https://acecodeinterview.com/2_week_prep/)

答题流程

1. 先问核心需求，增加假设
2. 关注 性能、伸缩性(扩容）、扩展性、可用性(主备等)、安全性
3. 几个模块，每个模块提供什么样的能力
4. 各个模块的存储设计
5. 整体架构

## [系统设计参考1](https://soulmachine.gitbooks.io/system-design/content/cn/tinyurl.html)

### 分布式ID生成器

核心需求

- 全局唯一(unique)
- 按照时间粗略有序(sortable by time)
- 尽可能短

雪花算法: 

- 4个字节表示的Unix timestamp,
- 3个字节表示的机器的ID
- 2个字节表示的进程ID
- 3个字节表示的计数器

时间在前面可保证有序



使用mysql自增id, 比如8台机器，每个机器每次+8

### 短网址系统

需求

- 足够短

网上链接大概45亿，长度7的字符串足够了，每个元素是大小写字母+数字

用分布式id生成器生成短链，用Nosql kv来存， 短网址-> 长网址

使用302临时重定向

### 信息流

[专门blog](https://mafulong.github.io/2020/12/28/Feed%E6%B5%81/)

### 定时任务调度器

[参考个人blog](https://mafulong.github.io/2021/04/06/%E5%AE%9A%E6%97%B6%E5%99%A8/)

### API限速

[参考个人blog: 限流器](https://mafulong.github.io/2021/04/12/%E9%99%90%E6%B5%81%E5%99%A8/)



### 设计线程安全的hashmap

hashmap可以拉链法，也可以java8一样，不是拉链，而是个红黑树，解决了hash冲突后的问题。

可以像concurrentHashMap一样采用分段锁保护。

### 实时输出最近一个小时内访问频率最高的10个IP

1. 3600s，3600个hashmap，存储每一秒的每个ip的访问次数。

2. 同时还要新建一个固定大小为10的小根堆，用于存放当前出现次数最大的10个IP。堆顶是10个IP里频率最小的IP。



3. 每次来一个请求，就把该秒对应的HashMap里对应的IP计数器增1，并查询该IP是否已经在堆中存在，

- 如果不存在，则把该IP在3600个HashMap的计数器加起来，与堆顶IP的出现次数进行比较，如果大于堆顶元素，则替换掉堆顶元素，如果小于，则什么也不做
- 如果已经存在，则把堆中该IP的计数器也增1，并调整堆

4. 需要有一个后台常驻线程，每过一秒，把最旧的那个HashMap销毁，并为当前这一秒新建一个HashMap，这样维持一个一小时的窗口。

5. 每次查询top 10的IP地址时，把堆里10个IP地址返回来即可。

如果内部存不下，可以使用redis等，同时时间跨度长的话还可以桶塌缩，近似统计。

### 设计一个负载均衡

负载均衡策略需要将请求均匀分配到各个服务节点，避免出现请求集中在某一点上的情况。有时会考虑节点权重，会话粘连等需求

> [参考](https://juejin.cn/post/6844903648460292109)

服务端节点列表存储下来，定时探活。

- 随机：数组存储列表，随机数字。

- 无权重轮询：移动cursor，数组

- 无权重轮询：移动cursor，数组。**权重分别为1,2,3的3该节点A,B,C，会先请求A一次，再请求B两次，再请求C三次**

- 平滑权重轮询

  - 所谓平滑, 即在一定的时间内, 不仅服务器被选择的次数分布和权重一致，满足权重要求，且调度算法还能比较均匀的选择节点分配请求

  - totalWeight：保存所有节点的权重和，该值在后续流程中保持不变

    nodeOriginWeight：保持每个节点的原始权重，在后续流程中也保持不变

    nodeCurWeights：保存每个节点的当前权重，该数组在后续每次计算请求应该分配到哪个节点时都会发生变化，初始化为每个节点的权重

    每次选择节点，都会执行以下3步

    - 选出当前权重中，值最大节点a
    - 将a的当前权重值减去**totalWeight**
    - 将每个当前权重加上每个节点的原始权重

  - 原理：**若某个节点增长越快，则越有概率被选中，而增长的速度和权重大小成正比，因此节点权重越大，越有概率被选中。相反或节点权重越小，增长成为最大当前权重节点的速度越慢，被选中的概率较低，从而达到按权重分配请求的效果**

    当每个节点被选中后，减去的值都相等，由于减去了一个较大的值（所有节点原始权重总和），**使得该节点在下几次请求中，被选中的概率较低，因为恢复成为最大值需要时间。从而达到平滑的效果**

- 最小活跃数：按活跃数排序，可以是avl树、跳表等。每次请求+1
- 一致性hash：参考个人blog，如数组二分查找、红黑树等，虚拟节点，hash个数字。

### 设计Key-Value存储引擎

[参考个人blog: leveldb设计及实现]()

### 网络爬虫

网络爬虫分两种

1. 这种是给搜索引擎用的

![image-20220101180152357](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220101180152.png)

2. 如果是定向爬取，可能是运营用的

   侧重于ip池、parse规则等。

### 分布式PageRank

1. 



