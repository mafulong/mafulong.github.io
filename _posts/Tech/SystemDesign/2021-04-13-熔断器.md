---
layout: post
category: SystemDesign
title: 熔断器
tags: SystemDesign
---

## 熔断器

### 熔断器模式

熔断器模式定义了熔断器开关相互转换的逻辑:

![image-20210413173622309](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20210413173634.png)

服务的健康状况 = 请求失败数 / 请求总数.
熔断器开关由关闭到打开的状态转换是通过当前服务健康状况和设定阈值比较决定的.

1. 当熔断器开关关闭时, 请求被允许通过熔断器. 如果当前健康状况高于设定阈值, 开关继续保持关闭. 如果当前健康状况低于设定阈值, 开关则切换为打开状态.
2. 当熔断器开关打开时, 请求被禁止通过.
3. 当熔断器开关处于打开状态, 经过一段时间后, 熔断器会自动进入半开状态, 这时熔断器只允许一个请求通过. 当该请求调用成功时, 熔断器恢复到关闭状态. 若该请求失败, 熔断器继续保持打开状态, 接下来的请求被禁止通过.

熔断器的开关能保证服务调用者在调用异常服务时, 快速返回结果, 避免大量的同步等待. 并且熔断器能在一段时间后继续侦测请求执行结果, 提供恢复服务调用的可能.



资源上可以互相隔离。比如一个依赖服务端一个熔断器。

微服务可以两个熔断器，一个是针对服务实例熔断、一个是针对依赖服务接口熔断。

并且也不必全靠真实流量从半开到闭合，像实例也可以用Ping定时检测自动恢复，避免影响真实流量。



以上也是**Hystrix** [hɪst'rɪks]的设计理念。



### 熔断器实现

以golang为例子。使用无锁结构或者atomic方式。

维护bucket，比如每10ms一个bucket， bucket上维护计数器cnt。

每次接口调用都在最新的bucket上+1，可能是success也可能是fail。

计算是否熔断时累加每个bucket的值即可。



bucket组织形式感觉可以用的循环数组实现。循环数组可以用个mutex锁住。