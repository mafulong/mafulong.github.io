---
layout: post
category: SystemDesign
title: 在线文档协同编辑
tags: SystemDesign
---

## 在线文档协同编辑

OT 的英文全称是 Operational transformation，是一种处理协同编辑的算法。

它常用于实现协同文档的底层算法，支持多个用户同时编辑文档，不会因为并发修改导致冲突，而使结果不一致或数据丢失。



## 冲突的处理方式

假设 A 和 B 在同时编辑同一个内容，我们处理冲突的方式有：

1. **加锁**。用户 A 在编辑时，就锁住文档，只能 A 进行更新。用户 B 就不能编辑，或编辑后提交修改被服务器丢弃；
2. **覆盖**。谁最后修改，就全量使用他的修改，更早一些的其他人的修改会被丢弃。
3. **用户自行处理冲突**。就像 git merge 导致的冲突一样，会提示哪个地方被同时修改了，让合并者手动选择使用哪一个修改；
4. **使用一致性算法**。比如我们要介绍的 OT 算法，可以让用户编辑进行算法处理进行调整，在多个客户端生成一致的修改结果。

对于在线协同文档，

加锁体验太差，一个人在编辑时其他人就要干等着。

覆盖则是导致用户的修改来回彼此覆盖，辛苦编辑的内容突然被别人覆盖掉了心情低落。

自行处理冲突则需要额外的操作步骤和成本，实时性很差，不适合高频同时修改的场景。

一致性算法是最好的选择，对用户最友好，不过带来了实现的复杂。



## 使用 OT

OT 算法可以解决一致性问题，我们来看看 OT 到底做了什么。

同样，原始内容是 “12”。

1. 用户 A 在末尾添加 “A”，本地变成 “12A”，并发送 `insert(2, A)`，这个操作计作 OA；
2. 用户 B 在末尾添加 “B”，本地变成 “12B”，并发送 `insert(2, B)`，这个操作计作 OB；
3. 用户 A 收到 OB，执行 `transform(OA, OB)`，得到修正后的操作 `insert(3, B)`，记为 OB'，相比 OB，它将插入位置从 2 修正为 3，于是 "12A" 变成了 “12AB”；
4. 用户 B 则收到 OA，同样执行 `transform(OA, OB)`，得到修正操作 `insert(2, A)`，记为 O1'，让内容从 "12A" 变成 “12AB”。transform 方法会同时产生 OA' 和 OB'。

最后，用户 A  和用户 B 看到的是 **一致** 的 “12AB”。



这里的核心在于这个 `transfrom` 方法，它能够对操作进行修正。transform 没有固定实现，要根据实际需求自行实现。



假如我们把 A 提交的行为叫做 A，B 提交的行为叫做 B，现在后台就是一个简单的转发功能，告诉 A 的是 B，告诉 B 的是 A，然后就出现问题了。所以后台应该更聪明一点，它应该学会一个招术，那就是把每个人提交的行为转变一下再告诉别人，其实这个技术就是 OT 算法。

OT 算法全名叫 **Operation Transformation**，你看从名字就对应了上面我说的转变算法。
假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A',B'。
也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A'行为告诉 B，把 B'行为告诉 A，这样大家再应用就相安无事了。

这里实际抽象一下，用户永远就只有两个人，一个是自己，一个是服务端，只是服务端的操作可能来自很多人，如果不这样抽象，那一个个进行冲突处理可能会让你觉得无法理解。



## OT 算法的实现

所有对文本的操作都可以抽象成三个原子行为：

> R = Retain，保持操作
> I = Insert，插入操作
> D = Delete，删除操作

那之前的行为

> **第 3 个字符行后面插入了一个 ‘d’**

就会变成

> R(3), I('d')



核心

你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A'行为告诉 B，把 B'行为告诉 A，这样大家再应用就相安无事了。

```scala
  // produces two operations A' and B' (in an array) such that
  // `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the
  // heart of OT.
```

A和B原子操作只有三种，根据排列组合，最多只会有 9 种情况。 分别处理即可。

比如A是插入，则遍历位置对应字符，判断A是Insert，则B对这个字符进行Retain，相当于延后B的字符串处理，索引S对应需要加一。 

## 时序

不是基于时间先后。

而是要基于版本。



## 服务器设计

服务器中维护了一系列历史的修改版本，例如 r1,r2,r3,…r100,…r110

假如某个客户端提交的变化 C,是基于 R100 的，这时候，我们需要不停的产生变化 newC = follow(R101,C)  , 然后 newC =  follow(R102,newC)，不断执行，最后要得到针对 r110 这个版本的 newC 变化，推送到各个客户端

## 参考

- [协同编辑中使用的 OT 算法是什么？](https://juejin.cn/post/7137846657474887711)

