---
layout: post
category: OperationSystem
title: 操作系统复习笔记
tags: OperationSystem
---

## 概念

- 周转时间：指从作业进入系统开始，直至其完成并退出系统为止所经历额时间- 分时系统：一台计算机分时提供给多个用户同时使用

1. 硬实时任务：必须满足任务对截止时间的要求
2. 软实时任务，不严格

- windows是单用户多任务操作系统，linux是多用户多任务操作系统

- 操作系统的基本特征：并发、共享、虚拟、异步
- 并行是同一时刻发生，并发是在同一时间间隔内发生
- 进程是能独立运行并作为资源分配的基本单位
- 线程作为独立运行和独立调度的基本单位，基本上不拥有系统资源，所以调度开销小
- 进程的异步性：以不可预知的速度向前推进
- 调度包括作业调度（选择作业分配资源分别为它们建立进程），进程调度（选择进程分配CPU），中级调度（进程挂起解挂）
- 缓冲：解决CPU高速和I/O低速间的矛盾性

## 进程管理
- 进程实体：程序段、数据段、PCB
- PCB: 进程标识符、处理机状态、进程调度信息、进程控制信息
- 原语：若干条原子操作组成 ，原子操作是不可分割的基本单位，管态下执行，常驻内存
- 进程的创建：申请空白PCB，分配资源，初始化进程控制块，插入就绪队列
- 进程同步制约关系：1.间接制约关系（互斥，不知道对方是谁），2.直接制约关系（同步，知道对方的存在）
- 同步进制规则：空闲让进，忙则等待，有限等待，让权等待
- 信号量集：Swait(S,d1,d2); 需要不少于d1,减去d2个；Swait(S,1,1)和wait一样，Swait(S,1,0)是开关
- 管程：模块化，定义公共数据结构，如消息队列
- 高级进程通信机制：共享存储器系统（共享数据结构或者开辟内存区），消息传递系统，管道通信（1.互斥，2.同步，3.需要确定对方已存在）
- 消息传递通信的方法:1.直接通信方式,Send和Receive，2.间接通信方式，需要通过作为共享数据结构的实体，实体叫做信箱，信箱包括私用（用户创建），公用信箱（os创建），共享信箱（进程创建，指定共享进程的名称）

## 处理机调度和死锁
- 带权周转时间：周转时间与系统为它提供服务的时间之比
- 调度算法：先来先服务FCFS，短作业有限SJF，高优先权调度算法，高响应比优先调度，优先权为周转时间与要求服务时间的比值，时间片轮转调度
- 产生死锁的原因：竞争资源，进程间推进顺序不合理
- 死锁必要条件：互斥，请求和保持，不剥夺，环路等待
- 解决死锁：银行家算法
- 预防死锁：摒弃请求和保持，摒弃不剥夺，摒弃环路等待
- 程序的装入和链接：绝对装入，可重定位装入，动态运行时装入；静态链接，装入时动态链接，运行时动态链接
- 连续分配方式：单一连续分配，固定分区分配，动态分区分配
- 分区分配算法：首次适应算法（从首部开始找），循环首次适应算法（从开始找），最佳适应算法，最坏适应算法，快速适应算法
- 页面置换算法：最佳置换算法（选择未来最长时间不再访问的），最近最久未使用LRU（选择以前未访问时间最长的）

## 用户进程间通信主要哪几种方式？

解答：主要有以下6种：

1、管道：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。

无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。

命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的I/O操作以后，命名管道将继续保存在文件系统中以便以后使用。

2、信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

3、消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4、信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

5、共享内存：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。

6、套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。

## 线程间的通信方式
锁机制：包括互斥锁、条件变量、读写锁

1. 互斥锁提供了以排他方式防止数据结构被并发修改的方法。

2. 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。

条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

信号机制(Signal)：类似进程间的信号处理

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

## PCB结构
进程实体：程序段、数据段、PCB

PCB: 进程标识符、处理机状态、进程调度信息、进程控制信息

[参考](https://www.cnblogs.com/alantu2018/p/8472017.html)  

但pcb还有一些复杂的

- 进程调度信息： 优先级
- 进程通信：与信号量相关的等待队列
- 进程链接：父子进程
- 时间和定时器：进程创建时间，时间片上剩余时间
- 文件系统信息：进程可以打开或关闭文件，文件属于系统资源，Linux 内核要对进程使用文件的情况进行记录
- 虚拟内存信息: 除了内核线程（Kernel Thread），每个进程都拥有自己的地址空间（也叫虚拟空间）
- 面管理信息: 当物理内存不足时，Linux 内存管理子系统需要把内存中的部分页面交换到外存，其交换是以页为单位的。

## 程序装入和链接
#### **1. 程序的装入（Loading）**

装入是指将程序从外存装入到内存中执行的过程。主要分为以下几种装入方式：

**（1）绝对装入**

- **特点**：编译时生成绝对地址的目标代码，装入时直接装到内存的指定位置。
- **优点**：简单、高效。
- **缺点**：程序无法移动或重定位，无法实现共享。

**（2）可重定位装入**

- **特点**：编译器生成可重定位代码，装入程序时，由装入程序对代码进行重定位。
- **优点**：灵活，可支持程序共享和内存优化。
- **常用的重定位方式**：静态重定位和动态重定位。

**（3）动态运行时装入**

- **特点**：仅在程序运行时将需要的模块装入内存。
- **优点**：节省内存，提高程序的灵活性。
- **缺点**：装入开销较高。

------

#### **2. 程序的链接（Linking）**

链接是指将目标代码、库文件等多个模块组合成一个可执行文件的过程。主要包括以下两种方式：

**（1）静态链接**

- **原理**：在编译时将所有依赖的库函数和目标模块直接链接到最终的可执行文件中。

- 优点

  ：

  - 可执行文件独立性强。
  - 执行时无需依赖外部库。

- 缺点

  ：

  - 可执行文件较大。
  - 修改库函数需要重新编译。

**（2）动态链接**

- **原理**：程序运行时才加载依赖的动态链接库（如 `.dll`、`.so` 文件）。

- 优点

  ：

  - 可执行文件较小。
  - 修改库函数无需重新编译。

- 缺点

  ：

  - 运行时需要依赖动态库。
  - 存在版本兼容性问题。

------

#### **3. 装入与链接的区别**

| 方面     | 装入                               | 链接                               |
| -------- | ---------------------------------- | ---------------------------------- |
| 定义     | 将程序从外存装入内存               | 将目标模块和库文件组合成可执行文件 |
| 发生时间 | 程序运行前（绝对、重定位）或运行时 | 程序运行前（静态/动态链接）        |
| 结果     | 程序在内存中准备好执行             | 生成完整的可执行文件               |

## 内存分配和回收buddy算法及slab算法

[参考](https://zhuanlan.zhihu.com/p/36140017)

Buddy 系统是一种基于分区的动态内存分配算法，适用于操作系统中内存分配与回收，能够快速分配大块和小块的内存。

buddy算法通过页面管理，多个链表，每个链表有不同的2^n个页面的节点，依次分配。申请128的没有时，从256借个并把剩下的放到128的。回收时进行连续内存合并。

两个伙伴块可以通过地址判断：如果两个块的起始地址按块大小对齐后是连续的，则它们是伙伴。



Slab 分配器主要用于内核的对象分配，减少对象的分配和释放开销，适合频繁分配的小对象。

slab分配器就应运而生了，专为小内存分配而生。slab分配器分配内存以Byte为单位。但是slab分配器并没有脱离伙伴系统，而是基于伙伴系统分配的大内存进一步细分成小内存分配。

slab是slab分配器的最小单位，在实现上一个slab有一个或多个连续的物理页组成（通常只有一页）。单个slab可以在slab链表之间移动，例如如果一个半满slab被分配了对象后变满了，就要从slabs_partial中被删除，同时插入到slabs_full中去。

为了进一步解释，这里举个例子来说明，用struct kmem_cache结构描述的一段内存就称作一个slab缓存池。一个slab缓存池就像是一箱牛奶，一箱牛奶中有很多瓶牛奶，每瓶牛奶就是一个object。分配内存的时候，就相当于从牛奶箱中拿一瓶。总有拿完的一天。当箱子空的时候，你就需要去超市再买一箱回来。超市就相当于partial链表，超市存储着很多箱牛奶。如果超市也卖完了，自然就要从厂家进货，然后出售给你。厂家就相当于伙伴系统。

## 

| **属性**     | **Buddy 系统**           | **Slab 分配器**                    |
| ------------ | ------------------------ | ---------------------------------- |
| **用途**     | 通用内存分配             | 特定对象分配（常用于操作系统内核） |
| **分配粒度** | 动态大小（2 的幂次方块） | 固定大小对象                       |
| **内存碎片** | 易产生内部碎片和外部碎片 | 几乎没有外部碎片                   |
| **效率**     | 分配和回收快             | 对频繁小对象分配优化更明显         |
| **复杂性**   | 较低                     | 较高                               |