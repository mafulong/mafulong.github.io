---
layout: post
category: OperationSystem
title: 为什么需要补码
tags: OperationSystem
---

## 为什么需要反码

**反码的作用就相当于数学中的负数。**

就是把a-b变成a+(-b) 这样就可以不用溢出位，然后计算，也就是a+(-b)=a+（b的取反+1），比如4-2=0100-0010= 0100+(-0010) = 0100+1010 然后求对应补码 = 0100+1110 = 10010 不管溢出位 = 0010 = 2

另外，两个用补 码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。 

有了补码，计算时不特殊考虑符号位，和其他位置的一样考虑。



计算机的加减法运算天生是一个模2^N的同余类上的运算，满2^N会抛弃进位，那表示有符号数时使用同余类代表很正常吧，比如-1 = 2^N -1 (mod 2^N)，-2 = 2^N-2 (mod 2^N)。

## 为什么需要补码

### 补码怎么来的：

如何将-变为+?

将数字排成一个圈，负数就是往后数。

在二进制下，当忽略多余进位的情况下，`2^n-x` 的结果跟 `~x + 1` 相同（可以证明的）。而 `~x + 1` 只有位运算和加法，完全没有减法。

证明：设某负数X，则X+X（反）= 0xFFFFFFFF，所以X+X（反）+1 = 0，可以得出 0 - X = X（反）+ 1

这里 **0 - X即定义为负数X的补码**，这样，计算机在进行X-Y运算时实际可用X+Y（补）代替，硬件角度只需实现加法电路即可。同样的道理，0-X（补）=X（补）（反）+1 = X，即已知负数补码只需对其各位取反加一即可得到原码。**补码的补码就是原码，就像负负得正一样**



### 为什么需要反码+1

区分+0和-0.

把0当成正数，也即+0，这样0的编码就变成：0_0000000。那8位二进制表示的正数范围仍然是： +0 —— +127。


