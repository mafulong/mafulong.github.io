```
layout: post
category: golang
title: golang语法
```

```go
package main

import (
	"fmt"
)

/*
变量
 */

func variable()  {
	//1. 指定类型
	// 有默认值
	var a int
	println(a)
	//也可以同时赋值
	var a1 bool=true
	println(a1)

	//2. 自动判断类型
	var b=3
	println(b)

	//3. 省略var
	c:=3
	println(c)
}

/*
常量
 */
 func constVariable(){
 	const a int=3;
	 //多类型简写
	 const c,d,e=1,false,4
	 //可以做枚举
	 const(
		h=1
		i=2
		j=3
		//如果不赋值，就是上一行的值
	 )


	 //itoa
	 //iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，
	 // const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。
	 const (
		 a1 = iota
		 b = iota
		 c1 = iota
	 )
	 //a1是0
 }

/*
运算符
 */

func operator()  {
	/*
	运算符没有三目运算符
	有赋值运算法及&& || ！
	有指针操作， & 及 *
	 */
}

/*
条件语句
 */
func ifStatement()  {
	//if
	if 3<4{
		println("3<4")
	}

	if(3<4){
		println("3<4")
	}
	if 3<4{
		println("3<4")
	}else if(4==4){
		println("4==4")
	}else{
		println("Jdd")
	}

	//switch
	/*
	switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，
	从上直下逐一测试，直到匹配为止。。

	switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break
	 */


	var grade string = "B"
	var marks int = 90

	switch marks {
	case 90: grade = "A"
	case 80: grade = "B"
	case 50,60,70 : grade = "C"
	default: grade = "D"
	}

	switch {
	case grade == "A" :
		fmt.Printf("优秀!\n" )
	case grade == "B", grade == "C" :
		fmt.Printf("良好\n" )
	case grade == "D" :
		fmt.Printf("及格\n" )
	case grade == "F":
		fmt.Printf("不及格\n" )
	default:
		fmt.Printf("差\n" );
	}
	//
	//switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。
	//
	//Type Switch 语法格式如下：

	//switch x.(type){
	//	case type:
	//	statement(s);
	//	case type:
	//	statement(s);
	//	/* 你可以定义任意个数的case */
	//	default: /* 可选 */
	//	statement(s);
	//}

	//select
	/*
	select是Go中的一个控制结构，
	类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。

	select随机执行一个可运行的case。如果没有case可运行，它将阻塞，
	直到有case可运行。一个默认的子句应该总是可运行的。
	 */

	var c1, c2, c3 chan int
	var i1, i2 int
	select {
	case i1 = <-c1:
		fmt.Printf("received ", i1, " from c1\n")
	case c2 <- i2:
		fmt.Printf("sent ", i2, " to c2\n")
	case i3, ok := (<-c3):  // same as: i3, ok := <-c3
		if ok {
			fmt.Printf("received ", i3, " from c3\n")
		} else {
			fmt.Printf("c3 is closed\n")
		}
	default:
		fmt.Printf("no communication\n")
	}//out: no communication

}

/*
循环语句
 */

func forStatement() {
	/*
	Go语言的For循环有3中形式，只有其中的一种使用分号。

	和 C 语言的 for 一样：

	for init; condition; post { }
	和 C 的 while 一样：

	for condition { }
	和 C 的 for(;;) 一样：

	for { }
	 */

	//for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：

	//for循环里的变量属于局部变量，与外界不冲突。。。就是for条件的那个位置


	/*
	和 C 的 while 一样：

	for condition { }
	 */
}


/*
函数
 */

func function()  {
	/*
	func function_name( [parameter list] ) [return_types] {
   		函数体
	}
	 */


	/*
	func swap(x, y string) (string, string) {
		return y, x
	}
	 */

	/*
   函数可作为变量
	*/
	//func f7(){
	//	/* 声明函数变量 */
	//	getSquareRoot := func(x float64) float64 {
	//		return math.Sqrt(x)
	//	}
	//
	//	/* 使用函数 */
	//	fmt.Println(getSquareRoot(9))
	//}

	/*
	闭包
	 */
	//func getSequence() func() int {
	//	i:=0
	//	return func() int {
	//		i+=1
	//		return i
	//	}
	//}
	///* nextNumber 为一个函数，函数 i 为 0 */
	//nextNumber := getSequence()
	//
	///* 调用 nextNumber 函数，i 变量自增 1 并返回 */
	//fmt.Println(nextNumber())
	//fmt.Println(nextNumber())
	//fmt.Println(nextNumber())

	/*
	方法
	 */
	///* 定义结构体 */
	//type Circle struct {
	//	radius float64
	//}
	////该 method 属于 Circle 类型对象中的方法
	//func (c Circle) getArea() float64 {
	//	//c.radius 即为 Circle 类型对象中的属性
	//	return 3.14 * c.radius * c.radius
	//}

}




/*
数组
 */
func array()  {
	/*
	var balance [10] float32
	var balance1 = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
	//如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：
	var balance2 = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//直接[]也行
	//多维数组
	var threedim [5][10][4]int
	var a = [3][4]int{
		{0, 1, 2, 3} ,
		{4, 5, 6, 7} ,
		{8, 9, 10, 11},
	}

	*/
	/* 未定义长度的数组只能传给不限制数组长度的函数 */
	/* 定义了长度的数组只能传给限制了相同数组长度的函数 */

}

/*
指针
 */

func pointer()  {
	var a int= 20   /* 声明实际变量 */
	var ip *int        /* 声明指针变量 */

	ip = &a  /* 指针变量的存储地址 */
	println(*ip)
	/*
	nil 指针也称为空指针。
	nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
	 */


	 //指针数组
	//var ptr [MAX]*int;

	//指向指针的指针
	//var pptr **int

	//指针作为函数参数
	/* 调用函数用于交换值
	* &a 指向 a 变量的地址
	* &b 指向 b 变量的地址
	*/
	//swap(&a, &b);
	//func swap(x *int, y *int) {}


}

/*
结构体
 */

func structStatement()  {
	/*
	type struct_variable_type struct {
	   member definition;
	   member definition;
	   ...
	   member definition;
	}
	 */

	//variable_name := structure_variable_type {value1, value2...valuen}
	//或
	//variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}

	//// 创建一个新的结构体
	//fmt.Println(Books{"Go 语言", "www.runoob.com", "Go 语言教程", 6495407})
	//
	//// 也可以使用 key => value 格式
	//fmt.Println(Books{title: "Go 语言", author: "www.runoob.com", subject: "Go 语言教程", book_id: 6495407})
	//
	//// 忽略的字段为 0 或 空
	//fmt.Println(Books{title: "Go 语言", author: "www.runoob.com"})

	//结构体作为函数参数
	//func printBook( book Books )

	//结构体指针
	//var struct_pointer *Books
	//使用结构体指针访问结构体成员，使用 "." 操作符：
	//struct_pointer.title;


}

/*
切片
 */
func slice()  {
	//使用结构体指针访问结构体成员，使用 "." 操作符：
	//struct_pointer.title;

	//var slice1 []type = make([]type, len)
	//
	//也可以简写为
	//
	//slice1 := make([]type, len)

	//make([]T, length, capacity)
	//s := arr[startIndex:endIndex]

	// var numbers = make([]int,3,5)

	//一个切片在未初始化之前默认为 nil，长度为 0，
	//var numbers []int

	numbers := []int{0,1,2,3,4,5,6,7,8}
	/* 打印原始切片 */
	fmt.Println("numbers ==", numbers)

	/* 打印子切片从索引1(包含) 到索引4(不包含)*/
	fmt.Println("numbers[1:4] ==", numbers[1:4])

	//append() 和 copy() 函数

	/* 同时添加多个元素 */
	numbers = append(numbers, 2,3,4)

	/* 创建切片 numbers1 是之前切片的两倍容量*/
	numbers1 := make([]int, len(numbers), (cap(numbers))*2)

	/* 拷贝 numbers 的内容到 numbers1 */
	copy(numbers1,numbers)

}

/*
范围 range
 */

func rangeStatement()  {
	/*
	 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。
	在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key及value 值。
	 */

	//这是我们使用range去求一个slice的和。使用数组跟这个很类似
	nums := []int{2, 3, 4}
	sum := 0
	for _, num := range nums {
		sum += num
	}


}

/*
map
 */
func mapStatement()  {
	/* 声明变量，默认 map 是 nil */
	//var map_variable map[key_data_type]value_data_type
	//nil map 不能用来存放键值对

	/* 使用 make 函数 */
	//map_variable := make(map[key_data_type]value_data_type)

	/* 创建map */
	//countryCapitalMap := map[string]string{"France": "Paris",
	// "Italy": "Rome", "Japan": "Tokyo", "India": "New delhi"}


	var countryCapitalMap map[string]string /*创建集合 */
	countryCapitalMap = make(map[string]string)

	/* map插入key - value对,各个国家对应的首都 */
	countryCapitalMap [ "France" ] = "Paris"
	countryCapitalMap [ "Italy" ] = "罗马"

	/*查看元素在集合中是否存在 */
	captial, ok := countryCapitalMap [ "美国" ] /*如果确定是真实的,则存在,否则不存在 */
	/*fmt.Println(captial) */
	/*fmt.Println(ok) */
	if (ok) {
		fmt.Println("美国的首都是", captial)
	} else {
		fmt.Println("美国的首都不存在")
	}

	/*删除元素*/
	delete(countryCapitalMap, "France")
}

/*
接口 interface
 */
func interfaceStatement()  {
	/*
		type Phone interface {
		call()
	}

	type NokiaPhone struct {
	}

	func (nokiaPhone NokiaPhone) call() {
		fmt.Println("I am Nokia, I can call you!")
	}

	type IPhone struct {
	}

	func (iPhone IPhone) call() {
		fmt.Println("I am iPhone, I can call you!")
	}

	func main() {
		var phone Phone

		phone = new(NokiaPhone)
		phone.call()

		phone = new(IPhone)
		phone.call()

	}
	 */
}

/*
错误处理
 */

func errorHandle()  {
	/*
	error类型是一个接口类型，这是它的定义：

		type error interface {
			Error() string
		}
	 */

/*
	// 定义一个 DivideError 结构
	type DivideError struct {
		dividee int
		divider int
	}

	// 实现 `error` 接口
	func (de *DivideError) Error() string {
		strFormat := `
		Cannot proceed, the divider is zero.
		dividee: %d
		divider: 0
	`
		return fmt.Sprintf(strFormat, de.dividee)
	}

	// 定义 `int` 类型除法运算的函数
	func Divide(varDividee int, varDivider int) (result int, errorMsg string) {
		if varDivider == 0 {
			dData := DivideError{
				dividee: varDividee,
				divider: varDivider,
			}
			errorMsg = dData.Error()
			return
		} else {
			return varDividee / varDivider, ""
		}

	}

 */
}
func main() {

}
```
