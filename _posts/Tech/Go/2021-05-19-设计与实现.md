---
layout: post
category: Go
title: 设计与实现
tags: Go
---

## 设计与实现

## 基础知识

### 切片

```
make([]int64, 0, 10) // cap10, len0
make([]int64, 10) // cap10, len 10, 少用
```

结构:

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

扩容策略

- cap<1024，每次*2
- cap>1024，每次*1.25
- 然后会字节对齐。
- 如果没发生扩容，修改在原来内存，
- 发生了扩容，修改在新内存，尤其注意当slice作为函数参会后，函数内部发生扩容并不会影响之前的了。

### map

[直接看另一篇文档](https://mafulong.top/2019/09/11/golang%E7%9A%84map%E7%9A%84%E5%AE%9E%E7%8E%B0/)

```go
struct Hmap
{
    uint8   B;    // 可以容纳2^B个项
    uint16  bucketsize;   // 每个桶的大小

    byte    *buckets;     // 2^B个Buckets的数组
    byte    *oldbuckets;  // 前一个buckets，只有当正在扩容时才不为空
};

```

这个hash结构使用的是一个可扩展哈希的算法，由hash值mod当前hash表大小决定某一个值属于哪个桶，而hash表大小是2的指数，即上面结构体中的2^B。每次扩容，会增大到上次大小的两倍。结构体中有一个buckets和一个oldbuckets是用来实现增量扩容的。正常情况下直接使用buckets，而oldbuckets为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。

- map存的是指针，不可以取址，扩容时会发生变化。
- 不会缩容。