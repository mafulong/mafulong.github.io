---
layout: post
category: Go
title: go之QA
tags: Go
---

## go之QA

### Go语言函数传参是值类型还是引用类型？

- 在Go语言中只存在值传递，要么是值的副本，要么是指针的副本。无论是值类型的变量还是引用类型的变量亦或是指针类型的变量作为参数传递都会发生值拷贝，开辟新的内存空间。
- 另外值传递、引用传递和值类型、引用类型是两个不同的概念，不要混淆了。引用类型作为变量传递可以影响到函数外部是因为发生值拷贝后新旧变量指向了相同的内存地址。

为啥说go不是引用传递，如果形参和实验地址一样的，那是引用传递，但事实不是，因此和c+不通。c+ 传递的引用其实就是指针的拷贝，而 go 传递的是指针上层结构体的拷贝。

### Go语言中的内存对齐了解吗？

CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。

CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数，例如：

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220424103153.awebp)

变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。

也可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。

简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。

### 两个 interface 可以比较吗？

- 判断类型是否一样

```
reflect.TypeOf(a).Kind() == reflect.TypeOf(b).Kind()
```

- 判断两个interface{}是否相等

```
reflect.DeepEqual(a, b interface{})
```





其他：将一个interface{}赋值给另一个interface{}

```
reflect.ValueOf(a).Elem().Set(reflect.ValueOf(b))
```



### go 打印时 %v %+v %#v 的区别？

- %v 只输出所有的值；
- %+v 先输出字段名字，再输出该字段的值；
- %#v 先输出结构体名字值，再输出结构体（字段名字+字段的值）；

```go
package main
import "fmt"
 
type student struct {
	id   int32
	name string
}
 
func main() {
	a := &student{id: 1, name: "微客鸟窝"}

	fmt.Printf("a=%v	\n", a) // a=&{1 微客鸟窝}	
	fmt.Printf("a=%+v	\n", a) // a=&{id:1 name:微客鸟窝}	
	fmt.Printf("a=%#v	\n", a) // a=&main.student{id:1, name:"微客鸟窝"}
}
```

### 空 struct{} 占用空间么？

可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数:

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println(unsafe.Sizeof(struct{}{}))  //0
}
复制代码
```

空结构体 struct{} 实例不占据任何的内存空间。



### 空 struct{} 的用途？

因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。

1. 将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。不发送数据的信道(channel)

2. 使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。

### **逃逸分析**

[面试官问我go逃逸场景有哪些，我？？？](https://mp.weixin.qq.com/s?__biz=Mzk0NzI3Mjk1Mg==&mid=2247484908&idx=1&sn=ee3aa086f8f808aa56c77bccdadea261&scene=21#wechat_redirect)

「逃逸分析」就是程序运行时内存的分配位置(栈或堆)，是由编译器来确定的。堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。

逃逸场景：

- 指针逃逸 返回局部变量指针
- 栈空间不足逃逸
- 动态类型逃逸 函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。
- 闭包引用对象逃逸

小结：

- 栈上分配内存比在堆中分配内存效率更高
- 栈上分配的内存不需要 GC 处理，而堆需要
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成

### **golang中new和make的区别？**

[用new还是make？到底该如何选择？](https://mp.weixin.qq.com/s?__biz=Mzk0NzI3Mjk1Mg==&mid=2247484513&idx=1&sn=e9f8be7ab5b99fc9eac1ee9b548df3f5&scene=21#wechat_redirect)

- make 仅用来分配及初始化类型为 slice、map、chan 的数据。
- new 可分配任意类型的数据，根据传入的类型申请一块内存，返回指向这块内存的指针，即类型 *Type。
- make 返回引用，即 Type，new 分配的空间被清零， make 分配空间后，会进行初始。



### for range读channel

`for range` 可以遍历通道（ `channel` ），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。

### Context

有几个方法创建Context:

- `WithCancel`、`WithTimeout`、`WithDeadline`：传入一个父的`Context`类型值，返回一个新的可取消的`Context`和用于取消该返回`Context`的函数，同时保证父`Context`取消后该子`Context`也会被取消。`WithTimeout`、`WithDeadline`： 内部存在了一个定时器，到时间点后会自动帮我们调用取消函数。

有哪些方法：

```go
type Context interface {
        Deadline() (deadline time.Time, ok bool)
        Done() <-chan struct{}
        Err() error
        Value(key interface{}) interface{}
}
```

- `Deadline`：获取是否设置了到期时间以及所设置的截止时间。如果有设置过期时间的话，`Context`会到那个时间点时自动发起取消`Context`的操作。
- `Done`：返回一个通道，如果通道关闭则代表该`Context`已经被取消；如果返回的为`nil`，则代表该`Context`是一个永远不会被取消的`Context`。
- `Err`：返回该`Context`被取消的原因，如果只使用`Context`包的`Context`类型的话，那么只可能返回`Canceled`（代表被明确取消）或者`DeadlineExceeded`（因超时而取消）
- `Value`：你可能经常看到代码中使用该函数从`ctx`中获取一个`string key`中的值，即一个`Context`内部是可以携带很多kv的, 关于如何存储，可以想象成一个树中的某个节点，每个节点保存了指向父节点的指针，从当前的节点一层层向根节点寻找



如果我们把一个网络请求的处理看做是一个任务的话，使用`Context`帮助我们在子任务树中传递取消任务的信号，并可以根据`WithXXX`生成新的子`Context`传递到下游子任务中，整体呈现出一个树状结构。上层`Context`被取消后会沿着树向下递归的告知所衍生的所有`Context`该任务被取消。相反的，子`Context`被取消并不会影响到其父`Context`是否被取消。另外，`Context`还可以携带`kv`在任务中传递。

<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv3/v3/20220424202538.png" alt="img" style="zoom: 67%;" />



- 当超时或者取消时：会递归取消每个child，向下传入，但不会向上传递。实现上是parent记录了children集合。

- context是并发安全的

- 在 Go 的 `context.Context` 中，键值对（KV）是**向上查找的**。

  当你通过 `ctx.Value(key)` 检索值时，Go 的 `context` 包会按照上下文的层级从**当前上下文**向其**父上下文**逐级查找，直到找到对应的键。如果层级较深，查找的性能可能会受到影响。

- context.TODO() 返回一个空的 context，常用于重构时期，没有合适的 context 可用。 todo 通常用在并不知道传递什么 context的情形。例如，调用一个需要传递 context 参数的函数，你手头并没有其他 context 可以传递，这时就可以传递 todo。



```go
type cancelCtx struct {
    Context
    // 保护之后的字段
    mu       sync.Mutex
    done     chan struct{}
    children map[canceler]struct{}
    err      error
}
```



### 自定义M/P/G上限数量？

M默认limit 10000 可自定义，但一般不需要。

P就是GOMAXPROCS, 可自定义，默认cpu核数

G数量，无限制。不可自定义。但受内存影响，可监控。

### go性能工具

Go 语言提供了多种 **性能分析工具（Profiling Tools）**，用于检测 CPU、内存、协程等资源的使用情况，帮助优化程序性能。

1. **pprof（Performance Profiler）**
   - Go 内置的性能分析工具，可用于 **CPU、内存、Goroutine、Block** 等分析。
   - **使用方式**：
     ```go
     import _ "net/http/pprof"
     go func() {
         log.Println(http.ListenAndServe("localhost:6060", nil))
     }()
     ```
   - 访问方式：
     - `go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30`（CPU Profile）
     - `go tool pprof http://localhost:6060/debug/pprof/heap`（Heap Profile）
   - 可以使用 `pprof -http=:8081` 生成可视化分析结果。

2. **trace（Go 运行时跟踪分析）**
   - `go test -trace trace.out` 生成 **Go 执行流程跟踪日志**。
   - 使用 `go tool trace trace.out` 进行可视化分析。
   - 适用于分析 **Goroutine 调度、系统调用、垃圾回收等** 问题。

3. **race（数据竞争检测）**
   - `go run -race main.go` 运行程序时检测 **数据竞争（Data Race）** 问题。
   - `go test -race` 测试代码时检测并发访问问题。

4. **benchmark（性能基准测试）**
   - `go test -bench` 运行基准测试：
     ```go
     func BenchmarkExample(b *testing.B) {
         for i := 0; i < b.N; i++ {
             someFunction()
         }
     }
     ```
   - 使用 `-benchmem` 统计内存分配情况。

5. **delve（Go 调试工具）**
   - `dlv debug ./main` 运行调试模式，可用于 **断点调试、内存查看、性能分析**。
   - `dlv trace` 进行系统调用跟踪。

6. **perf（Linux 性能分析）**
   - `perf record -g ./program` 记录 Go 进程的 **CPU 使用情况**。
   - `perf report` 分析性能热点。

7. **flamegraph（火焰图）**
   - `go tool pprof -http=:8080 cpu.prof` 可生成 **火焰图（Flame Graph）**，可视化查看热点函数。
   - 也可以结合 `Flamegraph` 工具（`https://github.com/brendangregg/FlameGraph`）分析 `perf` 采样数据。

8. **go-metrics（第三方监控工具）**
   - **prometheus+grafana** 结合 `expvar` 进行监控。
   - `uber-go/tally` 进行统计分析。

**总结**
- **pprof**：最常用，支持 **CPU、内存、协程、锁分析**。
- **trace**：分析 **Goroutine 调度、系统调用**，适用于性能调优。
- **race**：检测 **数据竞争**，适用于并发程序。
- **benchmark**：基准测试，评估函数执行效率。
- **delve**：Go 调试，支持断点调试、变量查看。
- **perf + flamegraph**：深入分析 **Linux 内核级性能瓶颈**。

综合使用这些工具，可以全面优化 Go 程序的性能。

### 杂

- Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。包括float

## 接口和C++的区别

C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。

C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 `itab` 中的 `fun` 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 `itab` 中的 `fun` 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 `itab`， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。

## unsafe

- Go 的指针不能进行数学运算
- Go 的指针不能进行数学运算
- 不同类型的指针不能使用 == 或 != 比较

## 版本更新

在 Go 1.22 中，`for` 循环中的迭代变量会被重新分配，每次循环迭代中都会创建一个新的变量。这种改动确保了闭包捕获的是**每次迭代中独立的变量副本**。



todo

## go内存分配



Go语言的内存分配算法主要依赖于**tcmalloc**的思想，并针对自身需求进行了优化

`tcmalloc`（Thread-Caching Malloc）是 Google 开发的一种高效的内存分配器，其核心思想是通过减少线程间的锁争用和优化内存分配的碎片管理，来提升多线程环境下的内存分配性能。以下是其关键设计思想和机制：

------

1. **线程本地缓存**

`tcmalloc` 的核心特点是为每个线程维护一个本地缓存（Thread Local Cache, TCache），用于管理小对象的分配和释放。

- **避免全局锁竞争**：线程在分配和释放内存时，优先从本地缓存中获取或释放，减少了访问全局堆的频率，降低了线程间的锁争用。
- **快速分配和释放**：本地缓存通过简单的数据结构（如链表或数组）管理内存块，操作非常高效。

------

2. **按大小分类的内存管理**

`tcmalloc` 将内存块分为多个**大小类别（Size Classes）**，并针对每个类别单独管理。

- **小对象**：小于某个阈值的对象（通常为32KB以下）分配到线程本地缓存，并按固定大小的块管理。
- **大对象**：大于阈值的对象直接从全局堆中分配，通常使用分页或直接映射（mmap）。
- **对齐优化**：内存块大小通常是固定的对齐单位（如8字节）的倍数，减少内存碎片并提高访问效率。

------

3. **页级管理**

`tcmalloc` 将内存划分为**页（Page）**，每页大小通常为 4KB 或 8KB，作为内存分配的基本单位。

- **Span**：多个连续的页组成一个 `Span`，用于管理同一大小类别的内存块。
- **Span 分配与回收**：当线程本地缓存需要新内存时，从全局堆中获取一个 `Span`；释放内存时，空闲的 `Span` 会被合并并归还到全局堆中。

------

4. **内存回收与共享**

`tcmalloc` 实现了高效的内存回收机制，以平衡线程本地缓存与全局堆之间的内存使用。

- **缓存溢出**：当线程本地缓存中的内存超出一定阈值时，部分空闲块会被归还到全局堆。
- **全局共享**：当某个线程需要分配内存且本地缓存不足时，可以从全局堆获取所需的 `Span`。

------

5. **内存碎片优化**

`tcmalloc` 的设计尽量减少内存碎片，通过以下策略实现：

- **固定大小类别**：通过分类管理，减少小对象分配带来的碎片。
- **内存合并**：回收空闲 `Span` 时，尝试合并相邻的页。
- **延迟释放**：小对象的内存释放延迟归还到全局堆，提高内存重用率。

------

6. **线程安全与并发优化**

`tcmalloc` 使用细粒度锁或无锁算法（如原子操作）来管理全局堆，保证线程安全的同时尽量减少锁的开销。

------

总结

`tcmalloc` 的主要思想是**“线程本地缓存 + 按大小分类管理 + 高效的内存回收”**，通过分层的内存分配与回收机制，提升了多线程环境下的性能，同时减少了内存碎片。





