---
layout: post
category: Mysql
title: mysql原理-锁
tags: Mysql
---

## mysql原理-锁



> [参考](https://learnku.com/articles/39212?order_by=vote_count&)

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/Zu4vlv7L2S.png!large)

## 锁原理-考点

mysql的锁类型，一般其实就是表锁、行锁和页锁。

一般myisam会加表锁，就是myisam引擎下，执行查询的时候，会默认加个表共享锁，也就是表读锁，这个时候别人只能来查，不能写数据的；然后myisam写的时候，也会加个表独占锁，也就是表写锁，别人不能读也不能写。

myisam其实在实际生产中，就是在报表系统里用的是最多的，当年es和kylin没出来的时候，大数据系统计算好的报表数据，都是放mysql的myisam里的，一般就是每天凌晨导入一批数据，那个时候别人不需要查询，没人凌晨来看报表；然后白天也没有写入，就是别人纯查询，建好索引，查询性能还是不错的，单表支撑千万级别数据没问题。



innodb引擎一般用行锁，但是也有表锁。

innodb的行锁有共享锁（S）和排他锁（X），两种，共享锁就是，多个事务都可以加共享锁读同一行数据，但是别的事务不能写这行数据；排他锁就是，就一个事务可以写这行数据，别的事务只能读，不能写。

innodb的表锁，分成意向共享锁，就是说加共享行锁的时候，必须先加这个共享表锁；还有一个意向排他锁，就是说，给某行加排他锁的时候，必须先给表加排他锁。这个表锁，是innodb引擎自动加的，不用你自己去加(主要是为了判断锁是否冲突了，如果冲突了就等待，不冲突就加上共享锁或者排他锁)

insert、update、delete，innodb会自动给那一行加行级排他锁。

select，innodb啥锁都不加，因为innodb默认实现了可重复读，也就是mvcc机制，所以多个事务随便读一个数据，一般不会有冲突，大家就读自己那个快照就可以了，不涉及到什么锁的问题。

但是innodb从来不会自己主动加个共享锁的，除非你用下面的语句自己手动加个锁：

主动加共享锁：select * from table where id=1 lock in share mode，那你就给那一行加了个共享锁，其他事务就不能来修改这行数据了。

主动加排他锁：select * from table where id=1 for update，那你就给那一行加了个排他锁，意思就是你准备修改，别的事务就别修改了，别的事务的修改会hang住。这个要慎用，一般线上系统不用这个，容易搞出问题来。

对一行数据，如果有人在修改，会加个排他锁，然后你不能修改，你只能等着获取这把锁，但是这个时候你可以随便select，你就是查询你的事务开始之前那行数据的某个版本而已。然后如果你修改某行数据，会同时拿这个表的排他锁，但是呢，如果不同的事务修改不同的行，会拿不同行的行级排他锁，但是大家都会拿一个表的排他锁，ok，实际上innodb的表级排他锁可以随便拿，这个是没冲突的。

所以这个就是mysql innodb存储引擎的默认锁模式。相当于就是一行数据，同一个时刻只能一个人在修改，但是别人修改，你可以随便读，读是读某个版本的，走mvcc机制。



在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。



## 通过锁实现隔离级别

注意是用锁实现隔离级别，实际上是通过mvcc以及间隙锁实现的。

- 在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

- 在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

- 在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

- SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

## InnoDB存储引擎的锁的算法有三种

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包含记录本身

相关知识点：

- innodb对于行的查询使用next-key lock
- Next-locking keying为了解决Phantom Problem幻读问题
- 当查询的索引含有唯一属性时，将next-key lock降级为record key
- Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

 

要禁止间隙锁的话，可以A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

## 快照读和当前读

### 快照读

**快照读也叫非阻塞读，即所谓快照读就是不加锁的非阻塞读，就是我们最简单的 `select`操作**

当然了，这里不加锁的非阻塞读是以事务隔离级别不为最高级别的前提下成立，因为在最高隔离级别下，快照读也会变成当前读，在其后自动加`lock in share mode`

### 当前读

**诸如`select ... lock in share mode`、`select ... for update`、`update`、`delete`、`insert`均为当前读；当前读本质上是加了锁的增删该查语句，无论上的是共享锁还是排他锁均为当前读.**

当前读会读最新版本，如果有正在加锁的事务，会等待锁释放才进行。

 这些语句被称为当前读的根本原因是因为它读取的是记录的最新版本，并且在读取之后，还需保证其他事务不能修改当前记录，对读取的记录加锁；上面的除 select 语句加的是共享锁外，其他的都是排他锁，那为什么 `update`、`delete`、`insert`也被称为当前读呢？
 我们都知道 [RSBMS](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F11032386%3Ffromtitle%3DRDBMS%26fromid%3D1048260) 主要由两大部分组成，一部分是程序实例（即 MySQL 实例），另一部分是存储（即 InnoDB），
 我们在执行 `update`语句更新某几行数据时，每次都需要先读取相应数据行，然后在更新，这个时候在读取的时候需要读取最新行，所以需要使用当前读

### 实现原理

**之所以出现快照读，是基于提升并发访问性能考虑的；快照读的实现是基于多版本的并发控制，即 MVCC，可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁的操作，因此开销更低.**
 **既然基于多版本实现，那么快照读有可能读到的并不是数据的最新版本，可能是之前的历史版本。**



在RR级别下，快照读是通过MVCC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。

当前读这种情况下都会开启间隙锁。间隙锁不分共享锁和排它锁。

MVCC只在读提交可重复读两种隔离级别下工作

## 意向锁

首先意向锁是表级别的锁，是InnoDB存储引擎自己维护的，用户无法手动添加意向锁。

当我们要对某个page中的一行记录进行锁定时，需要对上层的table加意向锁——IS/IX，意为该事务中有意向对表中的某些行加X、S锁。

主要是方便检查 表级别锁和行级别锁的冲突



**IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突**

再来回答意向锁的作用。意向锁是在添加行锁之前添加。

当再向一个表添加表级X锁的时候

- 如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突
- 如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果

意向锁间相互兼容，对行级锁不生效，

> **注意：这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！！**

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/v2-0ebbe61fff8f30e6af794d49ea752c13_1440w.jpg)



## InnoDB 行锁实现方式：

**行锁是加在索引上的**

**Innodb中的索引数据结构是 B+ 树，数据是有序排列的，从根节点到叶子节点一层层找到对应的数据**。

普通索引，也叫做辅助索引，叶子节点存放的是主键值。主键上的索引叫做聚集索引，表里的每一条记录都存放在主键的叶子节点上。当通过辅助索引select 查询数据的时候，会先在辅助索引中找到对应的主键值，然后用主键值在聚集索引中找到该条记录。

举个例子，用name=Alice来查询的时候，会先找到对应的主键值是18 ，然后用18在下面的聚集索引中找到name=Alice的记录内容是 77 和 Alice。

**表中每一行的数据，是组织存放在聚集索引中的，所以叫做索引组织表**。

- **InnoDB 行锁是通过给索引上的索引项加锁来实现的**，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！也就是说加锁读的时候，没有命中索引的话就全锁了**
- **不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁**。
- **只有执行计划真正使用了索引，才能使用行锁**：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：[MySQL索引总结](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/h4B84UmzAUJ81iBY_FXNOg)）
- **由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的**（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。

##### select * from user where name=‘b’ for update

这里的name上加了唯一索引，唯一索引本质上是辅助索引，加了唯一约束。所以会先在辅助索引上找到name为d的索引记录，在辅助索引中加锁，然后查找聚集索引，锁住对应索引记录。

##### 为什么聚簇索引上的记录也要加锁？

试想一下，如果有并发的另外一个SQL，是直接通过主键索引id=30来更新，会先在聚集索引中请求加锁。如果只在辅助索引中加锁的话，两个并发SQL之间是互相感知不到的。

<img src="https://user-gold-cdn.xitu.io/2019/10/20/16de975b6f1f9fc9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 50%;" />

<img src="https://user-gold-cdn.xitu.io/2019/10/20/16de975b76e40bd1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" />

## 锁优化原则

因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。RR下

加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。

原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。

原则 2：查找过程中访问到的对象才会加锁。

优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。



## 死锁

事务A：

select * from table where id=1 for update

事务B：

select * from table where id=2 for update

事务A：

select * from table where id=2 for update

事务B：

select * from table where id=1 for update

常见的死锁就是类似上面那种，分别都持有一个锁，结果还去请求别人持有的那把锁，结果就是谁也出不来，死锁了。

