---
layout: post
category: Mysql
title: mysql原理-各个日志
tags: Mysql
---

## mysql原理-各个日志

> [参考](https://juejin.cn/post/6844904086358196237)

- redolog：
     上面描述的查询的过程，如果要更新的话，那么肯定要先找到需要更新的记录，那么如果每次都是查出来在内存中进行更改，然后立刻同步到磁盘的话，其实会降低执行的效率，需要等待IO；如果直接再内存中先更改数据，然后写入redolog的日志文件中，然后等到后面再去同步磁盘，会提高执行的效率。redolog其实是类似于一个环形队列的概念，是可以重复利用的。像下面这个图，绿色的部分就是可以写入区的大小，如果写满了，那么这个时候就需要根据redolog，将内存中的数据，同步到磁盘里面去，这样才可以继续利用redolog记录数据变更。redolog其实记录的是针对具体数据页的操作，而不是记录的执行的sql。这个其实就是WAL（write-ahead logging）技术，innodb的redolog是固定大小的，比如可一个配置4个日志文件，一个日志文件大小设置为1GB，那么整体就可以容纳4个GB的数据写入。有时数据库的抖动（sql比平时执行的慢），就有可能是redolog已经写满，从而进行内存数据的脏页写入磁盘的过程导致的。redolog是重做日志，提供前滚操作。这句话的意思其实是说可以通过redolog来恢复磁盘数据，保证数据的crash-safe能力。直接从物理层面恢复数据，而不是binlog通过记录sql，重新运行sql来进行的数据恢复。

    ![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/1-20210106172415686)

    

    > - InnoDB 有 buffer pool（简称bp）。bp 是 物理页 的缓存，对 InnoDB 的任何修改操作都会首先在 bp 的 page 上进行，然后这样的页面将被标记为 dirty 并被放到专门的flush list 上，后续将由专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机 IO，阶段性的刷脏可以将多次对页面的修改 merge 成一次IO 操作，同时异步写入也降低了访问的时延。

    > - 然而，如果在 dirty page 还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb 将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是 redo log file。这样的技术推迟了 bp 页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销（顺序 IO，比随机 IO 快很多），以及数据库启动时恢复操作所需的时间。

- undolog：
   和redolog一样其实也是存储引擎层维护的，undolog是回退日志，提供回滚操作。undo log 用来回滚行记录到某个版本。undo log 一般是逻辑日志，根据每行记录进行记录。保证事务的原子性，innodb使用它来实现MVCC.Undo 记录某 数据 被修改 前 的值，可以用来在事务失败时进行 rollback。Redo 记录某 数据块 被修改 后 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。

  - Redo Log 保证事务的持久性
  - Undo Log 保证事务的原子性

  > 比如某一时刻数据库DOWN机了，有两个事务，一个事务已经提交，另一个事务正在处理。数据库重启的时候就要根据日志进行前滚及回滚，把已提交事务的更改写到数据文件，未提交事务的更改恢复到事务开始前的状态。即，当数据库 crash-recovery 时，通过 redo log将所有已经在存储引擎内部提交的事务应用 redo log 恢复，所有已经 prepared 但是没有 commit 的 transactions 将会应用 undo log 做 roll back。

  为什么不能只用redolog或者undolog？

  - 假设只有 undo-log：那么就必须保证提交前刷脏完成，否则宕机时有些修改就在内存中丢失了，破坏了持久性。（这样带来了一个问题，那就是前面提到的性能差）
  - 假设只有 redo-log：那么就不能随心所欲地在事务提交前刷脏，即无法支持大事务。（假如、某张表有 100 亿的 8 字节整数数据，就算不考虑其他东西带来的损耗，光 update 整张表至少要消耗 80G 的内存。如前所述，有了 undo-log，就可以随便刷脏。）

- binlog：
   binlog 是 mysql server 层维护的，跟采用何种引擎没有关系，记录的是所有引擎的更新操作的日志记录。最开始没有第三方存储引擎开发的时候其实mysql只有binglog，这个历史原因导致了binlog其实只是逻辑层面的。redo/undo 记录的是 每个页/每个数据 的修改情况，属于物理日志+逻辑日志结合的方式（redo log 是物理日志，undo log 是逻辑日志）。binlog 记录的都是事务操作内容，binlog 有三种模式：Statement（基于 SQL 语句的复制）、Row（基于行的复制） 以及 Mixed（混合模式）。不管采用的是什么模式，当然格式是二进制的。redo/undo 在 事务执行过程中 会不断的写入，而 binlog 是在 事务最终提交前 写入的。也就是二阶段提交。

   了解了各个日志大概是干什么的 下面说说update流程:



![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic/typora/1)



```
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。
复制代码
```

为什么需要binlog和redolog的两阶段提交？

> 假如中午十二点误删了一个表，假如前一天备份了全量库，那么可以现在测试环境恢复备份库，然后把生产的binlog拿下来，重放到十二点的状态，然后再把这个库同步到线上就完成了。假如binlog不一致，binlog比redolog超前，那么其实相当于多运行了一个sql，如果redolog比binglog超前，那么其实相当于少运行了一个sql，因为redolog在物理层面上已经进行数据页的更新，所以需要进行二阶段提交保证数据的一致性。




