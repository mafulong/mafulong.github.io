---
layout: post
category: Mysql
title: mysql原理4-日志系统
tags: Mysql
---

## mysql原理-日志系统

> [参考](https://juejin.cn/post/6844904086358196237)

![](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/126.png)

事务提交流程：

- 从磁盘加载书到buffer pool(change buffer)
- 写undo日志到log buffer，写入数据的旧值，便于回滚
- 准备阶段，sql成功执行，更新内存数据，生成xid、redolog、undolog，调用prepare，将事务标记为trx_started，**将redo log写盘**，这里由innodb_flush_log_at_trx_commited参数控制。
- 提交阶段，引擎执行prepare成功后，开始写binlog到file cache
- 调用fsync，将binlog从file cache写到磁盘，这是由**sync_binlog**参数控制的
- 通知引擎commit，引擎提交后会清除undolog，并再次将redo log写盘，标记事务为trx_not_started，由后台线程持久化

**注意undo log不需要2pc。**



redo log和binlog两者是2PC控制的，先redo log prepare，再更新binlog，然后redo log commit并进行持久化。



## 各个log的作用

### 1：重做日志（redo log）

**作用：**确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
 **产生与释放：**事务开始之后就产生redo log；当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了。

### 2：回滚日志（undo log）

**作用：**保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚。
 **产生与释放：**事务开始之前，将当前版本生成undo log；当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，最后决定是否可以清理undo log的日志空间。

### 3：二进制日志（binlog）

**作用：**在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。
 **产生与释放：**事务提交的时候，一次性将事务中的sql语句按照一定的格式记录到binlog中；超过配置的天数之后会被自动删除(默认永久不删除

## redo log (InnoDB特有)

和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。

具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

如果要更新的话，那么肯定要先找到需要更新的记录，那么如果每次都是查出来在内存中进行更改，然后立刻同步到磁盘的话，其实会降低执行的效率，需要等待IO；如果直接再内存中先更改数据，然后写入redolog的日志文件中，然后等到后面再去同步磁盘，会提高执行的效率。

> redolog其实是类似于一个环形队列的概念，是可以重复利用的。像下面这个图，绿色的部分就是可以写入区的大小，如果写满了，那么这个时候就需要根据redolog，将内存中的数据，同步到磁盘里面去，这样才可以继续利用redolog记录数据变更。redolog其实记录的是针对具体数据页的操作，而不是记录的执行的sql。这个其实就是WAL（write-ahead logging）技术，innodb的redolog是固定大小的，比如可一个配置4个日志文件，一个日志文件大小设置为1GB，那么整体就可以容纳4个GB的数据写入。有时数据库的抖动（sql比平时执行的慢），就有可能是redolog已经写满，从而进行内存数据的脏页写入磁盘的过程导致的。redolog是重做日志，提供前滚操作。这句话的意思其实是说可以通过redolog来恢复磁盘数据，保证数据的crash-safe能力。直接从物理层面恢复数据，而不是binlog通过记录sql，重新运行sql来进行的数据恢复。

![img](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/106.png)



> - InnoDB 有 buffer pool（简称bp）。bp 是 物理页 的缓存，对 InnoDB 的任何修改操作都会首先在 bp 的 page 上进行，然后这样的页面将被标记为 dirty 并被放到专门的flush list 上，后续将由专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机 IO，阶段性的刷脏可以将多次对页面的修改 merge 成一次IO 操作，同时异步写入也降低了访问的时延。

> - 然而，如果在 dirty page 还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb 将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是 redo log file。这样的技术推迟了 bp 页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销（顺序 IO，比随机 IO 快很多），以及数据库启动时恢复操作所需的时间。



## chang buffer和redo logo区别

如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。

 

chang buffer: 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

change buffer注意:

1、唯一索引不会用到 change buffer，插入值时，会查询数据是否唯一，也就没有必要用change buffer，所以唯一索引一定意义上会影响性能(如果buffer pool上有数据)

2、适合写多读少的场景



### 插入一条数据的过程

> [参考](https://blog.csdn.net/Kindle_code/article/details/107761447)

插入一条数据: insert into t(id,k) values(id1,k1),(id2,k2);
假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中

> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/10.png)
> 分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。
> 这条更新语句做了如下的操作（按照图中的数字顺序）：
> 1、Page 1 在内存中，直接更新内存。
> 2、Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息。
> 3、将上述两个动作记入 redo log 中（图中 3 和 4）。
> 做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。

 

### 查询一条语句的过程

> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/189.png)
> 1、读 Page 1 的时候，直接从内存返回。WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用的。你可以看一下图 3 的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。
> 2、要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。
> 可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。
> 所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。

## undolog

undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为<T1, X, 5>，Redo日志为<T1, X, 15>。



和redolog一样其实也是存储引擎层维护的，undolog是回退日志，提供回滚操作。undo log 用来回滚行记录到某个版本。undo log 一般是逻辑日志，根据每行记录进行记录。保证事务的原子性，innodb使用它来实现MVCC.Undo 记录某 数据 被修改 前 的值，可以用来在事务失败时进行 rollback。Redo 记录某 数据块 被修改 后 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。

- Redo Log 保证事务的持久性
- Undo Log 保证事务的原子性

> 比如某一时刻数据库DOWN机了，有两个事务，一个事务已经提交，另一个事务正在处理。数据库重启的时候就要根据日志进行前滚及回滚，把已提交事务的更改写到数据文件，未提交事务的更改恢复到事务开始前的状态。即，当数据库 crash-recovery 时，通过 redo log将所有已经在存储引擎内部提交的事务应用 redo log 恢复，所有已经 prepared 但是没有 commit 的 transactions 将会应用 undo log 做 roll back。

为什么不能只用redolog或者undolog？

- 假设只有 undo-log：那么就必须保证提交前刷脏完成，否则宕机时有些修改就在内存中丢失了，破坏了持久性。（这样带来了一个问题，那就是前面提到的性能差）
- 假设只有 redo-log：那么就不能随心所欲地在事务提交前刷脏，即无法支持大事务。（假如、某张表有 100 亿的 8 字节整数数据，就算不考虑其他东西带来的损耗，光 update 整张表至少要消耗 80G 的内存。如前所述，有了 undo-log，就可以随便刷脏。）

## binlog

binlog 是 mysql server 层维护的，跟采用何种引擎没有关系，记录的是所有引擎的更新操作的日志记录。最开始没有第三方存储引擎开发的时候其实mysql只有binglog，这个历史原因导致了binlog其实只是逻辑层面的。redo/undo 记录的是 每个页/每个数据 的修改情况，属于物理日志+逻辑日志结合的方式（redo log 是物理日志，undo log 是逻辑日志）。binlog 记录的都是事务操作内容，binlog 有三种模式：Statement（基于 SQL 语句的复制）、Row（基于行的复制） 以及 Mixed（混合模式）。不管采用的是什么模式，当然格式是二进制的。redo/undo 在 事务执行过程中 会不断的写入，而 binlog 是在 事务最终提交前 写入的。也就是二阶段提交。



### redolog和binlog区别

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

### update流程，binlog, redolog两阶段提交

了解了各个日志大概是干什么的 下面说说update流程:



<img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@vv1/v1/132.png" alt="img" style="zoom:50%;" />



```
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。
复制代码
```

为什么需要binlog和redolog的两阶段提交？

> 假如中午十二点误删了一个表，假如前一天备份了全量库，那么可以现在测试环境恢复备份库，然后把生产的binlog拿下来，重放到十二点的状态，然后再把这个库同步到线上就完成了。假如binlog不一致，binlog比redolog超前，那么其实相当于多运行了一个sql，如果redolog比binglog超前，那么其实相当于少运行了一个sql，因为redolog在物理层面上已经进行数据页的更新，所以需要进行二阶段提交保证数据的一致性。

### binlog格式

有三种格式，statement，row和mixed。

statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。

row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。

mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。


## Mysql抖动

第一种是“redo log 写满了，要 fl78ush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。

第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：第一种是，还没有使用的；第二种是，使用了并且是干净页；第三种是，使用了并且是脏页。

InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。



## WAL如何保证事务一致性

> [参考](https://zhuanlan.zhihu.com/p/24900322)

只要看一下 WAL 中有哪些事务是数据库还没做完的，把这些事务的 log 找出来。**如果这个事务最后一条记录是 Commit**，那么由于 Write ahead 的特性可能还没写进去我们只需要根据 log 里的 Entry 和 NewValue 把值不管三七二十一覆盖一下就好了，这样就达到了和 WAL 一致的状态。**如果事务最后一条记录不是 Commit**，那么这个事务肯定没有执行完，我们根据 OldValue 的值进行覆盖就相当于 rollback 到了事务开始前的值。



除了带来事务一致性的保证，由于只需要把操作写到 WAL 里就可以认为操作完成而无需等待持久化真正的数据库变更完成就可以返回，数据库操作的效率也得到了一些提升。窍门在于 WAL 是顺序写入的一直在**文件末尾 append**，而持久化数据库的数据是一个随机写入操作，顺序写会节省大量的磁盘悬臂来回寻址的过程，效率要高好几个量级。

