---
layout: post
category: C
title: 四种类型转换符
tags: C
---

1. static_cast会进行静态的安全性检查，一般用于内置数据类型的转换和通常的类之间的转换。
1. const_cast主要是用来去掉指针和引用的const和volatile类型。
1. reinterpret_cast用于完全没有关系指针或引用之间的转换，比如字符指针转整形指针。
1. dynamic_cast通常用于基类和派生类之间的相互转换。

[参考网址](https://www.cnblogs.com/yabin/p/6363531.html)

## static_cast

用于将一种数据类型转换成另一种数据类型，使用格式如下：
变量1 = static_cast<变量1数据类型>(另外一种数据类型变量或表达式);

## const_cast

用于去除指针和引用的常量性，不能去除变量的常量性。使用格式如下：
指针或引用1 = const_cast<指针或引用1类型>(带常量性的指针或引用2);

## reinterpret_cast

reinterpret_cast这种强制类型转换是一种非常强的强制类型转换，它可以将任意两个无关的指针或引用进行转换。上面的static_cast进行强制类型转换时，会进行编译时的类型安全检查，即你可以将int转成float,将子类引用(指针)转成父类引用(指针)，子转父和父转子都可以，但父转子不安全。但是你不能使用static_cast将两个无关的东西进行转换，比如两个无关的类，因为编译器在编译的时候会检查这个转换是否可行，很明显不可行。

但是如果使用的reinterpret_cast强制类型转换，就不会进行静态类型检查直接放行通过。当然如果这两个类如果没有关系，那么在运行的过程就会“跑偏出错”。为了防止在运行的过程中“跑偏”，我们除静态类型转换(static_cast)之外还需要一个动态的类型转换(dynamic_cast).

## dynamic_cast

前面我们介绍过了static_cast，从名称上来看，两个一动(dynamic)一静(static)肯定有关系。我们知道static_cast会在编译的过程中进行安全性检查，而dynamic_cast会在运行的过程中进行安全性检查。这两个都带安全性检查可以防止错误的类型转换导致程序跑偏。

dynamic_cast既然是动态安全性检查，那么它肯定只能应用于指针或引用，不能用于内置的数据类型转换（内置的数据类型转换，在编译阶段由static_cast检查即可）。

dynamic_cast不但检查两个指针是否属于同一个继承树(static_cast也检查这个)，还会检测这种转换是否可行。如果可行就会返回一个新指针，并计算出为处理多继承的需要的必要的偏移量。如果不可行会返回NULL。因此即使我们使用reinterpret_cast强制类型转换骗过编译器编译成功，如果我们在使用前再使用dynamic_cast转换检测一下的话，还是能发现这个错误的转换的。